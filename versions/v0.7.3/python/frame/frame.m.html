<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>sparktk.frame.frame API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: Arial, Helvetica, sans;
    font-size: 14px;
  }
  #content {
    position: absolute;
    left: 25%;
    right: 0;
    top: 0;
    bottom: 0;
    overflow: auto;
    padding: 30px;
    height: 100%;
  }
  #sidebar {
    position: absolute;
    width: 25%;
    top: 0;
    right: 0;
    left: 0;
    padding: 30px;
    overflow: auto;
    height: 100%;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #fixed_top_left {
    display: block;
    position: fixed;
    top: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
    background: transparent;
    z-index: 1;  /* Set z-index so that it doesn't get lost behind the sidebar */
  }

  #footer {
    font-size: .75em;
    margin-top: 20px;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    font-size: 1.5em;
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name, .param-name {
    font-family: Consolas, "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }
  .section-header {
    font-weight: bold;
    padding: 10px 0 5px 0;
  }
  .param-name {
    font-weight: bold;
    text-align: left;
    vertical-align: top;
  }
  .param-type {
    font-style: italic;
    text-align: left;
    vertical-align: top;
    padding-left: 5px;
  }
  .param-desc {
    text-align: left;
    vertical-align: top;
    padding-left: 5px;
  }
  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
      background: #f9f9f9;
      font-size: 13px;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 20px 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
  <a href="index.html" id="fixed_top_left">Up</a>
  <!--<a href="#" id="top">Top</a>-->
  <div id="container">
      
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#sparktk.frame.frame.create">create</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.import_csv">import_csv</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.import_hbase">import_hbase</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.import_hive">import_hive</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.import_jdbc">import_jdbc</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.import_pandas">import_pandas</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#sparktk.frame.frame.Frame">Frame</a></span>
        
          
  <ul>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.create_scala_frame">create_scala_frame</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.create_scala_frame_from_scala_dataframe">create_scala_frame_from_scala_dataframe</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.__init__">__init__</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.add_columns">add_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.append">append</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.append_csv_file">append_csv_file</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.assign_sample">assign_sample</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.bin_column">bin_column</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.binary_classification_metrics">binary_classification_metrics</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.box_cox">box_cox</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.categorical_summary">categorical_summary</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.collect">collect</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.column_median">column_median</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.column_mode">column_mode</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.column_summary_statistics">column_summary_statistics</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.copy">copy</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.correlation">correlation</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.correlation_matrix">correlation_matrix</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.count">count</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.covariance">covariance</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.covariance_matrix">covariance_matrix</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.cumulative_percent">cumulative_percent</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.cumulative_sum">cumulative_sum</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.dot_product">dot_product</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.drop_columns">drop_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.drop_duplicates">drop_duplicates</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.drop_rows">drop_rows</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.ecdf">ecdf</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.entropy">entropy</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.export_to_csv">export_to_csv</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.export_to_hbase">export_to_hbase</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.export_to_hive">export_to_hive</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.export_to_jdbc">export_to_jdbc</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.export_to_json">export_to_json</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.filter">filter</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.flatten_columns">flatten_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.group_by">group_by</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.histogram">histogram</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.inspect">inspect</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.is_python_rdd">is_python_rdd</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.is_scala_dataframe">is_scala_dataframe</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.is_scala_rdd">is_scala_rdd</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.join_inner">join_inner</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.join_left">join_left</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.join_outer">join_outer</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.join_right">join_right</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.map_columns">map_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.matrix_covariance_matrix">matrix_covariance_matrix</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.matrix_pca">matrix_pca</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.matrix_svd">matrix_svd</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.multiclass_classification_metrics">multiclass_classification_metrics</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.power_iteration_clustering">power_iteration_clustering</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.quantile_bin_column">quantile_bin_column</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.quantiles">quantiles</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.rename_columns">rename_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.reverse_box_cox">reverse_box_cox</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.save">save</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.sort">sort</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.sorted_k">sorted_k</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.take">take</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.tally">tally</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.tally_percent">tally_percent</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_augmented_dickey_fuller_test">timeseries_augmented_dickey_fuller_test</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_breusch_godfrey_test">timeseries_breusch_godfrey_test</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_breusch_pagan_test">timeseries_breusch_pagan_test</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_durbin_watson_test">timeseries_durbin_watson_test</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_from_observations">timeseries_from_observations</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.timeseries_slice">timeseries_slice</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.to_pandas">to_pandas</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.top_k">top_k</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.unflatten_columns">unflatten_columns</a></li>
    <li class="mono"><a href="#sparktk.frame.frame.Frame.validate_pyrdd_schema">validate_pyrdd_schema</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

      <article id="content">
        <div>
        
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">sparktk.frame.frame</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame" class="source">
    <div class="codehilite"><pre><span class="c"># vim: set encoding=utf-8</span>

<span class="c">#  Copyright (c) 2016 Intel Corporation </span>
<span class="c">#</span>
<span class="c">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c">#  you may not use this file except in compliance with the License.</span>
<span class="c">#  You may obtain a copy of the License at</span>
<span class="c">#</span>
<span class="c">#       http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c">#</span>
<span class="c">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="c">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c">#  See the License for the specific language governing permissions and</span>
<span class="c">#  limitations under the License.</span>
<span class="c">#</span>

<span class="kn">from</span> <span class="nn">pyspark.rdd</span> <span class="kn">import</span> <span class="n">RDD</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="kn">from</span> <span class="nn">sparktk.frame.pyframe</span> <span class="kn">import</span> <span class="n">PythonFrame</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.schema</span> <span class="kn">import</span> <span class="n">schema_to_python</span><span class="p">,</span> <span class="n">schema_to_scala</span>
<span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;sparktk&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sparktk.propobj</span> <span class="kn">import</span> <span class="n">PropertiesObject</span>

<span class="c"># import constructors for the API&#39;s sake (not actually dependencies of the Frame class)</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.create</span> <span class="kn">import</span> <span class="n">create</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.import_csv</span> <span class="kn">import</span> <span class="n">import_csv</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.import_hbase</span> <span class="kn">import</span> <span class="n">import_hbase</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.import_hive</span> <span class="kn">import</span> <span class="n">import_hive</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.import_jdbc</span> <span class="kn">import</span> <span class="n">import_jdbc</span>
<span class="kn">from</span> <span class="nn">sparktk.frame.constructors.import_pandas</span> <span class="kn">import</span> <span class="n">import_pandas</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;create&quot;</span><span class="p">,</span>
           <span class="s">&quot;Frame&quot;</span><span class="p">,</span>
           <span class="s">&quot;import_csv&quot;</span><span class="p">,</span>
           <span class="s">&quot;import_hbase&quot;</span><span class="p">,</span>
           <span class="s">&quot;import_hive&quot;</span><span class="p">,</span>
           <span class="s">&quot;import_jdbc&quot;</span><span class="p">,</span>
           <span class="s">&quot;import_pandas&quot;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Frame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">validate_schema</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala_frame</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_rdd</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_dataframe</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">_jdf</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">PythonFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">source</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid data source.  The data parameter must be a 2-dimensional list (list of row data) or an RDD.&quot;</span><span class="p">)</span>

                <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                        <span class="c"># check if schema is just a list of column names (versus string and data type tuples)</span>
                        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                        <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  Expected a list of tuples (str, type) with the column name and data type, but received type </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
                    <span class="c"># check for duplicate column names</span>
                    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
                    <span class="n">duplicate_column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span> <span class="k">if</span> <span class="n">column_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid schema, column names cannot be duplicated: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">schema</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Schema is not a list or None</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema type: </span><span class="si">%s</span><span class="s">.  Expected a list of tuples (str, type) with the column name and data type.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_supported_datatype</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">inferred_schema</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;The </span><span class="si">%s</span><span class="s"> data type was found when inferring the schema, and it is not a &quot;</span>
                                            <span class="s">&quot;supported data type.  Instead, specify a schema that uses a supported data &quot;</span>
                                            <span class="s">&quot;type, and enable validate_schema so that the data is converted to the proper &quot;</span>
                                            <span class="s">&quot;data type.</span><span class="se">\n\n</span><span class="s">Inferred schema: </span><span class="si">%s</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">schema</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  </span><span class="si">%s</span><span class="s"> is not a supported data type.</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>

                <span class="n">source</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">and</span> <span class="n">validate_schema</span><span class="p">:</span>
                <span class="c"># Validate schema by going through the data and checking the data type and attempting to parse it</span>
                <span class="n">validate_schema_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pyrdd_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">validated_rdd</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> values were unable to be parsed to the schema&#39;s data type.&quot;</span> <span class="o">%</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">bad_value_count</span><span class="p">)</span>

            <span class="c"># If schema contains matrix datatype, then apply type_coercer to convert list[list] to numpy ndarray</span>
            <span class="n">map_source</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">map_source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_merge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_list_a</span><span class="p">,</span> <span class="n">type_list_b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two lists of data types</span>

<span class="sd">        :param type_list_a: First list of data types to merge</span>
<span class="sd">        :param type_list_b: Second list of data types to merge</span>
<span class="sd">        :return: List of merged data types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to generate schema, because schema is not a list.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of each row must be the same (found rows with lengths: </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dtypes</span><span class="o">.</span><span class="n">_DataTypes</span><span class="o">.</span><span class="n">merge_types</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">type_list_b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">_infer_types_for_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of data types for the data in the specified row</span>

<span class="sd">        :param row: List or Row of data</span>
<span class="sd">        :return: List of data types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inferred_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">vector</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">inferred_types</span>

    <span class="k">def</span> <span class="nf">_infer_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infers the schema based on the data in the RDD.</span>

<span class="sd">        :param sc: Spark Context</span>
<span class="sd">        :param data: Data used to infer schema</span>
<span class="sd">        :param column_names: Optional column names to use in the schema.  If no column names are provided, columns</span>
<span class="sd">                             are given numbered names.  If there are more columns in the RDD than there are in the</span>
<span class="sd">                             column_names list, remaining columns will be numbered.</span>
<span class="sd">        :param sample_size: Number of rows to check when inferring the schema.  Defaults to 100.</span>
<span class="sd">        :return: Schema</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inferred_schema</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># get the schema for the first row</span>
                <span class="n">data_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_types_for_row</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">):</span>
                    <span class="n">data_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_types</span><span class="p">(</span><span class="n">data_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_types_for_row</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_types</span><span class="p">):</span>
                    <span class="n">column_name</span> <span class="o">=</span> <span class="s">&quot;C</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">column_name</span> <span class="o">=</span> <span class="n">column_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">inferred_schema</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">column_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to infer schema, because the data provided is not a list.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inferred_schema</span>

    <span class="k">def</span> <span class="nf">_is_supported_datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified data_type is supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">supported_primitives</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="n">supported_primitives</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">validate_pyrdd_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyrdd</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pyrdd</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
            <span class="n">schema_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
            <span class="n">num_bad_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">accumulator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">accumulator</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">schema_length</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of the row (</span><span class="si">%s</span><span class="s">) does not match the schema length (</span><span class="si">%s</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data_type</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                        <span class="n">accumulator</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="n">validated_rdd</span> <span class="o">=</span> <span class="n">pyrdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="p">))</span>

            <span class="c"># Force rdd to load, so that we can get a bad value count</span>
            <span class="n">validated_rdd</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">SchemaValidationReturn</span><span class="p">(</span><span class="n">validated_rdd</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to validate schema, because the pyrdd provided is not an RDD.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_scala_frame</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_dataframe</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_scala</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a python Frame for the given scala Frame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_frame_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">python_frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;converts a PythonFrame to a Scala Frame&quot;&quot;&quot;</span>
        <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">python_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">scala_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">pythonToScala</span><span class="p">(</span><span class="n">python_frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">_jrdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_scala_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">RDD</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_scala_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_python_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">RDD</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;answers whether the current frame is backed by a Scala Frame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_python</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;answers whether the current frame is backed by a _PythonFrame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets frame backend as Scala Frame, causes conversion if it is current not&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_python</span><span class="p">:</span>
            <span class="c"># If schema contains matrix dataype,</span>
            <span class="c"># then apply type_coercer_pymlib to convert ndarray to pymlib DenseMatrix for serialization purpose at java</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
            <span class="c"># convert PythonFrame to a Scala Frame&quot;&quot;&quot;</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
            <span class="n">scala_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">pythonToScala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">_jrdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_python</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets frame backend as _PythonFrame, causes conversion if it is current not&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
            <span class="c"># convert Scala Frame to a PythonFrame&quot;&quot;&quot;</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">()</span>
            <span class="n">java_rdd</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">scalaToPython</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="p">())</span>
            <span class="n">python_schema</span> <span class="o">=</span> <span class="n">schema_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
            <span class="n">python_rdd</span> <span class="o">=</span> <span class="n">RDD</span><span class="p">(</span><span class="n">java_rdd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span>
            <span class="c"># If schema contains matrix datatype, then apply type_coercer to convert list[list] to numpy ndarray</span>
            <span class="n">map_python_rdd</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="n">python_rdd</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">python_schema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">map_python_rdd</span><span class="p">,</span> <span class="n">python_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span>

    <span class="c">##########################################################################</span>
    <span class="c"># API</span>
    <span class="c">##########################################################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pyspark RDD  (causes conversion if currently backed by a Scala RDD)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">schema_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">())</span>  <span class="c"># need ()&#39;s on schema because it&#39;s a def in scala</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">dataframe</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sql_context</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Column identifications in the current frame.</span>

<span class="sd">        :return: list of names of all the frame&#39;s columns</span>

<span class="sd">        Returns the names of the columns of the current frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">            &gt;&gt;&gt; frame.column_names</span>
<span class="sd">            [u&#39;name&#39;, u&#39;age&#39;, u&#39;tenure&#39;, u&#39;phone&#39;]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append_csv_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">appendCsvFile</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">),</span> <span class="n">separator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToCsv</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="c"># Frame Operations</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.add_columns</span> <span class="kn">import</span> <span class="n">add_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.append</span> <span class="kn">import</span> <span class="n">append</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.assign_sample</span> <span class="kn">import</span> <span class="n">assign_sample</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.bin_column</span> <span class="kn">import</span> <span class="n">bin_column</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.binary_classification_metrics</span> <span class="kn">import</span> <span class="n">binary_classification_metrics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.box_cox</span> <span class="kn">import</span> <span class="n">box_cox</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.categorical_summary</span> <span class="kn">import</span> <span class="n">categorical_summary</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.collect</span> <span class="kn">import</span> <span class="n">collect</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_median</span> <span class="kn">import</span> <span class="n">column_median</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_mode</span> <span class="kn">import</span> <span class="n">column_mode</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_summary_statistics</span> <span class="kn">import</span> <span class="n">column_summary_statistics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.copy</span> <span class="kn">import</span> <span class="n">copy</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.correlation</span> <span class="kn">import</span> <span class="n">correlation</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.correlation_matrix</span> <span class="kn">import</span> <span class="n">correlation_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.count</span> <span class="kn">import</span> <span class="n">count</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.covariance</span> <span class="kn">import</span> <span class="n">covariance</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.covariance_matrix</span> <span class="kn">import</span> <span class="n">covariance_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.cumulative_percent</span> <span class="kn">import</span> <span class="n">cumulative_percent</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.cumulative_sum</span> <span class="kn">import</span> <span class="n">cumulative_sum</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.dot_product</span> <span class="kn">import</span> <span class="n">dot_product</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_columns</span> <span class="kn">import</span> <span class="n">drop_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_duplicates</span> <span class="kn">import</span> <span class="n">drop_duplicates</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_rows</span> <span class="kn">import</span> <span class="n">drop_rows</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.ecdf</span> <span class="kn">import</span> <span class="n">ecdf</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.entropy</span> <span class="kn">import</span> <span class="n">entropy</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.export_data</span> <span class="kn">import</span> <span class="n">export_to_jdbc</span><span class="p">,</span> <span class="n">export_to_json</span><span class="p">,</span> <span class="n">export_to_hbase</span><span class="p">,</span> <span class="n">export_to_hive</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.filter</span> <span class="kn">import</span> <span class="nb">filter</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.flatten_columns</span> <span class="kn">import</span> <span class="n">flatten_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.group_by</span> <span class="kn">import</span> <span class="n">group_by</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.histogram</span> <span class="kn">import</span> <span class="n">histogram</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.inspect</span> <span class="kn">import</span> <span class="n">inspect</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_inner</span> <span class="kn">import</span> <span class="n">join_inner</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_left</span> <span class="kn">import</span> <span class="n">join_left</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_right</span> <span class="kn">import</span> <span class="n">join_right</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_outer</span> <span class="kn">import</span> <span class="n">join_outer</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.map_columns</span> <span class="kn">import</span> <span class="n">map_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_covariance_matrix</span> <span class="kn">import</span> <span class="n">matrix_covariance_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_pca</span> <span class="kn">import</span> <span class="n">matrix_pca</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_svd</span> <span class="kn">import</span> <span class="n">matrix_svd</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.multiclass_classification_metrics</span> <span class="kn">import</span> <span class="n">multiclass_classification_metrics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.power_iteration_clustering</span> <span class="kn">import</span> <span class="n">power_iteration_clustering</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.quantile_bin_column</span> <span class="kn">import</span> <span class="n">quantile_bin_column</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.quantiles</span> <span class="kn">import</span> <span class="n">quantiles</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.rename_columns</span> <span class="kn">import</span> <span class="n">rename_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.reverse_box_cox</span> <span class="kn">import</span> <span class="n">reverse_box_cox</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.save</span> <span class="kn">import</span> <span class="n">save</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.sort</span> <span class="kn">import</span> <span class="n">sort</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.sortedk</span> <span class="kn">import</span> <span class="n">sorted_k</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.take</span> <span class="kn">import</span> <span class="n">take</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.tally</span> <span class="kn">import</span> <span class="n">tally</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.tally_percent</span> <span class="kn">import</span> <span class="n">tally_percent</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_augmented_dickey_fuller_test</span> <span class="kn">import</span> <span class="n">timeseries_augmented_dickey_fuller_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_breusch_godfrey_test</span> <span class="kn">import</span> <span class="n">timeseries_breusch_godfrey_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_breusch_pagan_test</span> <span class="kn">import</span> <span class="n">timeseries_breusch_pagan_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_durbin_watson_test</span> <span class="kn">import</span> <span class="n">timeseries_durbin_watson_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_from_observations</span> <span class="kn">import</span> <span class="n">timeseries_from_observations</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_slice</span> <span class="kn">import</span> <span class="n">timeseries_slice</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.to_pandas</span> <span class="kn">import</span> <span class="n">to_pandas</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.topk</span> <span class="kn">import</span> <span class="n">top_k</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.unflatten_columns</span> <span class="kn">import</span> <span class="n">unflatten_columns</span>


<span class="k">class</span> <span class="nc">SchemaValidationReturn</span><span class="p">(</span><span class="n">PropertiesObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return value from schema validation that includes the rdd of validated values and the number of bad values</span>
<span class="sd">    that were found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validated_rdd</span><span class="p">,</span> <span class="n">bad_value_count</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validated_rdd</span> <span class="o">=</span> <span class="n">validated_rdd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bad_value_count</span> <span class="o">=</span> <span class="n">bad_value_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">validated_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RDD of values that have been casted to the data type specified by the frame&#39;s schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validated_rdd</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bad_value_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of values that were unable to be parsed to the data type specified by the schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_value_count</span>


<span class="k">class</span> <span class="nc">MatrixCoercion</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">schema_is_coercible</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">python_schema</span><span class="p">,</span> <span class="n">in_scala</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check whether python schema is coercible or not.</span>
<span class="sd">        Like if schema contains matrix datatype, convert list[list] to numpy ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">schema</span> <span class="ow">in</span> <span class="n">python_schema</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_Matrix</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_scala</span><span class="p">:</span>
                <span class="n">map_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">type_coercer_pymllib</span><span class="p">(</span><span class="n">python_schema</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">map_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">type_coercer</span><span class="p">(</span><span class="n">python_schema</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_source</span> <span class="o">=</span> <span class="n">source</span>

        <span class="k">return</span> <span class="n">map_source</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">type_coercer</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When creating a new frame(python frame created) or converting frame from scala to python frame,</span>
<span class="sd">        the function scans a row and performs below</span>
<span class="sd">            * when creating a new frame(python frame created) - if it finds list[list](which represents matrix) as column value,</span>
<span class="sd">              converts it to numpy ndarray</span>
<span class="sd">            * when Converting frame from scala to python frame - (scala converts DenseMatrix--&gt; JList[JList[Double]](in JConvert.scala),</span>
<span class="sd">              jconvert.py converts JList[JList[Double]] --&gt; list[list[float64]]), converts list[list] to ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_Matrix</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">decorator</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">type_coercer_pymllib</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When converting from python to scala, function scans the row and converts the ndarray</span>
<span class="sd">        to python mllib DenseMatrix. so that autopicklers understands how to serialize from pyspark mllib DenseMatrix to Scala MLlib DenseMatrix.</span>
<span class="sd">        For Serialization to work we have to explicitly call SparkAliases.getSparkMLLibSerDe in pythonToScala() method of PythonJavaRdd.scala class</span>

<span class="sd">        ndarray stores data as row-major where as mllib densematrix stores data as column-major.</span>
<span class="sd">        To construct mllib DenseMatrix with row-major we are setting isTransposed=True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="kn">from</span> <span class="nn">pyspark.mllib.linalg</span> <span class="kn">import</span> <span class="n">DenseMatrix</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_Matrix</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">arr</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="c"># By default Mllib DenseMatrix constructs column-major matrix.</span>
                    <span class="c"># Setting isTranposed=True, will construct row-major DenseMatrix</span>
                    <span class="n">dm</span> <span class="o">=</span> <span class="n">DenseMatrix</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">,</span> <span class="n">isTransposed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">decorator</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.create">
    <p>def <span class="ident">create</span>(</p><p>data, schema=None, validate_schema=False, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a frame from the given data and schema.  If no schema data types are provided, the schema is inferred
based on the data in the first 100 rows.</p>
<p>If schema validation is enabled, all data is is checked to ensure that it matches the schema.  If the data does
not match the schema's data type, it attempts to cast the data to the proper data type.  When the data is unable
to be casted to the schema's data type, the item will be missing (None) in the frame.</p>
<table><tr><td class='param-name'>data</td><td class='param-type'>(List of row data or RDD):</td><td class='param-desc'>Data source
</td></tr></table>

<table><tr><td class='param-name'>schema</td><td class='param-type'>(Optional(list[tuple(str, type)] or list[str])] Optionally specify a schema (list of tuples of
               string column names and data type), column names (list of strings, and the column data types will
               be inferred):</td><td class='param-desc'>or None (column data types will be inferred and column names will be numbered like C0,
               C1, C2, etc).
</td></tr></table>

<table><tr><td class='param-name'>validate_schema</td><td class='param-type'>(Optional(bool)):</td><td class='param-desc'>When True, all data is checked to ensure that it matches the schema.
                        If the data does not match the schema's data type, it attempts to cast the data to the
                        proper data type.  When the data is unable to be casted to the schema's data type, a
                        missing value (None) is inserted in it's place. Defaults to False.
</td></tr></table>

<table><tr><td class='param-name'>tc: </td><td class='param-desc'>TkContext
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>Frame loaded with the specified data</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Create a frame with the specified data.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[&quot;Bob&quot;, 30, 8], [&quot;Jim&quot;, 45, 9.5], [&quot;Sue&quot;, 25, 7], [&quot;George&quot;, 15, 6], [&quot;Jennifer&quot;, 18, 8.5]]
&gt;&gt;&gt; frame = tc.frame.create(data)
</pre></div>


<p>Since no schema is provided, the schema will be inferred.  Note that the data set had a mix of strings and
integers in the third column.  The schema will use the most general data type from the data that it sees, so in
this example, the column is treated as a float.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.schema
[(&#39;C0&#39;, &lt;type &#39;str&#39;&gt;), (&#39;C1&#39;, &lt;type &#39;int&#39;&gt;), (&#39;C2&#39;, &lt;type &#39;float&#39;&gt;)]

&gt;&gt;&gt; frame.inspect()
[#]  C0        C1  C2
======================
[0]  Bob       30    8
[1]  Jim       45  9.5
[2]  Sue       25    7
[3]  George    15    6
[4]  Jennifer  18  8.5
</pre></div>


<p>We could also enable schema validation, which checks the data against the schema.  If the data does not match the
schema's data type, it attempts to cast the data to the proper data type.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create(data, validate_schema=True)
</pre></div>


<p>In this example with schema validation enabled, the integers in column C2 get casted to floats:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  C0        C1  C2
======================
[0]  Bob       30  8.0
[1]  Jim       45  9.5
[2]  Sue       25  7.0
[3]  George    15  6.0
[4]  Jennifer  18  8.5
</pre></div>


<p>We could also provide a list of column names when creating the frame.  When a list of column names is provided,
the data types for the schema are still inferred, but the columns in the schema are labeled with the specified names.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create(data, schema=[&quot;name&quot;, &quot;age&quot;, &quot;shoe_size&quot;], validate_schema=True)

&gt;&gt;&gt; frame.schema
[(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;age&#39;, &lt;type &#39;int&#39;&gt;), (&#39;shoe_size&#39;, &lt;type &#39;float&#39;&gt;)]

&gt;&gt;&gt; frame.inspect()
[#]  name      age  shoe_size
=============================
[0]  Bob        30        8.0
[1]  Jim        45        9.5
[2]  Sue        25        7.0
[3]  George     15        6.0
[4]  Jennifer   18        8.5
</pre></div>


<p>Note that if a value cannot be parsed as the specified data type in the schema, it will show up as missing (None),
if validate_schema is enabled.  For example, consider the following frame where columns are defined as integers,
but the data specified has a string in the second row.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[1, 2, 3], [4, &quot;five&quot;, 6]]
&gt;&gt;&gt; schema = [(&quot;a&quot;, int), (&quot;b&quot;, int), (&quot;c&quot;, int)]

&gt;&gt;&gt; frame = tc.frame.create(data, schema, validate_schema = True)

&gt;&gt;&gt; frame.inspect()
[#]  a  b     c
===============
[0]  1     2  3
[1]  4  None  6
</pre></div>


<p>Note that the spot where the string was located, has it's value missing (None) since it couldn't be parsed to an
integer.  If validate_schema was disabled, no attempt is made to parse the data to the data type specified by the
schema, and further frame operations may fail due to the data type discrepancy.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.create', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.create" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">validate_schema</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a frame from the given data and schema.  If no schema data types are provided, the schema is inferred</span>
<span class="sd">    based on the data in the first 100 rows.</span>

<span class="sd">    If schema validation is enabled, all data is is checked to ensure that it matches the schema.  If the data does</span>
<span class="sd">    not match the schema&#39;s data type, it attempts to cast the data to the proper data type.  When the data is unable</span>
<span class="sd">    to be casted to the schema&#39;s data type, the item will be missing (None) in the frame.</span>

<span class="sd">    :param data: (List of row data or RDD) Data source</span>
<span class="sd">    :param schema: (Optional(list[tuple(str, type)] or list[str])] Optionally specify a schema (list of tuples of</span>
<span class="sd">                   string column names and data type), column names (list of strings, and the column data types will</span>
<span class="sd">                   be inferred) or None (column data types will be inferred and column names will be numbered like C0,</span>
<span class="sd">                   C1, C2, etc).</span>
<span class="sd">    :param validate_schema: (Optional(bool)) When True, all data is checked to ensure that it matches the schema.</span>
<span class="sd">                            If the data does not match the schema&#39;s data type, it attempts to cast the data to the</span>
<span class="sd">                            proper data type.  When the data is unable to be casted to the schema&#39;s data type, a</span>
<span class="sd">                            missing value (None) is inserted in it&#39;s place. Defaults to False.</span>
<span class="sd">    :param tc: TkContext</span>
<span class="sd">    :return: (Frame) Frame loaded with the specified data</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a frame with the specified data.</span>

<span class="sd">        &gt;&gt;&gt; data = [[&quot;Bob&quot;, 30, 8], [&quot;Jim&quot;, 45, 9.5], [&quot;Sue&quot;, 25, 7], [&quot;George&quot;, 15, 6], [&quot;Jennifer&quot;, 18, 8.5]]</span>
<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create(data)</span>

<span class="sd">    Since no schema is provided, the schema will be inferred.  Note that the data set had a mix of strings and</span>
<span class="sd">    integers in the third column.  The schema will use the most general data type from the data that it sees, so in</span>
<span class="sd">    this example, the column is treated as a float.</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;C0&#39;, &lt;type &#39;str&#39;&gt;), (&#39;C1&#39;, &lt;type &#39;int&#39;&gt;), (&#39;C2&#39;, &lt;type &#39;float&#39;&gt;)]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  C0        C1  C2</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]  Bob       30    8</span>
<span class="sd">        [1]  Jim       45  9.5</span>
<span class="sd">        [2]  Sue       25    7</span>
<span class="sd">        [3]  George    15    6</span>
<span class="sd">        [4]  Jennifer  18  8.5</span>

<span class="sd">    We could also enable schema validation, which checks the data against the schema.  If the data does not match the</span>
<span class="sd">    schema&#39;s data type, it attempts to cast the data to the proper data type.</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create(data, validate_schema=True)</span>

<span class="sd">    In this example with schema validation enabled, the integers in column C2 get casted to floats:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  C0        C1  C2</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]  Bob       30  8.0</span>
<span class="sd">        [1]  Jim       45  9.5</span>
<span class="sd">        [2]  Sue       25  7.0</span>
<span class="sd">        [3]  George    15  6.0</span>
<span class="sd">        [4]  Jennifer  18  8.5</span>

<span class="sd">    We could also provide a list of column names when creating the frame.  When a list of column names is provided,</span>
<span class="sd">    the data types for the schema are still inferred, but the columns in the schema are labeled with the specified names.</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create(data, schema=[&quot;name&quot;, &quot;age&quot;, &quot;shoe_size&quot;], validate_schema=True)</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;age&#39;, &lt;type &#39;int&#39;&gt;), (&#39;shoe_size&#39;, &lt;type &#39;float&#39;&gt;)]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  shoe_size</span>
<span class="sd">        =============================</span>
<span class="sd">        [0]  Bob        30        8.0</span>
<span class="sd">        [1]  Jim        45        9.5</span>
<span class="sd">        [2]  Sue        25        7.0</span>
<span class="sd">        [3]  George     15        6.0</span>
<span class="sd">        [4]  Jennifer   18        8.5</span>

<span class="sd">    Note that if a value cannot be parsed as the specified data type in the schema, it will show up as missing (None),</span>
<span class="sd">    if validate_schema is enabled.  For example, consider the following frame where columns are defined as integers,</span>
<span class="sd">    but the data specified has a string in the second row.</span>

<span class="sd">        &gt;&gt;&gt; data = [[1, 2, 3], [4, &quot;five&quot;, 6]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&quot;a&quot;, int), (&quot;b&quot;, int), (&quot;c&quot;, int)]</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create(data, schema, validate_schema = True)</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b     c</span>
<span class="sd">        ===============</span>
<span class="sd">        [0]  1     2  3</span>
<span class="sd">        [1]  4  None  6</span>

<span class="sd">    Note that the spot where the string was located, has it&#39;s value missing (None) since it couldn&#39;t be parsed to an</span>
<span class="sd">    integer.  If validate_schema was disabled, no attempt is made to parse the data to the data type specified by the</span>
<span class="sd">    schema, and further frame operations may fail due to the data type discrepancy.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>\
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">RDD</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">))</span>\
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">RDD</span><span class="p">)</span>\
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid data source. Expected the data parameter to be a 2-dimensional list (list of row data) or an RDD or DataFrame, but received: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">validate_schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.import_csv">
    <p>def <span class="ident">import_csv</span>(</p><p>path, delimiter=&#39;,&#39;, header=False, infer_schema=True, schema=None, datetime_format=&#34;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSX&#34;, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a frame with data from a csv file.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>path</td><td class='param-type'>(str):</td><td class='param-desc'>Full path to the csv file
</td></tr></table>

<table><tr><td class='param-name'>delimiter</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>A string which indicates the separation of data fields.  This is usually a
                  single character and could be a non-visible character, such as a tab. The default delimiter
                  is a comma (,).
</td></tr></table>

<table><tr><td class='param-name'>header</td><td class='param-type'>(Optional[bool]):</td><td class='param-desc'>Boolean value indicating if the first line of the file will be used to name columns,
               and not be included in the data.  The default value is false.
</td></tr></table>

<p>:param infer_schema:(Optional[bool]) Boolean value indicating if the column types will be automatically inferred.
                   It requires one extra pass over the data and is false by default.
<table><tr><td class='param-name'>schema</td><td class='param-type'>(Optional[List[tuple(str, type)]]):</td><td class='param-desc'>Optionally specify the schema for the dataset.  Number of
                columns specified in the schema must match the number of columns in the csv file provided.  If the
                value from the csv file cannot be converted to the data type specified by the schema (for example,
                if the csv file has a string, and the schema specifies an int), the value will show up as missing
                (None) in the frame.
</td></tr></table><table><tr><td class='param-name'>datetime_format</td><td class='param-type'>(str):</td><td class='param-desc'>String specifying how date/time columns are formatted, using the java.text.SimpleDateFormat
                    specified at https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html
</td></tr></table><p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>Frame that contains the data from the csv file</td></tr></table></p></p>
<div class='section-header'>Examples:</div>

<p>Load a frame from a csv file by specifying the path to the file, delimiter, and options that specify that
there is a header and to infer the schema based on the data.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; file_path = &quot;../datasets/cities.csv&quot;

&gt;&gt;&gt; frame = tc.frame.import_csv(file_path, &quot;|&quot;, header=True, infer_schema=True)
-etc-

&gt;&gt;&gt; frame.inspect()
[#]  rank  city         population_2013  population_2010  change  county
============================================================================
[0]     1  Portland              609456           583776  4.40%   Multnomah
[1]     2  Salem                 160614           154637  3.87%   Marion
[2]     3  Eugene                159190           156185  1.92%   Lane
[3]     4  Gresham               109397           105594  3.60%   Multnomah
[4]     5  Hillsboro              97368            91611  6.28%   Washington
[5]     6  Beaverton              93542            89803  4.16%   Washington
[6]    15  Grants Pass            35076            34533  1.57%   Josephine
[7]    16  Oregon City            34622            31859  8.67%   Clackamas
[8]    17  McMinnville            33131            32187  2.93%   Yamhill
[9]    18  Redmond                27427            26215  4.62%   Deschutes

&gt;&gt;&gt; frame.schema
[(&#39;rank&#39;, &lt;type &#39;int&#39;&gt;), (&#39;city&#39;, &lt;type &#39;str&#39;&gt;), (&#39;population_2013&#39;, &lt;type &#39;int&#39;&gt;), (&#39;population_2010&#39;, &lt;type &#39;int&#39;&gt;), (&#39;change&#39;, &lt;type &#39;str&#39;&gt;), (&#39;county&#39;, &lt;type &#39;str&#39;&gt;)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.import_csv', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.import_csv" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">import_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">infer_schema</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">datetime_format</span><span class="o">=</span><span class="s">&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSX&quot;</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a frame with data from a csv file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param path: (str) Full path to the csv file</span>
<span class="sd">    :param delimiter: (Optional[str]) A string which indicates the separation of data fields.  This is usually a</span>
<span class="sd">                      single character and could be a non-visible character, such as a tab. The default delimiter</span>
<span class="sd">                      is a comma (,).</span>
<span class="sd">    :param header: (Optional[bool]) Boolean value indicating if the first line of the file will be used to name columns,</span>
<span class="sd">                   and not be included in the data.  The default value is false.</span>
<span class="sd">    :param infer_schema:(Optional[bool]) Boolean value indicating if the column types will be automatically inferred.</span>
<span class="sd">                       It requires one extra pass over the data and is false by default.</span>
<span class="sd">    :param schema: (Optional[List[tuple(str, type)]]) Optionally specify the schema for the dataset.  Number of</span>
<span class="sd">                    columns specified in the schema must match the number of columns in the csv file provided.  If the</span>
<span class="sd">                    value from the csv file cannot be converted to the data type specified by the schema (for example,</span>
<span class="sd">                    if the csv file has a string, and the schema specifies an int), the value will show up as missing</span>
<span class="sd">                    (None) in the frame.</span>
<span class="sd">    :param datetime_format: (str) String specifying how date/time columns are formatted, using the java.text.SimpleDateFormat</span>
<span class="sd">                        specified at https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html</span>
<span class="sd">    :return: (Frame) Frame that contains the data from the csv file</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load a frame from a csv file by specifying the path to the file, delimiter, and options that specify that</span>
<span class="sd">    there is a header and to infer the schema based on the data.</span>


<span class="sd">        &gt;&gt;&gt; file_path = &quot;../datasets/cities.csv&quot;</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_csv(file_path, &quot;|&quot;, header=True, infer_schema=True)</span>
<span class="sd">        -etc-</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  rank  city         population_2013  population_2010  change  county</span>
<span class="sd">        ============================================================================</span>
<span class="sd">        [0]     1  Portland              609456           583776  4.40%   Multnomah</span>
<span class="sd">        [1]     2  Salem                 160614           154637  3.87%   Marion</span>
<span class="sd">        [2]     3  Eugene                159190           156185  1.92%   Lane</span>
<span class="sd">        [3]     4  Gresham               109397           105594  3.60%   Multnomah</span>
<span class="sd">        [4]     5  Hillsboro              97368            91611  6.28%   Washington</span>
<span class="sd">        [5]     6  Beaverton              93542            89803  4.16%   Washington</span>
<span class="sd">        [6]    15  Grants Pass            35076            34533  1.57%   Josephine</span>
<span class="sd">        [7]    16  Oregon City            34622            31859  8.67%   Clackamas</span>
<span class="sd">        [8]    17  McMinnville            33131            32187  2.93%   Yamhill</span>
<span class="sd">        [9]    18  Redmond                27427            26215  4.62%   Deschutes</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;rank&#39;, &lt;type &#39;int&#39;&gt;), (&#39;city&#39;, &lt;type &#39;str&#39;&gt;), (&#39;population_2013&#39;, &lt;type &#39;int&#39;&gt;), (&#39;population_2010&#39;, &lt;type &#39;int&#39;&gt;), (&#39;change&#39;, &lt;type &#39;str&#39;&gt;), (&#39;county&#39;, &lt;type &#39;str&#39;&gt;)]</span>


<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">infer_schema</span> <span class="o">=</span> <span class="bp">False</span>   <span class="c"># if a custom schema is provided, don&#39;t waste time inferring the schema during load</span>
        <span class="n">sparktk_schema</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;header parameter must be a boolean, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">header</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">infer_schema</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;infer_schema parameter must be a boolean, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">infer_schema</span><span class="p">)))</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>

    <span class="n">header_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">infer_schema_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">infer_schema</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">pyspark_schema</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">infer_schema</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_data_type_to_pyspark_type_table</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">StructField</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_data_type_to_pyspark_type_table</span><span class="p">[</span><span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="bp">True</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unsupported type {0} in schema for column {1}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">pyspark_schema</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sql_context</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="s">&quot;com.databricks.spark.csv.org.trustedanalytics.sparktk&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
            <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header_str</span><span class="p">,</span>
            <span class="n">dateformat</span><span class="o">=</span><span class="n">datetime_format</span><span class="p">,</span>
            <span class="n">inferschema</span><span class="o">=</span><span class="n">infer_schema_str</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">pyspark_schema</span><span class="p">)</span>

    <span class="n">df_schema</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">get_primitive_type_from_pyspark_type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dataType</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unsupported data type ({0}) for column {1}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dataType</span><span class="p">),</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">df_schema</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">datatype</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_column_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
        <span class="n">custom_column_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">df_column_count</span> <span class="o">!=</span> <span class="n">custom_column_count</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Bad schema value.  The number of columns in the custom schema ({0}) must match the&quot;</span>
                             <span class="s">&quot;number of columns in the csv file data ({1}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">custom_column_count</span><span class="p">,</span> <span class="n">df_column_count</span><span class="p">))</span>
        <span class="n">df_schema</span> <span class="o">=</span> <span class="n">schema</span>

    <span class="k">def</span> <span class="nf">cast_datetime</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spark data frame gives uses datetime objects.  Convert them to long (ms since epoch) for our frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column_index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_schema</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">df_schema</span><span class="p">[</span><span class="n">column_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">datetime</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_index</span><span class="p">],</span> <span class="n">datetime</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">datetime_to_ms</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_index</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_index</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="n">jrdd</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">scalaToPython</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">_jdf</span><span class="o">.</span><span class="n">rdd</span><span class="p">())</span>
    <span class="n">rdd</span> <span class="o">=</span> <span class="n">RDD</span><span class="p">(</span><span class="n">jrdd</span><span class="p">,</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">datetime</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df_schema</span><span class="p">):</span>
        <span class="c"># If any columns are date/time we must do this map</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cast_datetime</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>  <span class="c"># circular dependency, so import late</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">rdd</span><span class="p">,</span> <span class="n">df_schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.import_hbase">
    <p>def <span class="ident">import_hbase</span>(</p><p>table_name, schema, start_tag=None, end_tag=None, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Import data from hbase table into frame</p>
<table><tr><td class='param-name'>table_name</td><td class='param-type'>(str):</td><td class='param-desc'>hbase table name
</td></tr></table>

<table><tr><td class='param-name'>schema</td><td class='param-type'>(list[list[str, str, type]]):</td><td class='param-desc'>hbase schema as a List of List(string) (columnFamily, columnName,
               dataType for cell value)
</td></tr></table>

<table><tr><td class='param-name'>start_tag</td><td class='param-type'>(Optional(str)):</td><td class='param-desc'>optional start tag for filtering
</td></tr></table>

<table><tr><td class='param-name'>end_tag</td><td class='param-type'>(Optional(str)):</td><td class='param-desc'>optional end tag for filtering
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>frame with data from hbase table</td></tr></table></p>

<div class='section-header'>Example:</div>

<p>Load data into frame from a hbase table</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.import_hbase(&quot;demo_test_hbase&quot;, [[&quot;test_family&quot;, &quot;a&quot;, int],[&quot;test_family&quot;, &quot;b&quot;, float], [&quot;test_family&quot;, &quot;c&quot;, int],[&quot;test_family&quot;, &quot;d&quot;, int]])
-etc-
&gt;&gt;&gt; frame.inspect()
[#]  test_family_a  test_family_b  test_family_c  test_family_d
===============================================================
[0]              1            0.2             -2              5
[1]              2            0.4             -1              6
[2]              3            0.6              0              7
[3]              4            0.8              1              8

Use of start_tag and end_tag. (Hbase creates a unique row id for data in hbase tables)
start_tag: It is the unique row id from where row scan should start
end_tag: It is the unique row id where row scan should end

Assuming you already have data on hbase table &quot;test_startendtag&quot; under &quot;startendtag&quot; family name with single column named &quot;number&quot;.
data: column contains values from 1 to 99. Here rowid is generated by hbase.

Sample hbase data. Few rows from hbase table looks as below.
hbase(main):002:0&gt; scan &quot;test_startendtag&quot;
ROW             COLUMN+CELL
 0          column=startendtag:number, timestamp=1465342524846, value=1
 1          column=startendtag:number, timestamp=1465342524846, value=25
 10         column=startendtag:number, timestamp=1465342524847, value=51
 103        column=startendtag:number, timestamp=1465342524851, value=98
 107        column=startendtag:number, timestamp=1465342524851, value=99
 11         column=startendtag:number, timestamp=1465342524851, value=75
 12         column=startendtag:number, timestamp=1465342524846, value=4
 13         column=startendtag:number, timestamp=1465342524846, value=28
 14         column=startendtag:number, timestamp=1465342524847, value=52
 15         column=startendtag:number, timestamp=1465342524851, value=76
 16         column=startendtag:number, timestamp=1465342524846, value=5
 17         column=startendtag:number, timestamp=1465342524846, value=29
 18         column=startendtag:number, timestamp=1465342524847, value=53
 19         column=startendtag:number, timestamp=1465342524851, value=77
 2          column=startendtag:number, timestamp=1465342524847, value=49
 20         column=startendtag:number, timestamp=1465342524846, value=6
 21         column=startendtag:number, timestamp=1465342524846, value=30

&gt;&gt;&gt; frame = tc.frame.import_hbase(&quot;test_startendtag&quot;, [[&quot;startendtag&quot;, &quot;number&quot;, int]], start_tag=&quot;20&quot;, end_tag=&quot;50&quot;)
-etc-
&gt;&gt;&gt; frame.count()
33
&gt;&gt;&gt; frame.inspect(33)
[##]  startendtag_number
========================
[0]                    6
[1]                   30
[2]                   54
[3]                   78
[4]                    7
[5]                   31
[6]                   55
[7]                   79
[8]                    8
[9]                   32
[10]                  73
[11]                  56
[12]                  80
[13]                   9
[14]                  33
[15]                  57
[16]                  81
[17]                  10
[18]                  34
[19]                  58


[##]  startendtag_number
========================
[20]                  82
[21]                   2
[22]                  11
[23]                  35
[24]                  59
[25]                  83
[26]                  12
[27]                  36
[28]                  60
[29]                  84
[30]                  13
[31]                  37
[32]                  26
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.import_hbase', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.import_hbase" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">import_hbase</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">start_tag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end_tag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import data from hbase table into frame</span>

<span class="sd">    :param table_name: (str) hbase table name</span>
<span class="sd">    :param schema: (list[list[str, str, type]]) hbase schema as a List of List(string) (columnFamily, columnName,</span>
<span class="sd">                   dataType for cell value)</span>
<span class="sd">    :param start_tag: (Optional(str)) optional start tag for filtering</span>
<span class="sd">    :param end_tag: (Optional(str)) optional end tag for filtering</span>
<span class="sd">    :return: (Frame) frame with data from hbase table</span>

<span class="sd">    Example</span>
<span class="sd">    ---------</span>
<span class="sd">    Load data into frame from a hbase table</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_hbase(&quot;demo_test_hbase&quot;, [[&quot;test_family&quot;, &quot;a&quot;, int],[&quot;test_family&quot;, &quot;b&quot;, float], [&quot;test_family&quot;, &quot;c&quot;, int],[&quot;test_family&quot;, &quot;d&quot;, int]])</span>
<span class="sd">        -etc-</span>
<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  test_family_a  test_family_b  test_family_c  test_family_d</span>
<span class="sd">        ===============================================================</span>
<span class="sd">        [0]              1            0.2             -2              5</span>
<span class="sd">        [1]              2            0.4             -1              6</span>
<span class="sd">        [2]              3            0.6              0              7</span>
<span class="sd">        [3]              4            0.8              1              8</span>

<span class="sd">        Use of start_tag and end_tag. (Hbase creates a unique row id for data in hbase tables)</span>
<span class="sd">        start_tag: It is the unique row id from where row scan should start</span>
<span class="sd">        end_tag: It is the unique row id where row scan should end</span>

<span class="sd">        Assuming you already have data on hbase table &quot;test_startendtag&quot; under &quot;startendtag&quot; family name with single column named &quot;number&quot;.</span>
<span class="sd">        data: column contains values from 1 to 99. Here rowid is generated by hbase.</span>

<span class="sd">        Sample hbase data. Few rows from hbase table looks as below.</span>
<span class="sd">        hbase(main):002:0&gt; scan &quot;test_startendtag&quot;</span>
<span class="sd">        ROW             COLUMN+CELL</span>
<span class="sd">         0          column=startendtag:number, timestamp=1465342524846, value=1</span>
<span class="sd">         1          column=startendtag:number, timestamp=1465342524846, value=25</span>
<span class="sd">         10         column=startendtag:number, timestamp=1465342524847, value=51</span>
<span class="sd">         103        column=startendtag:number, timestamp=1465342524851, value=98</span>
<span class="sd">         107        column=startendtag:number, timestamp=1465342524851, value=99</span>
<span class="sd">         11         column=startendtag:number, timestamp=1465342524851, value=75</span>
<span class="sd">         12         column=startendtag:number, timestamp=1465342524846, value=4</span>
<span class="sd">         13         column=startendtag:number, timestamp=1465342524846, value=28</span>
<span class="sd">         14         column=startendtag:number, timestamp=1465342524847, value=52</span>
<span class="sd">         15         column=startendtag:number, timestamp=1465342524851, value=76</span>
<span class="sd">         16         column=startendtag:number, timestamp=1465342524846, value=5</span>
<span class="sd">         17         column=startendtag:number, timestamp=1465342524846, value=29</span>
<span class="sd">         18         column=startendtag:number, timestamp=1465342524847, value=53</span>
<span class="sd">         19         column=startendtag:number, timestamp=1465342524851, value=77</span>
<span class="sd">         2          column=startendtag:number, timestamp=1465342524847, value=49</span>
<span class="sd">         20         column=startendtag:number, timestamp=1465342524846, value=6</span>
<span class="sd">         21         column=startendtag:number, timestamp=1465342524846, value=30</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_hbase(&quot;test_startendtag&quot;, [[&quot;startendtag&quot;, &quot;number&quot;, int]], start_tag=&quot;20&quot;, end_tag=&quot;50&quot;)</span>
<span class="sd">        -etc-</span>
<span class="sd">        &gt;&gt;&gt; frame.count()</span>
<span class="sd">        33</span>
<span class="sd">        &gt;&gt;&gt; frame.inspect(33)</span>
<span class="sd">        [##]  startendtag_number</span>
<span class="sd">        ========================</span>
<span class="sd">        [0]                    6</span>
<span class="sd">        [1]                   30</span>
<span class="sd">        [2]                   54</span>
<span class="sd">        [3]                   78</span>
<span class="sd">        [4]                    7</span>
<span class="sd">        [5]                   31</span>
<span class="sd">        [6]                   55</span>
<span class="sd">        [7]                   79</span>
<span class="sd">        [8]                    8</span>
<span class="sd">        [9]                   32</span>
<span class="sd">        [10]                  73</span>
<span class="sd">        [11]                  56</span>
<span class="sd">        [12]                  80</span>
<span class="sd">        [13]                   9</span>
<span class="sd">        [14]                  33</span>
<span class="sd">        [15]                  57</span>
<span class="sd">        [16]                  81</span>
<span class="sd">        [17]                  10</span>
<span class="sd">        [18]                  34</span>
<span class="sd">        [19]                  58</span>


<span class="sd">        [##]  startendtag_number</span>
<span class="sd">        ========================</span>
<span class="sd">        [20]                  82</span>
<span class="sd">        [21]                   2</span>
<span class="sd">        [22]                  11</span>
<span class="sd">        [23]                  35</span>
<span class="sd">        [24]                  59</span>
<span class="sd">        [25]                  83</span>
<span class="sd">        [26]                  12</span>
<span class="sd">        [27]                  36</span>
<span class="sd">        [28]                  60</span>
<span class="sd">        [29]                  84</span>
<span class="sd">        [30]                  13</span>
<span class="sd">        [31]                  37</span>
<span class="sd">        [32]                  26</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;table name parameter must be a string, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">table_name</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;schema parameter must be a list, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">table_name</span><span class="p">)))</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>

    <span class="n">inner_lists</span><span class="o">=</span><span class="p">[</span><span class="n">tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
    <span class="n">scala_final_schema</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list</span><span class="p">(</span><span class="n">inner_lists</span><span class="p">)</span>

    <span class="n">scala_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">constructors</span><span class="o">.</span><span class="n">Import</span><span class="o">.</span><span class="n">importHbase</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">get_scala_sc</span><span class="p">(),</span>
                                                                                                         <span class="n">table_name</span><span class="p">,</span> <span class="n">scala_final_schema</span><span class="p">,</span>
                                                                                                         <span class="n">tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">start_tag</span><span class="p">),</span>
                                                                                                         <span class="n">tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">end_tag</span><span class="p">))</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.import_hive">
    <p>def <span class="ident">import_hive</span>(</p><p>hive_query, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Import data from hive table into frame.</p>
<p>Define the sql query to retrieve the data from a hive table.</p>
<p>Only a subset of Hive data types are supported.</p>
<p>Data Type   Support</p>
<hr />
<p>boolean     cast to int</p>
<p>bigint      native support
int         native support
tinyint     cast to int
smallint    cast to int</p>
<p>decimal     cast to double, may lose precision
double      native support
float       native support</p>
<p>date        cast to string
string      native support
timestamp   cast to string
varchar     cast to string</p>
<p>arrays      not supported
binary      not supported
char        not supported
maps        not supported
structs     not supported
union       not supported</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>hive_query</td><td class='param-type'>(str):</td><td class='param-desc'>hive query to fetch data from table
</td></tr></table>

<table><tr><td class='param-name'>tc</td><td class='param-type'>(TkContext):</td><td class='param-desc'>TK context
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns frame with hive table data</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Load data into frame from a hive table based on hive query</p>
<div class="codehilite"><pre>&gt;&gt;&gt; h_query = &quot;select * from demo_test&quot;
&gt;&gt;&gt; frame = tc.frame.import_hive(h_query)
-etc-

&gt;&gt;&gt; frame.inspect()
[#]  number  strformat
======================
[0]       1  one
[1]       2  two
[2]       3  three
[3]       4  four
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.import_hive', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.import_hive" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">import_hive</span><span class="p">(</span><span class="n">hive_query</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import data from hive table into frame.</span>

<span class="sd">    Define the sql query to retrieve the data from a hive table.</span>

<span class="sd">    Only a subset of Hive data types are supported.</span>

<span class="sd">    Data Type   Support</span>
<span class="sd">    ___________ ___________________________</span>

<span class="sd">    boolean     cast to int</span>

<span class="sd">    bigint      native support</span>
<span class="sd">    int         native support</span>
<span class="sd">    tinyint     cast to int</span>
<span class="sd">    smallint    cast to int</span>

<span class="sd">    decimal     cast to double, may lose precision</span>
<span class="sd">    double      native support</span>
<span class="sd">    float       native support</span>

<span class="sd">    date        cast to string</span>
<span class="sd">    string      native support</span>
<span class="sd">    timestamp   cast to string</span>
<span class="sd">    varchar     cast to string</span>

<span class="sd">    arrays      not supported</span>
<span class="sd">    binary      not supported</span>
<span class="sd">    char        not supported</span>
<span class="sd">    maps        not supported</span>
<span class="sd">    structs     not supported</span>
<span class="sd">    union       not supported</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param hive_query: (str) hive query to fetch data from table</span>
<span class="sd">    :param tc: (TkContext) TK context</span>
<span class="sd">    :return: (Frame) returns frame with hive table data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load data into frame from a hive table based on hive query</span>

<span class="sd">        &gt;&gt;&gt; h_query = &quot;select * from demo_test&quot;</span>
<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_hive(h_query)</span>
<span class="sd">        -etc-</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  number  strformat</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]       1  one</span>
<span class="sd">        [1]       2  two</span>
<span class="sd">        [2]       3  three</span>
<span class="sd">        [3]       4  four</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hive_query</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;hive query parameter must be a string, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">hive_query</span><span class="p">)))</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>

    <span class="n">scala_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">constructors</span><span class="o">.</span><span class="n">Import</span><span class="o">.</span><span class="n">importHive</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">get_scala_sc</span><span class="p">(),</span> <span class="n">hive_query</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.import_jdbc">
    <p>def <span class="ident">import_jdbc</span>(</p><p>connection_url, table_name, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Import data from jdbc table into frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>connection_url</td><td class='param-type'>(str):</td><td class='param-desc'>JDBC connection url to database server
</td></tr></table>

<table><tr><td class='param-name'>table_name</td><td class='param-type'>(str):</td><td class='param-desc'>JDBC table name
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns frame with jdbc table data</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Load a frame from a jdbc table specifying the connection url to the database server.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; url = &quot;jdbc:postgresql://localhost/postgres&quot;
&gt;&gt;&gt; tb_name = &quot;demo_test&quot;

&gt;&gt;&gt; frame = tc.frame.import_jdbc(url, tb_name)
-etc-

&gt;&gt;&gt; frame.inspect()
[#]  a  b    c   d
==================
[0]  1  0.2  -2  5
[1]  2  0.4  -1  6
[2]  3  0.6   0  7
[3]  4  0.8   1  8

&gt;&gt;&gt; frame.schema
[(u&#39;a&#39;, int), (u&#39;b&#39;, float), (u&#39;c&#39;, int), (u&#39;d&#39;, int)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.import_jdbc', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.import_jdbc" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">import_jdbc</span><span class="p">(</span><span class="n">connection_url</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import data from jdbc table into frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param connection_url: (str) JDBC connection url to database server</span>
<span class="sd">    :param table_name: (str) JDBC table name</span>
<span class="sd">    :return: (Frame) returns frame with jdbc table data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load a frame from a jdbc table specifying the connection url to the database server.</span>

<span class="sd">        &gt;&gt;&gt; url = &quot;jdbc:postgresql://localhost/postgres&quot;</span>
<span class="sd">        &gt;&gt;&gt; tb_name = &quot;demo_test&quot;</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_jdbc(url, tb_name)</span>
<span class="sd">        -etc-</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b    c   d</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]  1  0.2  -2  5</span>
<span class="sd">        [1]  2  0.4  -1  6</span>
<span class="sd">        [2]  3  0.6   0  7</span>
<span class="sd">        [3]  4  0.8   1  8</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(u&#39;a&#39;, int), (u&#39;b&#39;, float), (u&#39;c&#39;, int), (u&#39;d&#39;, int)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">connection_url</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;connection url parameter must be a string, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">connection_url</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;table name parameter must be a string, but is {0}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">table_name</span><span class="p">)))</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>

    <span class="n">scala_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">constructors</span><span class="o">.</span><span class="n">Import</span><span class="o">.</span><span class="n">importJdbc</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">get_scala_sc</span><span class="p">(),</span> <span class="n">connection_url</span><span class="p">,</span> <span class="n">table_name</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.import_pandas">
    <p>def <span class="ident">import_pandas</span>(</p><p>pandas_frame, schema=None, row_index=True, validate_schema=False, tc=&lt;class &#39;sparktk.arguments.implicit&#39;&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Imports data from the specified pandas data frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>pandas_frame</td><td class='param-type'>(pandas.DataFrame):</td><td class='param-desc'> pandas dataframe object
</td></tr></table>

<table><tr><td class='param-name'>schema</td><td class='param-type'>(Optional(list[tuples(string, type)])):</td><td class='param-desc'>Schema description of the fields for a given line.  It is a
               list of tuples which describe each field, (field name, field type), where the field name is a
               string, and file is a supported type.  If no schema is provided, the schema will be inferred based
               on the column names and types from the pandas_frame.
</td></tr></table>

<table><tr><td class='param-name'>row_index</td><td class='param-type'>(Optional(bool)):</td><td class='param-desc'>Indicates if the row_index is present in the pandas dataframe and needs to be
                  ignored when looking at the data values. Default value is True.
</td></tr></table>

<table><tr><td class='param-name'>validate_schema</td><td class='param-type'>(Optional(bool)):</td><td class='param-desc'>If true, validates the data against the schema and attempts to cast the
                        data to the specified type, if it does not match the schema.  Defaults to False.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>spark-tk frame that contains data from the pandas_frame</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Create a pandas data frame:</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pandas</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ratings_data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;invalid&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Very Poor&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Poor&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Average&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Good&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;Very Good&quot;</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ratings_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;rating_id&#39;</span><span class="p">,</span> <span class="s">&#39;rating_text&#39;</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">df</span>
   <span class="n">rating_id</span> <span class="n">rating_text</span>
<span class="mi">0</span>          <span class="mi">0</span>     <span class="n">invalid</span>
<span class="mi">1</span>          <span class="mi">1</span>   <span class="n">Very</span> <span class="n">Poor</span>
<span class="mi">2</span>          <span class="mi">2</span>        <span class="n">Poor</span>
<span class="mi">3</span>          <span class="mi">3</span>     <span class="n">Average</span>
<span class="mi">4</span>          <span class="mi">4</span>        <span class="n">Good</span>
<span class="mi">5</span>          <span class="mi">5</span>   <span class="n">Very</span> <span class="n">Good</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="p">[</span><span class="s">&#39;rating_id&#39;</span><span class="p">,</span> <span class="s">&#39;rating_text&#39;</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
<span class="n">rating_id</span>       <span class="n">int64</span>
<span class="n">rating_text</span>    <span class="nb">object</span>
<span class="n">dtype</span><span class="p">:</span> <span class="nb">object</span>
</pre></div>


<p>When using import_pandas by just passing the pandas data frame, it will use the column names and types from the
pandas data frame to generate the schema.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.import_pandas(df)

&gt;&gt;&gt; frame.inspect()
[#]  rating_id  rating_text
===========================
[0]          0  invalid
[1]          1  Very Poor
[2]          2  Poor
[3]          3  Average
[4]          4  Good
[5]          5  Very Good

&gt;&gt;&gt; frame.schema
[(&#39;rating_id&#39;, &lt;type &#39;long&#39;&gt;), (&#39;rating_text&#39;, &lt;type &#39;str&#39;&gt;)]
</pre></div>


<p>Alternatively, you can specify a schema when importing the pandas data frame.  There is also the option to validate
the data against the schema.  If this option is enabled, we will attempt to cast the data to the column's data type,
if it does not match the schema.</p>
<p>For example, here we will specify a schema where the rating_id column will instead be called 'rating_float' and it's
data type will be a float.  We will also enable the validate_schema option so that the rating_id value will get
casted to a float:
    &gt;&gt;&gt; schema = [("rating_float", float), ("rating_str", unicode)]
    &gt;&gt;&gt; frame = tc.frame.import_pandas(df, schema, validate_schema=True)</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  rating_float  rating_str
=============================
[0]           0.0  invalid
[1]           1.0  Very Poor
[2]           2.0  Poor
[3]           3.0  Average
[4]           4.0  Good
[5]           5.0  Very Good

&gt;&gt;&gt; frame.schema
[(&#39;rating_float&#39;, &lt;type &#39;float&#39;&gt;), (&#39;rating_str&#39;, &lt;type &#39;unicode&#39;&gt;)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.import_pandas', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.import_pandas" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">import_pandas</span><span class="p">(</span><span class="n">pandas_frame</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">row_index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">validate_schema</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="n">TkContext</span><span class="o">.</span><span class="n">implicit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Imports data from the specified pandas data frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param pandas_frame: (pandas.DataFrame)  pandas dataframe object</span>
<span class="sd">    :param schema: (Optional(list[tuples(string, type)])) Schema description of the fields for a given line.  It is a</span>
<span class="sd">                   list of tuples which describe each field, (field name, field type), where the field name is a</span>
<span class="sd">                   string, and file is a supported type.  If no schema is provided, the schema will be inferred based</span>
<span class="sd">                   on the column names and types from the pandas_frame.</span>
<span class="sd">    :param row_index: (Optional(bool)) Indicates if the row_index is present in the pandas dataframe and needs to be</span>
<span class="sd">                      ignored when looking at the data values. Default value is True.</span>
<span class="sd">    :param validate_schema: (Optional(bool)) If true, validates the data against the schema and attempts to cast the</span>
<span class="sd">                            data to the specified type, if it does not match the schema.  Defaults to False.</span>
<span class="sd">    :return: (Frame) spark-tk frame that contains data from the pandas_frame</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a pandas data frame:</span>

<span class="sd">        &gt;&gt;&gt; import pandas</span>
<span class="sd">        &gt;&gt;&gt; ratings_data = [[0, &quot;invalid&quot;], [1, &quot;Very Poor&quot;], [2, &quot;Poor&quot;], [3, &quot;Average&quot;], [4, &quot;Good&quot;], [5, &quot;Very Good&quot;]]</span>
<span class="sd">        &gt;&gt;&gt; df = pandas.DataFrame(ratings_data, columns=[&#39;rating_id&#39;, &#39;rating_text&#39;])</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           rating_id rating_text</span>
<span class="sd">        0          0     invalid</span>
<span class="sd">        1          1   Very Poor</span>
<span class="sd">        2          2        Poor</span>
<span class="sd">        3          3     Average</span>
<span class="sd">        4          4        Good</span>
<span class="sd">        5          5   Very Good</span>

<span class="sd">        &gt;&gt;&gt; df.columns.tolist()</span>
<span class="sd">        [&#39;rating_id&#39;, &#39;rating_text&#39;]</span>

<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        rating_id       int64</span>
<span class="sd">        rating_text    object</span>
<span class="sd">        dtype: object</span>

<span class="sd">    When using import_pandas by just passing the pandas data frame, it will use the column names and types from the</span>
<span class="sd">    pandas data frame to generate the schema.</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_pandas(df)</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  rating_id  rating_text</span>
<span class="sd">        ===========================</span>
<span class="sd">        [0]          0  invalid</span>
<span class="sd">        [1]          1  Very Poor</span>
<span class="sd">        [2]          2  Poor</span>
<span class="sd">        [3]          3  Average</span>
<span class="sd">        [4]          4  Good</span>
<span class="sd">        [5]          5  Very Good</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;rating_id&#39;, &lt;type &#39;long&#39;&gt;), (&#39;rating_text&#39;, &lt;type &#39;str&#39;&gt;)]</span>

<span class="sd">    Alternatively, you can specify a schema when importing the pandas data frame.  There is also the option to validate</span>
<span class="sd">    the data against the schema.  If this option is enabled, we will attempt to cast the data to the column&#39;s data type,</span>
<span class="sd">    if it does not match the schema.</span>

<span class="sd">    For example, here we will specify a schema where the rating_id column will instead be called &#39;rating_float&#39; and it&#39;s</span>
<span class="sd">    data type will be a float.  We will also enable the validate_schema option so that the rating_id value will get</span>
<span class="sd">    casted to a float:</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&quot;rating_float&quot;, float), (&quot;rating_str&quot;, unicode)]</span>
<span class="sd">        &gt;&gt;&gt; frame = tc.frame.import_pandas(df, schema, validate_schema=True)</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  rating_float  rating_str</span>
<span class="sd">        =============================</span>
<span class="sd">        [0]           0.0  invalid</span>
<span class="sd">        [1]           1.0  Very Poor</span>
<span class="sd">        [2]           2.0  Poor</span>
<span class="sd">        [3]           3.0  Average</span>
<span class="sd">        [4]           4.0  Good</span>
<span class="sd">        [5]           5.0  Very Good</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;rating_float&#39;, &lt;type &#39;float&#39;&gt;), (&#39;rating_str&#39;, &lt;type &#39;unicode&#39;&gt;)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pandas</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;pandas module not found, unable to download.  Install pandas or try the take command.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pandas_frame</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;data_frame must be a pandas DataFrame.&quot;</span><span class="p">)</span>
    <span class="n">TkContext</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">_validate</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">_get_schema_from_df</span><span class="p">(</span><span class="n">pandas_frame</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">row_index</span><span class="p">:</span>
        <span class="n">pandas_frame</span> <span class="o">=</span> <span class="n">pandas_frame</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="n">pandas_frame</span> <span class="o">=</span> <span class="n">pandas_frame</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">thresh</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
    <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Number of columns in Pandasframe {0} does not match the number of columns in the&quot;</span>
                         <span class="s">&quot; schema provided {1}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_names</span><span class="p">)))</span>

    <span class="n">date_time_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">&quot;datetime64[ns]&quot;</span><span class="p">]</span>
    <span class="n">has_date_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">date_time_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c"># pandas gives us the date/time in nm or as a Timestamp, and spark-tk expects it as ms, so we need to do the conversion</span>
    <span class="k">def</span> <span class="nf">pandas_datetime_to_ms</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">date_time_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">long</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000000</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pandas</span><span class="o">.</span><span class="n">tslib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">datetime</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c"># get number of seconds since epoch (%s) and multiply by 1000 for ms then get the</span>
                <span class="c"># microseconds to get the ms precision.</span>
                <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">long</span><span class="p">((</span><span class="nb">long</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="n">pandas_rows</span> <span class="o">=</span> <span class="n">pandas_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c"># if the dataframe has date/time columns, map them to ms</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">has_date_time</span><span class="p">):</span>
        <span class="n">pandas_rows</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">pandas_datetime_to_ms</span><span class="p">,</span> <span class="n">pandas_rows</span><span class="p">)</span>

    <span class="c"># create frame with the pandas_rows</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">pandas_rows</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">validate_schema</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">rdd</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">validate_schema</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frame</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="sparktk.frame.frame.Frame" class="name">class <span class="ident">Frame</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame" class="source">
    <div class="codehilite"><pre><span class="k">class</span> <span class="nc">Frame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">validate_schema</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala_frame</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_rdd</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_dataframe</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">_jdf</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">PythonFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">source</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid data source.  The data parameter must be a 2-dimensional list (list of row data) or an RDD.&quot;</span><span class="p">)</span>

                <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                        <span class="c"># check if schema is just a list of column names (versus string and data type tuples)</span>
                        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                        <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  Expected a list of tuples (str, type) with the column name and data type, but received type </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
                    <span class="c"># check for duplicate column names</span>
                    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
                    <span class="n">duplicate_column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span> <span class="k">if</span> <span class="n">column_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid schema, column names cannot be duplicated: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">schema</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Schema is not a list or None</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema type: </span><span class="si">%s</span><span class="s">.  Expected a list of tuples (str, type) with the column name and data type.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_supported_datatype</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">inferred_schema</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;The </span><span class="si">%s</span><span class="s"> data type was found when inferring the schema, and it is not a &quot;</span>
                                            <span class="s">&quot;supported data type.  Instead, specify a schema that uses a supported data &quot;</span>
                                            <span class="s">&quot;type, and enable validate_schema so that the data is converted to the proper &quot;</span>
                                            <span class="s">&quot;data type.</span><span class="se">\n\n</span><span class="s">Inferred schema: </span><span class="si">%s</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">schema</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  </span><span class="si">%s</span><span class="s"> is not a supported data type.</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>

                <span class="n">source</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">and</span> <span class="n">validate_schema</span><span class="p">:</span>
                <span class="c"># Validate schema by going through the data and checking the data type and attempting to parse it</span>
                <span class="n">validate_schema_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pyrdd_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">validated_rdd</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> values were unable to be parsed to the schema&#39;s data type.&quot;</span> <span class="o">%</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">bad_value_count</span><span class="p">)</span>

            <span class="c"># If schema contains matrix datatype, then apply type_coercer to convert list[list] to numpy ndarray</span>
            <span class="n">map_source</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">map_source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_merge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_list_a</span><span class="p">,</span> <span class="n">type_list_b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two lists of data types</span>

<span class="sd">        :param type_list_a: First list of data types to merge</span>
<span class="sd">        :param type_list_b: Second list of data types to merge</span>
<span class="sd">        :return: List of merged data types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to generate schema, because schema is not a list.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of each row must be the same (found rows with lengths: </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_b</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dtypes</span><span class="o">.</span><span class="n">_DataTypes</span><span class="o">.</span><span class="n">merge_types</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">type_list_b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_list_a</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">_infer_types_for_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of data types for the data in the specified row</span>

<span class="sd">        :param row: List or Row of data</span>
<span class="sd">        :return: List of data types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inferred_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inferred_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">vector</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">inferred_types</span>

    <span class="k">def</span> <span class="nf">_infer_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infers the schema based on the data in the RDD.</span>

<span class="sd">        :param sc: Spark Context</span>
<span class="sd">        :param data: Data used to infer schema</span>
<span class="sd">        :param column_names: Optional column names to use in the schema.  If no column names are provided, columns</span>
<span class="sd">                             are given numbered names.  If there are more columns in the RDD than there are in the</span>
<span class="sd">                             column_names list, remaining columns will be numbered.</span>
<span class="sd">        :param sample_size: Number of rows to check when inferring the schema.  Defaults to 100.</span>
<span class="sd">        :return: Schema</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inferred_schema</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># get the schema for the first row</span>
                <span class="n">data_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_types_for_row</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">):</span>
                    <span class="n">data_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_types</span><span class="p">(</span><span class="n">data_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_types_for_row</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_types</span><span class="p">):</span>
                    <span class="n">column_name</span> <span class="o">=</span> <span class="s">&quot;C</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">column_name</span> <span class="o">=</span> <span class="n">column_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">inferred_schema</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">column_name</span><span class="p">,</span> <span class="n">data_type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to infer schema, because the data provided is not a list.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inferred_schema</span>

    <span class="k">def</span> <span class="nf">_is_supported_datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified data_type is supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">supported_primitives</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="n">supported_primitives</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">validate_pyrdd_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyrdd</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pyrdd</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
            <span class="n">schema_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
            <span class="n">num_bad_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">accumulator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">accumulator</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">schema_length</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of the row (</span><span class="si">%s</span><span class="s">) does not match the schema length (</span><span class="si">%s</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data_type</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                        <span class="n">accumulator</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="n">validated_rdd</span> <span class="o">=</span> <span class="n">pyrdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="p">))</span>

            <span class="c"># Force rdd to load, so that we can get a bad value count</span>
            <span class="n">validated_rdd</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">SchemaValidationReturn</span><span class="p">(</span><span class="n">validated_rdd</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to validate schema, because the pyrdd provided is not an RDD.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_scala_frame</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_dataframe</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_scala</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a python Frame for the given scala Frame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">scala_frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_frame_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">python_frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;converts a PythonFrame to a Scala Frame&quot;&quot;&quot;</span>
        <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">python_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">scala_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">pythonToScala</span><span class="p">(</span><span class="n">python_frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">_jrdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_scala_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">RDD</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_scala_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_python_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">RDD</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;answers whether the current frame is backed by a Scala Frame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_python</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;answers whether the current frame is backed by a _PythonFrame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_scala</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets frame backend as Scala Frame, causes conversion if it is current not&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_python</span><span class="p">:</span>
            <span class="c"># If schema contains matrix dataype,</span>
            <span class="c"># then apply type_coercer_pymlib to convert ndarray to pymlib DenseMatrix for serialization purpose at java</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
            <span class="c"># convert PythonFrame to a Scala Frame&quot;&quot;&quot;</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
            <span class="n">scala_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">pythonToScala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">_jrdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_python</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets frame backend as _PythonFrame, causes conversion if it is current not&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
            <span class="c"># convert Scala Frame to a PythonFrame&quot;&quot;&quot;</span>
            <span class="n">scala_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">()</span>
            <span class="n">java_rdd</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">internal</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">PythonJavaRdd</span><span class="o">.</span><span class="n">scalaToPython</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">rdd</span><span class="p">())</span>
            <span class="n">python_schema</span> <span class="o">=</span> <span class="n">schema_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
            <span class="n">python_rdd</span> <span class="o">=</span> <span class="n">RDD</span><span class="p">(</span><span class="n">java_rdd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span>
            <span class="c"># If schema contains matrix datatype, then apply type_coercer to convert list[list] to numpy ndarray</span>
            <span class="n">map_python_rdd</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="n">python_rdd</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">python_schema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">map_python_rdd</span><span class="p">,</span> <span class="n">python_schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span>

    <span class="c">##########################################################################</span>
    <span class="c"># API</span>
    <span class="c">##########################################################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pyspark RDD  (causes conversion if currently backed by a Scala RDD)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">schema_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span><span class="p">())</span>  <span class="c"># need ()&#39;s on schema because it&#39;s a def in scala</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">dataframe</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sql_context</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Column identifications in the current frame.</span>

<span class="sd">        :return: list of names of all the frame&#39;s columns</span>

<span class="sd">        Returns the names of the columns of the current frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">            &gt;&gt;&gt; frame.column_names</span>
<span class="sd">            [u&#39;name&#39;, u&#39;age&#39;, u&#39;tenure&#39;, u&#39;phone&#39;]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append_csv_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">appendCsvFile</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">),</span> <span class="n">separator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToCsv</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="c"># Frame Operations</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.add_columns</span> <span class="kn">import</span> <span class="n">add_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.append</span> <span class="kn">import</span> <span class="n">append</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.assign_sample</span> <span class="kn">import</span> <span class="n">assign_sample</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.bin_column</span> <span class="kn">import</span> <span class="n">bin_column</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.binary_classification_metrics</span> <span class="kn">import</span> <span class="n">binary_classification_metrics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.box_cox</span> <span class="kn">import</span> <span class="n">box_cox</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.categorical_summary</span> <span class="kn">import</span> <span class="n">categorical_summary</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.collect</span> <span class="kn">import</span> <span class="n">collect</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_median</span> <span class="kn">import</span> <span class="n">column_median</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_mode</span> <span class="kn">import</span> <span class="n">column_mode</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.column_summary_statistics</span> <span class="kn">import</span> <span class="n">column_summary_statistics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.copy</span> <span class="kn">import</span> <span class="n">copy</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.correlation</span> <span class="kn">import</span> <span class="n">correlation</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.correlation_matrix</span> <span class="kn">import</span> <span class="n">correlation_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.count</span> <span class="kn">import</span> <span class="n">count</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.covariance</span> <span class="kn">import</span> <span class="n">covariance</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.covariance_matrix</span> <span class="kn">import</span> <span class="n">covariance_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.cumulative_percent</span> <span class="kn">import</span> <span class="n">cumulative_percent</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.cumulative_sum</span> <span class="kn">import</span> <span class="n">cumulative_sum</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.dot_product</span> <span class="kn">import</span> <span class="n">dot_product</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_columns</span> <span class="kn">import</span> <span class="n">drop_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_duplicates</span> <span class="kn">import</span> <span class="n">drop_duplicates</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.drop_rows</span> <span class="kn">import</span> <span class="n">drop_rows</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.ecdf</span> <span class="kn">import</span> <span class="n">ecdf</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.entropy</span> <span class="kn">import</span> <span class="n">entropy</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.export_data</span> <span class="kn">import</span> <span class="n">export_to_jdbc</span><span class="p">,</span> <span class="n">export_to_json</span><span class="p">,</span> <span class="n">export_to_hbase</span><span class="p">,</span> <span class="n">export_to_hive</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.filter</span> <span class="kn">import</span> <span class="nb">filter</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.flatten_columns</span> <span class="kn">import</span> <span class="n">flatten_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.group_by</span> <span class="kn">import</span> <span class="n">group_by</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.histogram</span> <span class="kn">import</span> <span class="n">histogram</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.inspect</span> <span class="kn">import</span> <span class="n">inspect</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_inner</span> <span class="kn">import</span> <span class="n">join_inner</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_left</span> <span class="kn">import</span> <span class="n">join_left</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_right</span> <span class="kn">import</span> <span class="n">join_right</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.join_outer</span> <span class="kn">import</span> <span class="n">join_outer</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.map_columns</span> <span class="kn">import</span> <span class="n">map_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_covariance_matrix</span> <span class="kn">import</span> <span class="n">matrix_covariance_matrix</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_pca</span> <span class="kn">import</span> <span class="n">matrix_pca</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.matrix_svd</span> <span class="kn">import</span> <span class="n">matrix_svd</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.multiclass_classification_metrics</span> <span class="kn">import</span> <span class="n">multiclass_classification_metrics</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.power_iteration_clustering</span> <span class="kn">import</span> <span class="n">power_iteration_clustering</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.quantile_bin_column</span> <span class="kn">import</span> <span class="n">quantile_bin_column</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.quantiles</span> <span class="kn">import</span> <span class="n">quantiles</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.rename_columns</span> <span class="kn">import</span> <span class="n">rename_columns</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.reverse_box_cox</span> <span class="kn">import</span> <span class="n">reverse_box_cox</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.save</span> <span class="kn">import</span> <span class="n">save</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.sort</span> <span class="kn">import</span> <span class="n">sort</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.sortedk</span> <span class="kn">import</span> <span class="n">sorted_k</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.take</span> <span class="kn">import</span> <span class="n">take</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.tally</span> <span class="kn">import</span> <span class="n">tally</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.tally_percent</span> <span class="kn">import</span> <span class="n">tally_percent</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_augmented_dickey_fuller_test</span> <span class="kn">import</span> <span class="n">timeseries_augmented_dickey_fuller_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_breusch_godfrey_test</span> <span class="kn">import</span> <span class="n">timeseries_breusch_godfrey_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_breusch_pagan_test</span> <span class="kn">import</span> <span class="n">timeseries_breusch_pagan_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_durbin_watson_test</span> <span class="kn">import</span> <span class="n">timeseries_durbin_watson_test</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_from_observations</span> <span class="kn">import</span> <span class="n">timeseries_from_observations</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.timeseries_slice</span> <span class="kn">import</span> <span class="n">timeseries_slice</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.to_pandas</span> <span class="kn">import</span> <span class="n">to_pandas</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.topk</span> <span class="kn">import</span> <span class="n">top_k</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.unflatten_columns</span> <span class="kn">import</span> <span class="n">unflatten_columns</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#sparktk.frame.frame.Frame">Frame</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.create_scala_frame">
    <p>def <span class="ident">create_scala_frame</span>(</p><p>sc, scala_rdd, scala_schema)</p>
    </div>
    

    
  
    <div class="desc"><p>call constructor in JVM</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.create_scala_frame', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.create_scala_frame" class="source">
    <div class="codehilite"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_scala_frame</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_rdd</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.create_scala_frame_from_scala_dataframe">
    <p>def <span class="ident">create_scala_frame_from_scala_dataframe</span>(</p><p>sc, scala_dataframe)</p>
    </div>
    

    
  
    <div class="desc"><p>call constructor in JVM</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.create_scala_frame_from_scala_dataframe', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.create_scala_frame_from_scala_dataframe" class="source">
    <div class="codehilite"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">scala_dataframe</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;call constructor in JVM&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">trustedanalytics</span><span class="o">.</span><span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">scala_dataframe</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="sparktk.frame.frame.Frame.column_names" class="name">var <span class="ident">column_names</span></p>
            

            
  
    <div class="desc"><p>Column identifications in the current frame.</p>
<p><table style='padding-top:10px'><tr><td class='param-name'>Returns: </td><td class='param-desc'>list of names of all the frame's columns</td></tr></table></p>

<p>Returns the names of the columns of the current frame.</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; frame.column_names
[u&#39;name&#39;, u&#39;age&#39;, u&#39;tenure&#39;, u&#39;phone&#39;]
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="sparktk.frame.frame.Frame.dataframe" class="name">var <span class="ident">dataframe</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="sparktk.frame.frame.Frame.rdd" class="name">var <span class="ident">rdd</span></p>
            

            
  
    <div class="desc"><p>pyspark RDD  (causes conversion if currently backed by a Scala RDD)</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="sparktk.frame.frame.Frame.schema" class="name">var <span class="ident">schema</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, tc, source, schema=None, validate_schema=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.__init__', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.__init__" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">validate_schema</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span> <span class="o">=</span> <span class="n">tc</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala_frame</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_rdd</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">scala_schema</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_scala_dataframe</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_scala_frame_from_scala_dataframe</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">_jdf</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">PythonFrame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">source</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">source</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid data source.  The data parameter must be a 2-dimensional list (list of row data) or an RDD.&quot;</span><span class="p">)</span>
            <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                    <span class="c"># check if schema is just a list of column names (versus string and data type tuples)</span>
                    <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                    <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                              <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                              <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  Expected a list of tuples (str, type) with the column name and data type, but received type </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
                <span class="c"># check for duplicate column names</span>
                <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
                <span class="n">duplicate_column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span> <span class="k">if</span> <span class="n">column_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid schema, column names cannot be duplicated: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">duplicate_column_names</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">schema</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_schema</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">inferred_schema</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Schema is not a list or None</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema type: </span><span class="si">%s</span><span class="s">.  Expected a list of tuples (str, type) with the column name and data type.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_supported_datatype</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">inferred_schema</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;The </span><span class="si">%s</span><span class="s"> data type was found when inferring the schema, and it is not a &quot;</span>
                                        <span class="s">&quot;supported data type.  Instead, specify a schema that uses a supported data &quot;</span>
                                        <span class="s">&quot;type, and enable validate_schema so that the data is converted to the proper &quot;</span>
                                        <span class="s">&quot;data type.</span><span class="se">\n\n</span><span class="s">Inferred schema: </span><span class="si">%s</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                        <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">schema</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Invalid schema.  </span><span class="si">%s</span><span class="s"> is not a supported data type.</span><span class="se">\n\n</span><span class="s">Supported data types: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                                        <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">and</span> <span class="n">validate_schema</span><span class="p">:</span>
            <span class="c"># Validate schema by going through the data and checking the data type and attempting to parse it</span>
            <span class="n">validate_schema_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pyrdd_schema</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">validated_rdd</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> values were unable to be parsed to the schema&#39;s data type.&quot;</span> <span class="o">%</span> <span class="n">validate_schema_result</span><span class="o">.</span><span class="n">bad_value_count</span><span class="p">)</span>
        <span class="c"># If schema contains matrix datatype, then apply type_coercer to convert list[list] to numpy ndarray</span>
        <span class="n">map_source</span> <span class="o">=</span> <span class="n">MatrixCoercion</span><span class="o">.</span><span class="n">schema_is_coercible</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">schema</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">map_source</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.add_columns">
    <p>def <span class="ident">add_columns</span>(</p><p>self, func, schema)</p>
    </div>
    

    
  
    <div class="desc"><p>Add columns to current frame.</p>
<p>Assigns data to column based on evaluating a function for each row.</p>
<div class='section-header'>Notes:</div>

<ol>
<li>The row |UDF| ('func') must return a value in the same format as
    specified by the schema.</li>
</ol>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>func</td><td class='param-type'>(UDF):</td><td class='param-desc'>Function which takes the values in the row and produces a value, or collection of values, for the new cell(s).
</td></tr></table>

<table><tr><td class='param-name'>schema</td><td class='param-type'>(List[(str,type)]):</td><td class='param-desc'>Schema for the column(s) being added.</td></tr></table>

<div class='section-header'>Examples:</div>

<p>Given our frame, let's add a column which has how many years the person has been over 18</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],
...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],
...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],
...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],
...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Susan      33       3  555-0202
[2]  Thurston   65      26  555-4510
[3]  Judy       44      14  555-2183

&gt;&gt;&gt; frame.add_columns(lambda row: row.age - 18, (&#39;adult_years&#39;, int))

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone     adult_years
=================================================
[0]  Fred       39      16  555-1234           21
[1]  Susan      33       3  555-0202           15
[2]  Thurston   65      26  555-4510           47
[3]  Judy       44      14  555-2183           26
</pre></div>


<p>Multiple columns can be added at the same time.  Let's add percentage of
life and percentage of adult life in one call, which is more efficient.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.add_columns(lambda row: [row.tenure / float(row.age), row.tenure / float(row.adult_years)],
...                   [(&quot;of_age&quot;, float), (&quot;of_adult&quot;, float)])

&gt;&gt;&gt; frame.inspect(round=2)
[#]  name      age  tenure  phone     adult_years  of_age  of_adult
===================================================================
[0]  Fred       39      16  555-1234           21    0.41      0.76
[1]  Susan      33       3  555-0202           15    0.09      0.20
[2]  Thurston   65      26  555-4510           47    0.40      0.55
[3]  Judy       44      14  555-2183           26    0.32      0.54
</pre></div>


<p>Note that the function returns a list, and therefore the schema also needs to be a list.</p>
<p>It is not necessary to use lambda syntax, any function will do, as long as it takes a single row argument.  We
can also call other local functions within.</p>
<p>Let's add a column which shows the amount of person's name based on their adult tenure percentage.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; def percentage_of_string(string, percentage):
...     &#39;&#39;&#39;returns a substring of the given string according to the given percentage&#39;&#39;&#39;
...     substring_len = int(percentage * len(string))
...     return string[:substring_len]

&gt;&gt;&gt; def add_name_by_adult_tenure(row):
...     return percentage_of_string(row.name, row.of_adult)

&gt;&gt;&gt; frame.add_columns(add_name_by_adult_tenure, (&#39;tenured_name&#39;, unicode))

&gt;&gt;&gt; frame.inspect(columns=[&#39;name&#39;, &#39;of_adult&#39;, &#39;tenured_name&#39;], round=2)
[#]  name      of_adult  tenured_name
=====================================
[0]  Fred          0.76  Fre
[1]  Susan         0.20  S
[2]  Thurston      0.55  Thur
[3]  Judy          0.54  Ju
</pre></div>


<p>Let's add a name based on tenure percentage of age.  We know we're only going to use
columns 'name' and 'of_age'.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.add_columns(lambda row: percentage_of_string(row.name, row.of_age),
...                   (&#39;tenured_name_age&#39;, unicode))

&gt;&gt;&gt; frame.inspect(round=2)
[#]  name      age  tenure  phone     adult_years  of_age  of_adult
===================================================================
[0]  Fred       39      16  555-1234           21    0.41      0.76
[1]  Susan      33       3  555-0202           15    0.09      0.20
[2]  Thurston   65      26  555-4510           47    0.40      0.55
[3]  Judy       44      14  555-2183           26    0.32      0.54
&lt;BLANKLINE&gt;
[#]  tenured_name  tenured_name_age
===================================
[0]  Fre           F
[1]  S
[2]  Thur          Thu
[3]  Ju            J
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.add_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.add_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add columns to current frame.</span>

<span class="sd">    Assigns data to column based on evaluating a function for each row.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    1.  The row |UDF| (&#39;func&#39;) must return a value in the same format as</span>
<span class="sd">        specified by the schema.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param func: (UDF) Function which takes the values in the row and produces a value, or collection of values, for the new cell(s).</span>
<span class="sd">    :param schema: (List[(str,type)]) Schema for the column(s) being added.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given our frame, let&#39;s add a column which has how many years the person has been over 18</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],</span>
<span class="sd">        ...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],</span>
<span class="sd">        ...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],</span>
<span class="sd">        ...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],</span>
<span class="sd">        ...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">        &gt;&gt;&gt; frame.add_columns(lambda row: row.age - 18, (&#39;adult_years&#39;, int))</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone     adult_years</span>
<span class="sd">        =================================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234           21</span>
<span class="sd">        [1]  Susan      33       3  555-0202           15</span>
<span class="sd">        [2]  Thurston   65      26  555-4510           47</span>
<span class="sd">        [3]  Judy       44      14  555-2183           26</span>


<span class="sd">    Multiple columns can be added at the same time.  Let&#39;s add percentage of</span>
<span class="sd">    life and percentage of adult life in one call, which is more efficient.</span>

<span class="sd">        &gt;&gt;&gt; frame.add_columns(lambda row: [row.tenure / float(row.age), row.tenure / float(row.adult_years)],</span>
<span class="sd">        ...                   [(&quot;of_age&quot;, float), (&quot;of_adult&quot;, float)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(round=2)</span>
<span class="sd">        [#]  name      age  tenure  phone     adult_years  of_age  of_adult</span>
<span class="sd">        ===================================================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234           21    0.41      0.76</span>
<span class="sd">        [1]  Susan      33       3  555-0202           15    0.09      0.20</span>
<span class="sd">        [2]  Thurston   65      26  555-4510           47    0.40      0.55</span>
<span class="sd">        [3]  Judy       44      14  555-2183           26    0.32      0.54</span>

<span class="sd">    Note that the function returns a list, and therefore the schema also needs to be a list.</span>

<span class="sd">    It is not necessary to use lambda syntax, any function will do, as long as it takes a single row argument.  We</span>
<span class="sd">    can also call other local functions within.</span>

<span class="sd">    Let&#39;s add a column which shows the amount of person&#39;s name based on their adult tenure percentage.</span>

<span class="sd">        &gt;&gt;&gt; def percentage_of_string(string, percentage):</span>
<span class="sd">        ...     &#39;&#39;&#39;returns a substring of the given string according to the given percentage&#39;&#39;&#39;</span>
<span class="sd">        ...     substring_len = int(percentage * len(string))</span>
<span class="sd">        ...     return string[:substring_len]</span>

<span class="sd">        &gt;&gt;&gt; def add_name_by_adult_tenure(row):</span>
<span class="sd">        ...     return percentage_of_string(row.name, row.of_adult)</span>

<span class="sd">        &gt;&gt;&gt; frame.add_columns(add_name_by_adult_tenure, (&#39;tenured_name&#39;, unicode))</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(columns=[&#39;name&#39;, &#39;of_adult&#39;, &#39;tenured_name&#39;], round=2)</span>
<span class="sd">        [#]  name      of_adult  tenured_name</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  Fred          0.76  Fre</span>
<span class="sd">        [1]  Susan         0.20  S</span>
<span class="sd">        [2]  Thurston      0.55  Thur</span>
<span class="sd">        [3]  Judy          0.54  Ju</span>


<span class="sd">    Let&#39;s add a name based on tenure percentage of age.  We know we&#39;re only going to use</span>
<span class="sd">    columns &#39;name&#39; and &#39;of_age&#39;.</span>

<span class="sd">        &gt;&gt;&gt; frame.add_columns(lambda row: percentage_of_string(row.name, row.of_age),</span>
<span class="sd">        ...                   (&#39;tenured_name_age&#39;, unicode))</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(round=2)</span>
<span class="sd">        [#]  name      age  tenure  phone     adult_years  of_age  of_adult</span>
<span class="sd">        ===================================================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234           21    0.41      0.76</span>
<span class="sd">        [1]  Susan      33       3  555-0202           15    0.09      0.20</span>
<span class="sd">        [2]  Thurston   65      26  555-4510           47    0.40      0.55</span>
<span class="sd">        [3]  Judy       44      14  555-2183           26    0.32      0.54</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  tenured_name  tenured_name_age</span>
<span class="sd">        ===================================</span>
<span class="sd">        [0]  Fre           F</span>
<span class="sd">        [1]  S</span>
<span class="sd">        [2]  Thur          Thu</span>
<span class="sd">        [3]  Ju            J</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">schema_helper</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="n">schema_helper</span><span class="o">.</span><span class="n">validate_is_mergeable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">+</span> <span class="n">add_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">+</span> <span class="p">[</span><span class="n">add_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.append">
    <p>def <span class="ident">append</span>(</p><p>self, frame)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds more data to the current frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>frame</td><td class='param-type'>(Frame):</td><td class='param-desc'>Frame of data to append to the current frame.</td></tr></table>

<div class='section-header'>Examples:</div>

<p>In this example, we start off by creating a frame of animals.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; animals = tc.frame.create([[&#39;dog&#39;, &#39;snoopy&#39;],[&#39;cat&#39;, &#39;tom&#39;],[&#39;bear&#39;, &#39;yogi&#39;],[&#39;mouse&#39;, &#39;jerry&#39;]],
...                       [(&#39;animal&#39;, str), (&#39;name&#39;, str)])
[===Job Progress===]

&gt;&gt;&gt; animals.inspect()
[#]  animal  name
===================
[0]  dog     snoopy
[1]  cat     tom
[2]  bear    yogi
[3]  mouse   jerry
</pre></div>


<p>Then, we append a frame that will add a few more animals to the original frame.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; animals.append(tc.frame.create([[&#39;donkey&#39;],[&#39;elephant&#39;], [&#39;ostrich&#39;]], [(&#39;animal&#39;, str)]))
[===Job Progress===]

&gt;&gt;&gt; animals.inspect()
[#]  animal    name
=====================
[0]  dog       snoopy
[1]  cat       tom
[2]  bear      yogi
[3]  mouse     jerry
[4]  donkey    None
[5]  elephant  None
[6]  ostrich   None
</pre></div>


<p>The data we added didn't have names, so None values were inserted for the new rows.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.append', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.append" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds more data to the current frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param frame: (Frame) Frame of data to append to the current frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    In this example, we start off by creating a frame of animals.</span>

<span class="sd">        &gt;&gt;&gt; animals = tc.frame.create([[&#39;dog&#39;, &#39;snoopy&#39;],[&#39;cat&#39;, &#39;tom&#39;],[&#39;bear&#39;, &#39;yogi&#39;],[&#39;mouse&#39;, &#39;jerry&#39;]],</span>
<span class="sd">        ...                       [(&#39;animal&#39;, str), (&#39;name&#39;, str)])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; animals.inspect()</span>
<span class="sd">        [#]  animal  name</span>
<span class="sd">        ===================</span>
<span class="sd">        [0]  dog     snoopy</span>
<span class="sd">        [1]  cat     tom</span>
<span class="sd">        [2]  bear    yogi</span>
<span class="sd">        [3]  mouse   jerry</span>

<span class="sd">    Then, we append a frame that will add a few more animals to the original frame.</span>

<span class="sd">        &gt;&gt;&gt; animals.append(tc.frame.create([[&#39;donkey&#39;],[&#39;elephant&#39;], [&#39;ostrich&#39;]], [(&#39;animal&#39;, str)]))</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; animals.inspect()</span>
<span class="sd">        [#]  animal    name</span>
<span class="sd">        =====================</span>
<span class="sd">        [0]  dog       snoopy</span>
<span class="sd">        [1]  cat       tom</span>
<span class="sd">        [2]  bear      yogi</span>
<span class="sd">        [3]  mouse     jerry</span>
<span class="sd">        [4]  donkey    None</span>
<span class="sd">        [5]  elephant  None</span>
<span class="sd">        [6]  ostrich   None</span>


<span class="sd">    The data we added didn&#39;t have names, so None values were inserted for the new rows.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">Frame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;frame must be a Frame type, but is: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">_scala</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.append_csv_file">
    <p>def <span class="ident">append_csv_file</span>(</p><p>self, file_name, schema, separator=&#39;,&#39;)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.append_csv_file', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.append_csv_file" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">append_csv_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">appendCsvFile</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">schema</span><span class="p">),</span> <span class="n">separator</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.assign_sample">
    <p>def <span class="ident">assign_sample</span>(</p><p>self, sample_percentages, sample_labels=None, output_column=None, random_seed=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Randomly group rows into user-defined classes.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>sample_percentages</td><td class='param-type'>(List[float]):</td><td class='param-desc'>Entries are non-negative and sum to 1. (See the note below.)
                     If the *i*'th entry of the  list is *p*, then then each row
                     receives label *i* with independent probability *p*.
</td></tr></table>

<table><tr><td class='param-name'>sample_labels</td><td class='param-type'>(Optional[List[str]]):</td><td class='param-desc'>Names to be used for the split classes. Defaults to 'TR', 'TE',
                'VA' when the length of *sample_percentages* is 3, and defaults
                to Sample_0, Sample_1, ... otherwise.
</td></tr></table>

<table><tr><td class='param-name'>output_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the new column which holds the labels generated by the function
</td></tr></table>

<table><tr><td class='param-name'>random_seed</td><td class='param-type'>(int):</td><td class='param-desc'>Random seed used to generate the labels.  Defaults to 0.</td></tr></table>

<p>Randomly assign classes to rows given a vector of percentages.
The table receives an additional column that contains a random label.
The random label is generated by a probability distribution function.
The distribution function is specified by the sample_percentages, a list of
floating point values, which add up to 1.
The labels are non-negative integers drawn from the range
:math:<code>[ 0, len(S) - 1]</code> where :math:<code>S</code> is the sample_percentages.</p>
<div class='section-header'>Notes:</div>

<p>The sample percentages provided by the user are preserved to at least eight
decimal places, but beyond this there may be small changes due to floating
point imprecision.</p>
<p>In particular:</p>
<ol>
<li>The engine validates that the sum of probabilities sums to 1.0 within
eight decimal places and returns an error if the sum falls outside of this
range.</li>
<li>The probability of the final class is clamped so that each row receives a
valid label with probability one.</li>
</ol>
<div class='section-header'>Examples:</div>

<p>Consider this simple frame.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  blip  id
=============
[0]  abc    0
[1]  def    1
[2]  ghi    2
[3]  jkl    3
[4]  mno    4
[5]  pqr    5
[6]  stu    6
[7]  vwx    7
[8]  yza    8
[9]  bcd    9
</pre></div>


<p>We'll assign labels to each row according to a rough 40-30-30 split, for
"train", "test", and "validate".</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.assign_sample([0.4, 0.3, 0.3])
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  blip  id  sample_bin
=========================
[0]  abc    0  VA
[1]  def    1  TR
[2]  ghi    2  TE
[3]  jkl    3  TE
[4]  mno    4  TE
[5]  pqr    5  TR
[6]  stu    6  TR
[7]  vwx    7  VA
[8]  yza    8  VA
[9]  bcd    9  VA
</pre></div>


<p>Now the frame  has a new column named "sample_bin" with a string label.
Values in the other columns are unaffected.</p>
<p>Here it is again, this time specifying labels, output column and random seed</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.assign_sample([0.2, 0.2, 0.3, 0.3],
...                     [&quot;cat1&quot;, &quot;cat2&quot;, &quot;cat3&quot;, &quot;cat4&quot;],
...                     output_column=&quot;cat&quot;,
...                     random_seed=12)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  blip  id  sample_bin  cat
===============================
[0]  abc    0  VA          cat4
[1]  def    1  TR          cat2
[2]  ghi    2  TE          cat3
[3]  jkl    3  TE          cat4
[4]  mno    4  TE          cat1
[5]  pqr    5  TR          cat3
[6]  stu    6  TR          cat2
[7]  vwx    7  VA          cat3
[8]  yza    8  VA          cat3
[9]  bcd    9  VA          cat4
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.assign_sample', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.assign_sample" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">assign_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_percentages</span><span class="p">,</span>
                  <span class="n">sample_labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                  <span class="n">output_column</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                  <span class="n">random_seed</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly group rows into user-defined classes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param sample_percentages: (List[float]) Entries are non-negative and sum to 1. (See the note below.)</span>
<span class="sd">                         If the *i*&#39;th entry of the  list is *p*, then then each row</span>
<span class="sd">                         receives label *i* with independent probability *p*.</span>
<span class="sd">    :param sample_labels: (Optional[List[str]]) Names to be used for the split classes. Defaults to &#39;TR&#39;, &#39;TE&#39;,</span>
<span class="sd">                    &#39;VA&#39; when the length of *sample_percentages* is 3, and defaults</span>
<span class="sd">                    to Sample_0, Sample_1, ... otherwise.</span>
<span class="sd">    :param output_column: (str) Name of the new column which holds the labels generated by the function</span>
<span class="sd">    :param random_seed: (int) Random seed used to generate the labels.  Defaults to 0.</span>

<span class="sd">    Randomly assign classes to rows given a vector of percentages.</span>
<span class="sd">    The table receives an additional column that contains a random label.</span>
<span class="sd">    The random label is generated by a probability distribution function.</span>
<span class="sd">    The distribution function is specified by the sample_percentages, a list of</span>
<span class="sd">    floating point values, which add up to 1.</span>
<span class="sd">    The labels are non-negative integers drawn from the range</span>
<span class="sd">    :math:`[ 0, len(S) - 1]` where :math:`S` is the sample_percentages.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The sample percentages provided by the user are preserved to at least eight</span>
<span class="sd">    decimal places, but beyond this there may be small changes due to floating</span>
<span class="sd">    point imprecision.</span>

<span class="sd">    In particular:</span>

<span class="sd">    1.  The engine validates that the sum of probabilities sums to 1.0 within</span>
<span class="sd">    eight decimal places and returns an error if the sum falls outside of this</span>
<span class="sd">    range.</span>
<span class="sd">    +  The probability of the final class is clamped so that each row receives a</span>
<span class="sd">    valid label with probability one.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider this simple frame.</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  blip  id</span>
<span class="sd">        =============</span>
<span class="sd">        [0]  abc    0</span>
<span class="sd">        [1]  def    1</span>
<span class="sd">        [2]  ghi    2</span>
<span class="sd">        [3]  jkl    3</span>
<span class="sd">        [4]  mno    4</span>
<span class="sd">        [5]  pqr    5</span>
<span class="sd">        [6]  stu    6</span>
<span class="sd">        [7]  vwx    7</span>
<span class="sd">        [8]  yza    8</span>
<span class="sd">        [9]  bcd    9</span>

<span class="sd">    We&#39;ll assign labels to each row according to a rough 40-30-30 split, for</span>
<span class="sd">    &quot;train&quot;, &quot;test&quot;, and &quot;validate&quot;.</span>

<span class="sd">        &gt;&gt;&gt; frame.assign_sample([0.4, 0.3, 0.3])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  blip  id  sample_bin</span>
<span class="sd">        =========================</span>
<span class="sd">        [0]  abc    0  VA</span>
<span class="sd">        [1]  def    1  TR</span>
<span class="sd">        [2]  ghi    2  TE</span>
<span class="sd">        [3]  jkl    3  TE</span>
<span class="sd">        [4]  mno    4  TE</span>
<span class="sd">        [5]  pqr    5  TR</span>
<span class="sd">        [6]  stu    6  TR</span>
<span class="sd">        [7]  vwx    7  VA</span>
<span class="sd">        [8]  yza    8  VA</span>
<span class="sd">        [9]  bcd    9  VA</span>


<span class="sd">    Now the frame  has a new column named &quot;sample_bin&quot; with a string label.</span>
<span class="sd">    Values in the other columns are unaffected.</span>

<span class="sd">    Here it is again, this time specifying labels, output column and random seed</span>

<span class="sd">        &gt;&gt;&gt; frame.assign_sample([0.2, 0.2, 0.3, 0.3],</span>
<span class="sd">        ...                     [&quot;cat1&quot;, &quot;cat2&quot;, &quot;cat3&quot;, &quot;cat4&quot;],</span>
<span class="sd">        ...                     output_column=&quot;cat&quot;,</span>
<span class="sd">        ...                     random_seed=12)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  blip  id  sample_bin  cat</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]  abc    0  VA          cat4</span>
<span class="sd">        [1]  def    1  TR          cat2</span>
<span class="sd">        [2]  ghi    2  TE          cat3</span>
<span class="sd">        [3]  jkl    3  TE          cat4</span>
<span class="sd">        [4]  mno    4  TE          cat1</span>
<span class="sd">        [5]  pqr    5  TR          cat3</span>
<span class="sd">        [6]  stu    6  TR          cat2</span>
<span class="sd">        [7]  vwx    7  VA          cat3</span>
<span class="sd">        [8]  yza    8  VA          cat3</span>
<span class="sd">        [9]  bcd    9  VA          cat4</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">assignSample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_double</span><span class="p">(</span><span class="n">sample_percentages</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">sample_labels</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">output_column</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">random_seed</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.bin_column">
    <p>def <span class="ident">bin_column</span>(</p><p>self, column_name, bins=None, include_lowest=True, strict_binning=False, bin_column_name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Summarize rows of data based on the value in a single column by sorting them
into bins, or groups, based on a list of bin cutoff points or a specified number of
equal-width bins.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column to bin
</td></tr></table>

<table><tr><td class='param-name'>bins</td><td class='param-type'>(Optional[List[float]]):</td><td class='param-desc'>Either a single value representing the number of equal-width bins to create, or an array of values
 containing bin cutoff points. Array can be list or tuple. If an array is provided, values must be progressively
 increasing. All bin boundaries must be included, so, with N bins, you need N+1 values.
 Default (None or Empty List) is equal-width bins where the maximum number of bins is the Square-root choice
 :math:`\lfloor \sqrt{m} 
floor`, where :math:`m` is the number of rows.
</td></tr></table>

<table><tr><td class='param-name'>include_lowest</td><td class='param-type'>(bool):</td><td class='param-desc'>Specify how the boundary conditions are handled. ``True`` indicates that the lower bound
 of the bin is inclusive. ``False`` indicates that the upper bound is inclusive. Default is ``True``.
</td></tr></table>

<table><tr><td class='param-name'>strict_binning</td><td class='param-type'>(bool):</td><td class='param-desc'>Specify how values outside of the cutoffs array should be binned. If set to ``True``, each
 value less than cutoffs[0] or greater than cutoffs[-1] will be assigned a bin value of -1. If set to ``False``,
 values less than cutoffs[0] will be included in the first bin while values greater than cutoffs[-1] will be
 included in the final bin.
</td></tr></table>

<table><tr><td class='param-name'>bin_column_name</td><td class='param-type'>(str):</td><td class='param-desc'>The name for the new binned column.  Default is ``&lt;column_name&gt;_binned``
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(List[float]): </td><td class='param-desc'>a list containing the edges of each bin</td></tr></table></p>

<div class='section-header'>Notes:</div>

<ol>
<li>Bins IDs are 0-index, in other words, the lowest bin number is 0.</li>
<li>The first and last cutoffs are always included in the bins.
    When <em>include_lowest</em> is <code>True</code>, the last bin includes both cutoffs.
    When <em>include_lowest</em> is <code>False</code>, the first bin (bin 0) includes both
    cutoffs.</li>
</ol>
<div class='section-header'>Examples:</div>

<p>For these examples, we will use a frame with column <em>a</em> accessed by a Frame
object <em>my_frame</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect(n=11)
[##]  a
========
[0]    1
[1]    1
[2]    2
[3]    3
[4]    5
[5]    8
[6]   13
[7]   21
[8]   34
[9]   55
[10]  89
</pre></div>


<p>Modify the frame with a column showing what bin the data is in, by
specifying cutoffs for the bin edges.
The data values should use strict_binning:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [5, 12, 25, 60], include_lowest=True,
... strict_binning=True, bin_column_name=&#39;binned_using_cutoffs&#39;)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect(n=11)
[##]  a   binned_using_cutoffs
==============================
[0]    1                    -1
[1]    1                    -1
[2]    2                    -1
[3]    3                    -1
[4]    5                     0
[5]    8                     0
[6]   13                     1
[7]   21                     1
[8]   34                     2
[9]   55                     2
[10]  89                    -1
</pre></div>


<p>Modify the frame with a column showing what bin the data is in.
The data value should not use strict_binning:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [5, 12, 25, 60], include_lowest=True,
... strict_binning=False, bin_column_name=&#39;binned_using_cutoffs&#39;)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect(n=11)
[##]  a   binned_using_cutoffs
==============================
[0]    1                     0
[1]    1                     0
[2]    2                     0
[3]    3                     0
[4]    5                     0
[5]    8                     0
[6]   13                     1
[7]   21                     1
[8]   34                     2
[9]   55                     2
[10]  89                     2
</pre></div>


<p>Modify the frame with a column showing what bin the data is in.
The bins should be lower inclusive:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [1,5,34,55,89], include_lowest=True,
... strict_binning=False, bin_column_name=&#39;binned_using_cutoffs&#39;)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect( n=11 )
[##]  a   binned_using_cutoffs
==============================
[0]    1                     0
[1]    1                     0
[2]    2                     0
[3]    3                     0
[4]    5                     1
[5]    8                     1
[6]   13                     1
[7]   21                     1
[8]   34                     2
[9]   55                     3
[10]  89                     3
</pre></div>


<p>Modify the frame with a column showing what bin the data is in.
The bins should be upper inclusive:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [1,5,34,55,89], include_lowest=False,
... strict_binning=True, bin_column_name=&#39;binned_using_cutoffs&#39;)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect( n=11 )
[##]  a   binned_using_cutoffs
==============================
[0]    1                     0
[1]    1                     0
[2]    2                     0
[3]    3                     0
[4]    5                     0
[5]    8                     1
[6]   13                     1
[7]   21                     1
[8]   34                     1
[9]   55                     2
[10]  89                     3
</pre></div>


<p>Modify the frame with a column of 3 equal-width bins.  This also
returns the cutoffs that were used for creating the bins.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; cutoffs = frame.bin_column(&#39;a&#39;, 3, bin_column_name=&#39;equal_width_bins&#39;)

&gt;&gt;&gt; print cutoffs
[1.0, 30.333333333333332, 59.666666666666664, 89.0]

&gt;&gt;&gt; frame.inspect(n=frame.count())
[##]  a   equal_width_bins
==========================
[0]    1                 0
[1]    1                 0
[2]    2                 0
[3]    3                 0
[4]    5                 0
[5]    8                 0
[6]   13                 0
[7]   21                 0
[8]   34                 1
[9]   55                 1
[10]  89                 2
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.bin_column', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.bin_column" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">bin_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">include_lowest</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">strict_binning</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">bin_column_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summarize rows of data based on the value in a single column by sorting them</span>
<span class="sd">    into bins, or groups, based on a list of bin cutoff points or a specified number of</span>
<span class="sd">    equal-width bins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: (str) Name of the column to bin</span>
<span class="sd">    :param bins: (Optional[List[float]]) Either a single value representing the number of equal-width bins to create, or an array of values</span>
<span class="sd">     containing bin cutoff points. Array can be list or tuple. If an array is provided, values must be progressively</span>
<span class="sd">     increasing. All bin boundaries must be included, so, with N bins, you need N+1 values.</span>
<span class="sd">     Default (None or Empty List) is equal-width bins where the maximum number of bins is the Square-root choice</span>
<span class="sd">     :math:`\lfloor \sqrt{m} \rfloor`, where :math:`m` is the number of rows.</span>
<span class="sd">    :param include_lowest: (bool) Specify how the boundary conditions are handled. ``True`` indicates that the lower bound</span>
<span class="sd">     of the bin is inclusive. ``False`` indicates that the upper bound is inclusive. Default is ``True``.</span>
<span class="sd">    :param strict_binning: (bool) Specify how values outside of the cutoffs array should be binned. If set to ``True``, each</span>
<span class="sd">     value less than cutoffs[0] or greater than cutoffs[-1] will be assigned a bin value of -1. If set to ``False``,</span>
<span class="sd">     values less than cutoffs[0] will be included in the first bin while values greater than cutoffs[-1] will be</span>
<span class="sd">     included in the final bin.</span>
<span class="sd">    :param bin_column_name: (str) The name for the new binned column.  Default is ``&amp;lt;column_name&amp;gt;_binned``</span>
<span class="sd">    :return: (List[float]) a list containing the edges of each bin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    1.  Bins IDs are 0-index, in other words, the lowest bin number is 0.</span>
<span class="sd">    +   The first and last cutoffs are always included in the bins.</span>
<span class="sd">        When *include_lowest* is ``True``, the last bin includes both cutoffs.</span>
<span class="sd">        When *include_lowest* is ``False``, the first bin (bin 0) includes both</span>
<span class="sd">        cutoffs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For these examples, we will use a frame with column *a* accessed by a Frame</span>
<span class="sd">    object *my_frame*:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(n=11)</span>
<span class="sd">        [##]  a</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    1</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    3</span>
<span class="sd">        [4]    5</span>
<span class="sd">        [5]    8</span>
<span class="sd">        [6]   13</span>
<span class="sd">        [7]   21</span>
<span class="sd">        [8]   34</span>
<span class="sd">        [9]   55</span>
<span class="sd">        [10]  89</span>

<span class="sd">    Modify the frame with a column showing what bin the data is in, by</span>
<span class="sd">    specifying cutoffs for the bin edges.</span>
<span class="sd">    The data values should use strict_binning:</span>

<span class="sd">        &gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [5, 12, 25, 60], include_lowest=True,</span>
<span class="sd">        ... strict_binning=True, bin_column_name=&#39;binned_using_cutoffs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(n=11)</span>
<span class="sd">        [##]  a   binned_using_cutoffs</span>
<span class="sd">        ==============================</span>
<span class="sd">        [0]    1                    -1</span>
<span class="sd">        [1]    1                    -1</span>
<span class="sd">        [2]    2                    -1</span>
<span class="sd">        [3]    3                    -1</span>
<span class="sd">        [4]    5                     0</span>
<span class="sd">        [5]    8                     0</span>
<span class="sd">        [6]   13                     1</span>
<span class="sd">        [7]   21                     1</span>
<span class="sd">        [8]   34                     2</span>
<span class="sd">        [9]   55                     2</span>
<span class="sd">        [10]  89                    -1</span>


<span class="sd">    Modify the frame with a column showing what bin the data is in.</span>
<span class="sd">    The data value should not use strict_binning:</span>

<span class="sd">        &gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [5, 12, 25, 60], include_lowest=True,</span>
<span class="sd">        ... strict_binning=False, bin_column_name=&#39;binned_using_cutoffs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(n=11)</span>
<span class="sd">        [##]  a   binned_using_cutoffs</span>
<span class="sd">        ==============================</span>
<span class="sd">        [0]    1                     0</span>
<span class="sd">        [1]    1                     0</span>
<span class="sd">        [2]    2                     0</span>
<span class="sd">        [3]    3                     0</span>
<span class="sd">        [4]    5                     0</span>
<span class="sd">        [5]    8                     0</span>
<span class="sd">        [6]   13                     1</span>
<span class="sd">        [7]   21                     1</span>
<span class="sd">        [8]   34                     2</span>
<span class="sd">        [9]   55                     2</span>
<span class="sd">        [10]  89                     2</span>

<span class="sd">    Modify the frame with a column showing what bin the data is in.</span>
<span class="sd">    The bins should be lower inclusive:</span>

<span class="sd">        &gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [1,5,34,55,89], include_lowest=True,</span>
<span class="sd">        ... strict_binning=False, bin_column_name=&#39;binned_using_cutoffs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect( n=11 )</span>
<span class="sd">        [##]  a   binned_using_cutoffs</span>
<span class="sd">        ==============================</span>
<span class="sd">        [0]    1                     0</span>
<span class="sd">        [1]    1                     0</span>
<span class="sd">        [2]    2                     0</span>
<span class="sd">        [3]    3                     0</span>
<span class="sd">        [4]    5                     1</span>
<span class="sd">        [5]    8                     1</span>
<span class="sd">        [6]   13                     1</span>
<span class="sd">        [7]   21                     1</span>
<span class="sd">        [8]   34                     2</span>
<span class="sd">        [9]   55                     3</span>
<span class="sd">        [10]  89                     3</span>

<span class="sd">    Modify the frame with a column showing what bin the data is in.</span>
<span class="sd">    The bins should be upper inclusive:</span>

<span class="sd">        &gt;&gt;&gt; frame.bin_column(&#39;a&#39;, [1,5,34,55,89], include_lowest=False,</span>
<span class="sd">        ... strict_binning=True, bin_column_name=&#39;binned_using_cutoffs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect( n=11 )</span>
<span class="sd">        [##]  a   binned_using_cutoffs</span>
<span class="sd">        ==============================</span>
<span class="sd">        [0]    1                     0</span>
<span class="sd">        [1]    1                     0</span>
<span class="sd">        [2]    2                     0</span>
<span class="sd">        [3]    3                     0</span>
<span class="sd">        [4]    5                     0</span>
<span class="sd">        [5]    8                     1</span>
<span class="sd">        [6]   13                     1</span>
<span class="sd">        [7]   21                     1</span>
<span class="sd">        [8]   34                     1</span>
<span class="sd">        [9]   55                     2</span>
<span class="sd">        [10]  89                     3</span>

<span class="sd">    Modify the frame with a column of 3 equal-width bins.  This also</span>
<span class="sd">    returns the cutoffs that were used for creating the bins.</span>

<span class="sd">        &gt;&gt;&gt; cutoffs = frame.bin_column(&#39;a&#39;, 3, bin_column_name=&#39;equal_width_bins&#39;)</span>

<span class="sd">        &gt;&gt;&gt; print cutoffs</span>
<span class="sd">        [1.0, 30.333333333333332, 59.666666666666664, 89.0]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(n=frame.count())</span>
<span class="sd">        [##]  a   equal_width_bins</span>
<span class="sd">        ==========================</span>
<span class="sd">        [0]    1                 0</span>
<span class="sd">        [1]    1                 0</span>
<span class="sd">        [2]    2                 0</span>
<span class="sd">        [3]    3                 0</span>
<span class="sd">        [4]    5                 0</span>
<span class="sd">        [5]    8                 0</span>
<span class="sd">        [6]   13                 0</span>
<span class="sd">        [7]   21                 0</span>
<span class="sd">        [8]   34                 1</span>
<span class="sd">        [9]   55                 1</span>
<span class="sd">        [10]  89                 2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">bins</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_scala_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">binColumn</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option_list_double</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span>
                                <span class="n">include_lowest</span><span class="p">,</span>
                                <span class="n">strict_binning</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">bin_column_name</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.binary_classification_metrics">
    <p>def <span class="ident">binary_classification_metrics</span>(</p><p>self, label_column, pred_column, pos_label, beta=1.0, frequency_column=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Statistics of accuracy, precision, and others for a binary classification model.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>label_column</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column containing the correct label for each instance.
</td></tr></table>

<table><tr><td class='param-name'>pred_column</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column containing the predicted label for each instance.
</td></tr></table>

<table><tr><td class='param-name'>pos_label</td><td class='param-type'>(Any):</td><td class='param-desc'>The value to be interpreted as a positive instance for binary classification.
</td></tr></table>

<table><tr><td class='param-name'>beta</td><td class='param-type'>(Optional[float]):</td><td class='param-desc'>This is the beta value to use for :math:`F_{ eta}` measure (default F1 measure is computed);
must be greater than zero. Defaults is 1.
</td></tr></table>

<table><tr><td class='param-name'>frequency_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The name of an optional column containing the frequency of observations.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(ClassificationMetricsValue): </td><td class='param-desc'>The data returned is composed of multiple components:<br>
    &lt;object&gt;.accuracy : double<br>
    &lt;object&gt;.confusion_matrix : table<br>
    &lt;object&gt;.f_measure : double<br>
    &lt;object&gt;.precision : double<br>
    &lt;object&gt;.recall : double<br></td></tr></table></p>

<p>Calculate the accuracy, precision, confusion_matrix, recall and :math:<code>F_{ eta}</code> measure for a
    classification model.</p>
<ul>
<li>
<p>The <strong>f_measure</strong> result is the :math:<code>F_{ eta}</code> measure for a
    classification model.
    The :math:<code>F_{ eta}</code> measure of a binary classification model is the
    harmonic mean of precision and recall.
    If we let:</p>
<ul>
<li>beta :math:<code>\equiv eta</code>,</li>
<li>:math:<code>T_{P}</code> denotes the number of true positives,</li>
<li>:math:<code>F_{P}</code> denotes the number of false positives, and</li>
<li>:math:<code>F_{N}</code> denotes the number of false negatives</li>
</ul>
<p>then:</p>
<p>.. math::</p>
<p>F_{ eta} = (1 + eta ^ 2) * rac{ rac{T_{P}}{T_{P} + F_{P}} *                 rac{T_{P}}{T_{P} + F_{N}}}{ eta ^ 2 * rac{T_{P}}{T_{P} +                                                                          F_{P}}  + rac{T_{P}}{T_{P} + F_{N}}}</p>
<p>The :math:<code>F_{ eta}</code> measure for a multi-class classification model is
computed as the weighted average of the :math:<code>F_{ eta}</code> measure for
    each label, where the weight is the number of instances of each label.
The determination of binary vs. multi-class is automatically inferred
from the data.</p>
<ul>
<li>
<p>The <strong>recall</strong> result of a binary classification model is the proportion
of positive instances that are correctly identified.
If we let :math:<code>T_{P}</code> denote the number of true positives and
:math:<code>F_{N}</code> denote the number of false negatives, then the model
recall is given by :math:<code>rac {T_{P}} {T_{P} + F_{N}}</code>.</p>
</li>
<li>
<p>The <strong>precision</strong> of a binary classification model is the proportion of
predicted positive instances that are correctly identified.
If we let :math:<code>T_{P}</code> denote the number of true positives and
:math:<code>F_{P}</code> denote the number of false positives, then the model
precision is given by: :math:<code>rac {T_{P}} {T_{P} + F_{P}}</code>.</p>
</li>
<li>
<p>The <strong>accuracy</strong> of a classification model is the proportion of
predictions that are correctly identified.
If we let :math:<code>T_{P}</code> denote the number of true positives,
:math:<code>T_{N}</code> denote the number of true negatives, and :math:<code>K</code> denote
the total number of classified instances, then the model accuracy is
given by: :math:<code>rac{T_{P} + T_{N}}{K}</code>.</p>
</li>
</ul>
</li>
<li>
<p>The <strong>confusion_matrix</strong> result is a confusion matrix for a
    binary classifier model, formatted for human readability.</p>
</li>
</ul>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a      b  labels  predictions
==================================
[0]  red    1       0            0
[1]  blue   3       1            0
[2]  green  1       0            0
[3]  green  0       1            1

&gt;&gt;&gt; cm = my_frame.binary_classification_metrics(&#39;labels&#39;, &#39;predictions&#39;, 1, 1)
[===Job Progress===]

&gt;&gt;&gt; cm.f_measure
0.6666666666666666

&gt;&gt;&gt; cm.recall
0.5

&gt;&gt;&gt; cm.accuracy
0.75

&gt;&gt;&gt; cm.precision
1.0

&gt;&gt;&gt; cm.confusion_matrix
            Predicted_Pos  Predicted_Neg
Actual_Pos              1              1
Actual_Neg              0              2
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.binary_classification_metrics', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.binary_classification_metrics" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">binary_classification_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_column</span><span class="p">,</span> <span class="n">pred_column</span><span class="p">,</span> <span class="n">pos_label</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">frequency_column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Statistics of accuracy, precision, and others for a binary classification model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param label_column: (str) The name of the column containing the correct label for each instance.</span>
<span class="sd">    :param pred_column: (str) The name of the column containing the predicted label for each instance.</span>
<span class="sd">    :param pos_label: (Any) The value to be interpreted as a positive instance for binary classification.</span>
<span class="sd">    :param beta: (Optional[float]) This is the beta value to use for :math:`F_{ \beta}` measure (default F1 measure is computed);</span>
<span class="sd">    must be greater than zero. Defaults is 1.</span>
<span class="sd">    :param frequency_column: (Optional[str]) The name of an optional column containing the frequency of observations.</span>
<span class="sd">    :return: (ClassificationMetricsValue) The data returned is composed of multiple components:&lt;br&gt;</span>
<span class="sd">        &amp;lt;object&amp;gt;.accuracy : double&lt;br&gt;</span>
<span class="sd">        &amp;lt;object&amp;gt;.confusion_matrix : table&lt;br&gt;</span>
<span class="sd">        &amp;lt;object&amp;gt;.f_measure : double&lt;br&gt;</span>
<span class="sd">        &amp;lt;object&amp;gt;.precision : double&lt;br&gt;</span>
<span class="sd">        &amp;lt;object&amp;gt;.recall : double&lt;br&gt;</span>


<span class="sd">    Calculate the accuracy, precision, confusion_matrix, recall and :math:`F_{ \beta}` measure for a</span>
<span class="sd">        classification model.</span>

<span class="sd">    *   The **f_measure** result is the :math:`F_{ \beta}` measure for a</span>
<span class="sd">        classification model.</span>
<span class="sd">        The :math:`F_{ \beta}` measure of a binary classification model is the</span>
<span class="sd">        harmonic mean of precision and recall.</span>
<span class="sd">        If we let:</span>

<span class="sd">        * beta :math:`\equiv \beta`,</span>
<span class="sd">        * :math:`T_{P}` denotes the number of true positives,</span>
<span class="sd">        * :math:`F_{P}` denotes the number of false positives, and</span>
<span class="sd">        * :math:`F_{N}` denotes the number of false negatives</span>

<span class="sd">        then:</span>

<span class="sd">        .. math::</span>

<span class="sd">        F_{ \beta} = (1 + \beta ^ 2) * \frac{ \frac{T_{P}}{T_{P} + F_{P}} * \</span>
<span class="sd">                \frac{T_{P}}{T_{P} + F_{N}}}{ \beta ^ 2 * \frac{T_{P}}{T_{P} + \</span>
<span class="sd">                                                                         F_{P}}  + \frac{T_{P}}{T_{P} + F_{N}}}</span>

<span class="sd">        The :math:`F_{ \beta}` measure for a multi-class classification model is</span>
<span class="sd">        computed as the weighted average of the :math:`F_{ \beta}` measure for</span>
<span class="sd">            each label, where the weight is the number of instances of each label.</span>
<span class="sd">        The determination of binary vs. multi-class is automatically inferred</span>
<span class="sd">        from the data.</span>

<span class="sd">        *   The **recall** result of a binary classification model is the proportion</span>
<span class="sd">        of positive instances that are correctly identified.</span>
<span class="sd">        If we let :math:`T_{P}` denote the number of true positives and</span>
<span class="sd">        :math:`F_{N}` denote the number of false negatives, then the model</span>
<span class="sd">        recall is given by :math:`\frac {T_{P}} {T_{P} + F_{N}}`.</span>

<span class="sd">        *   The **precision** of a binary classification model is the proportion of</span>
<span class="sd">        predicted positive instances that are correctly identified.</span>
<span class="sd">        If we let :math:`T_{P}` denote the number of true positives and</span>
<span class="sd">        :math:`F_{P}` denote the number of false positives, then the model</span>
<span class="sd">        precision is given by: :math:`\frac {T_{P}} {T_{P} + F_{P}}`.</span>

<span class="sd">        *   The **accuracy** of a classification model is the proportion of</span>
<span class="sd">        predictions that are correctly identified.</span>
<span class="sd">        If we let :math:`T_{P}` denote the number of true positives,</span>
<span class="sd">        :math:`T_{N}` denote the number of true negatives, and :math:`K` denote</span>
<span class="sd">        the total number of classified instances, then the model accuracy is</span>
<span class="sd">        given by: :math:`\frac{T_{P} + T_{N}}{K}`.</span>

<span class="sd">    *   The **confusion_matrix** result is a confusion matrix for a</span>
<span class="sd">        binary classifier model, formatted for human readability.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider Frame *my_frame*, which contains the data</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a      b  labels  predictions</span>
<span class="sd">        ==================================</span>
<span class="sd">        [0]  red    1       0            0</span>
<span class="sd">        [1]  blue   3       1            0</span>
<span class="sd">        [2]  green  1       0            0</span>
<span class="sd">        [3]  green  0       1            1</span>

<span class="sd">        &gt;&gt;&gt; cm = my_frame.binary_classification_metrics(&#39;labels&#39;, &#39;predictions&#39;, 1, 1)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; cm.f_measure</span>
<span class="sd">        0.6666666666666666</span>

<span class="sd">        &gt;&gt;&gt; cm.recall</span>
<span class="sd">        0.5</span>

<span class="sd">        &gt;&gt;&gt; cm.accuracy</span>
<span class="sd">        0.75</span>

<span class="sd">        &gt;&gt;&gt; cm.precision</span>
<span class="sd">        1.0</span>

<span class="sd">        &gt;&gt;&gt; cm.confusion_matrix</span>
<span class="sd">                    Predicted_Pos  Predicted_Neg</span>
<span class="sd">        Actual_Pos              1              1</span>
<span class="sd">        Actual_Neg              0              2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ClassificationMetricsValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">binaryClassificationMetrics</span><span class="p">(</span><span class="n">label_column</span><span class="p">,</span>
                                      <span class="n">pred_column</span><span class="p">,</span>
                                      <span class="n">pos_label</span><span class="p">,</span>
                                      <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">frequency_column</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.box_cox">
    <p>def <span class="ident">box_cox</span>(</p><p>self, column_name, lambda_value=0.0, box_cox_column_name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the box-cox transformation for each row on a given column of the current frame</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name: </td><td class='param-desc'>Name of the column to perform the transformation on
</td></tr></table>

<table><tr><td class='param-name'>lambda_value: </td><td class='param-desc'>Lambda power parameter. Default is 0.0
</td></tr></table>

<table><tr><td class='param-name'>box_cox_column_name: </td><td class='param-desc'>Optional column name for the box_cox value
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns a frame with a new column storing the box-cox transformed value</td></tr></table></p>

<p>Calculate the box-cox transformation for each row in column 'column_name' of a frame using the lambda_value.</p>
<p>Box-cox transformation is computed by the following formula:</p>
<p>boxcox = log(y); if lambda=0,
boxcox = (y^lambda -1)/lambda ; else
where log is the natural log</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; data = [[7.7132064326674596],[0.207519493594015],[6.336482349262754],[7.4880388253861181],[4.9850701230259045]]
&gt;&gt;&gt; schema = [(&quot;input&quot;, float)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
&gt;&gt;&gt; my_frame.inspect()
[#]  input
===================
[0]   7.71320643267
[1]  0.207519493594
[2]   6.33648234926
[3]   7.48803882539
[4]   4.98507012303

Compute the box-cox transformation on the &#39;input&#39; column
&gt;&gt;&gt; my_frame.box_cox(&#39;input&#39;,0.3)

A new column gets added to the frame which stores the box-cox transformation for each row
&gt;&gt;&gt; my_frame.inspect()
[#]  input           input_lambda_0.3
=====================================
[0]   7.71320643267     2.81913279907
[1]  0.207519493594    -1.25365381375
[2]   6.33648234926     2.46673638752
[3]   7.48803882539     2.76469126003
[4]   4.98507012303     2.06401101556
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.box_cox', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.box_cox" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">box_cox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lambda_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">box_cox_column_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate the box-cox transformation for each row on a given column of the current frame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: Name of the column to perform the transformation on</span>
<span class="sd">    :param lambda_value: Lambda power parameter. Default is 0.0</span>
<span class="sd">    :param box_cox_column_name: Optional column name for the box_cox value</span>
<span class="sd">    :return: (Frame) returns a frame with a new column storing the box-cox transformed value</span>

<span class="sd">    Calculate the box-cox transformation for each row in column &#39;column_name&#39; of a frame using the lambda_value.</span>

<span class="sd">    Box-cox transformation is computed by the following formula:</span>

<span class="sd">    boxcox = log(y); if lambda=0,</span>
<span class="sd">    boxcox = (y^lambda -1)/lambda ; else</span>
<span class="sd">    where log is the natural log</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; data = [[7.7132064326674596],[0.207519493594015],[6.336482349262754],[7.4880388253861181],[4.9850701230259045]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&quot;input&quot;, float)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  input</span>
<span class="sd">        ===================</span>
<span class="sd">        [0]   7.71320643267</span>
<span class="sd">        [1]  0.207519493594</span>
<span class="sd">        [2]   6.33648234926</span>
<span class="sd">        [3]   7.48803882539</span>
<span class="sd">        [4]   4.98507012303</span>

<span class="sd">        Compute the box-cox transformation on the &#39;input&#39; column</span>
<span class="sd">        &gt;&gt;&gt; my_frame.box_cox(&#39;input&#39;,0.3)</span>

<span class="sd">        A new column gets added to the frame which stores the box-cox transformation for each row</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  input           input_lambda_0.3</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]   7.71320643267     2.81913279907</span>
<span class="sd">        [1]  0.207519493594    -1.25365381375</span>
<span class="sd">        [2]   6.33648234926     2.46673638752</span>
<span class="sd">        [3]   7.48803882539     2.76469126003</span>
<span class="sd">        [4]   4.98507012303     2.06401101556</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">boxCox</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">lambda_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">box_cox_column_name</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.categorical_summary">
    <p>def <span class="ident">categorical_summary</span>(</p><p>self, columns, top_k=None, threshold=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Build summary of the data.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(List[CategoricalSummaryInput]):</td><td class='param-desc'>List of CategoricalSummaryInput consisting of column, topk and/or threshold
</td></tr></table>

<table><tr><td class='param-name'>top_k</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>Displays levels which are in the top k most frequently
        occurring values for that column.
        Default is 10.
</td></tr></table>

<table><tr><td class='param-name'>threshold</td><td class='param-type'>(Optional[float]):</td><td class='param-desc'>Displays levels which are above the threshold percentage with
        respect to the total row count.
        Default is 0.0.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(List[CategoricalSummaryOutput]): </td><td class='param-desc'>List of CategoricalSummaryOutput objects for specified column(s) consisting of levels with
         their frequency and percentage.</td></tr></table></p>

<p>Compute a summary of the data in a column(s) for categorical or numerical data types.
The returned value is a Map containing categorical summary for each specified column.</p>
<p>For each column, levels which satisfy the top k and/or threshold cutoffs are
displayed along with their frequency and percentage occurrence with respect to
the total rows in the dataset.</p>
<p>Performs level pruning first based on top k and then filters
out levels which satisfy the threshold criterion.</p>
<p>Missing data is reported when a column value is empty ("") or null.</p>
<p>All remaining data is grouped together in the Other category and its frequency
and percentage are reported as well.</p>
<p>User must specify the column name and can optionally specify top_k and/or threshold.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  source           target
=====================================
[0]  entity           thing
[1]  entity           physical_entity
[2]  entity           abstraction
[3]  physical_entity  entity
[4]  physical_entity  matter
[5]  physical_entity  process
[6]  physical_entity  thing
[7]  physical_entity  substance
[8]  physical_entity  object
[9]  physical_entity  causal_agent

&gt;&gt;&gt; cm = my_frame.categorical_summary(&#39;source&#39;, top_k=2)
[===Job Progress===]

&gt;&gt;&gt; cm
column_name = &quot;source&quot;
[#]  level        frequency  percentage
===========================================
[0]  thing                9  0.321428571429
[1]  abstraction          9  0.321428571429
[2]  &lt;Missing&gt;            0             0.0
[3]  &lt;Other&gt;             10  0.357142857143

&gt;&gt;&gt; cm = my_frame.categorical_summary(&#39;source&#39;, threshold = 0.5)
[===Job Progress===]

&gt;&gt;&gt; cm
column_name = &quot;source&quot;
[#]  level      frequency  percentage
=====================================
[0]  &lt;Missing&gt;          0         0.0
[1]  &lt;Other&gt;           28         1.0

&gt;&gt;&gt; cm = my_frame.categorical_summary([&#39;source&#39;, &#39;target&#39;], top_k=[2, None], threshold=[None, 0.5])
[===Job Progress===]

&gt;&gt;&gt; cm
column_name = &quot;source&quot;
[#]  level        frequency  percentage
===========================================
[0]  thing                9  0.321428571429
[1]  abstraction          9  0.321428571429
[2]  &lt;Missing&gt;            0             0.0
[3]  &lt;Other&gt;             10  0.357142857143
&lt;BLANKLINE&gt;
column_name = &quot;target&quot;
[#]  level      frequency  percentage
=====================================
[0]  &lt;Missing&gt;          0         0.0
[1]  &lt;Other&gt;           28         1.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.categorical_summary', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.categorical_summary" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">categorical_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">top_k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build summary of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (List[CategoricalSummaryInput]) List of CategoricalSummaryInput consisting of column, topk and/or threshold</span>
<span class="sd">    :param top_k: (Optional[int]) Displays levels which are in the top k most frequently</span>
<span class="sd">            occurring values for that column.</span>
<span class="sd">            Default is 10.</span>
<span class="sd">    :param threshold: (Optional[float]) Displays levels which are above the threshold percentage with</span>
<span class="sd">            respect to the total row count.</span>
<span class="sd">            Default is 0.0.</span>
<span class="sd">    :return: (List[CategoricalSummaryOutput]) List of CategoricalSummaryOutput objects for specified column(s) consisting of levels with</span>
<span class="sd">             their frequency and percentage.</span>

<span class="sd">    Compute a summary of the data in a column(s) for categorical or numerical data types.</span>
<span class="sd">    The returned value is a Map containing categorical summary for each specified column.</span>

<span class="sd">    For each column, levels which satisfy the top k and/or threshold cutoffs are</span>
<span class="sd">    displayed along with their frequency and percentage occurrence with respect to</span>
<span class="sd">    the total rows in the dataset.</span>

<span class="sd">    Performs level pruning first based on top k and then filters</span>
<span class="sd">    out levels which satisfy the threshold criterion.</span>

<span class="sd">    Missing data is reported when a column value is empty (&quot;&quot;) or null.</span>

<span class="sd">    All remaining data is grouped together in the Other category and its frequency</span>
<span class="sd">    and percentage are reported as well.</span>

<span class="sd">    User must specify the column name and can optionally specify top_k and/or threshold.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider Frame *my_frame*, which contains the data</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  source           target</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  entity           thing</span>
<span class="sd">        [1]  entity           physical_entity</span>
<span class="sd">        [2]  entity           abstraction</span>
<span class="sd">        [3]  physical_entity  entity</span>
<span class="sd">        [4]  physical_entity  matter</span>
<span class="sd">        [5]  physical_entity  process</span>
<span class="sd">        [6]  physical_entity  thing</span>
<span class="sd">        [7]  physical_entity  substance</span>
<span class="sd">        [8]  physical_entity  object</span>
<span class="sd">        [9]  physical_entity  causal_agent</span>

<span class="sd">        &gt;&gt;&gt; cm = my_frame.categorical_summary(&#39;source&#39;, top_k=2)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; cm</span>
<span class="sd">        column_name = &quot;source&quot;</span>
<span class="sd">        [#]  level        frequency  percentage</span>
<span class="sd">        ===========================================</span>
<span class="sd">        [0]  thing                9  0.321428571429</span>
<span class="sd">        [1]  abstraction          9  0.321428571429</span>
<span class="sd">        [2]  &lt;Missing&gt;            0             0.0</span>
<span class="sd">        [3]  &lt;Other&gt;             10  0.357142857143</span>

<span class="sd">        &gt;&gt;&gt; cm = my_frame.categorical_summary(&#39;source&#39;, threshold = 0.5)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; cm</span>
<span class="sd">        column_name = &quot;source&quot;</span>
<span class="sd">        [#]  level      frequency  percentage</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  &lt;Missing&gt;          0         0.0</span>
<span class="sd">        [1]  &lt;Other&gt;           28         1.0</span>

<span class="sd">        &gt;&gt;&gt; cm = my_frame.categorical_summary([&#39;source&#39;, &#39;target&#39;], top_k=[2, None], threshold=[None, 0.5])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; cm</span>
<span class="sd">        column_name = &quot;source&quot;</span>
<span class="sd">        [#]  level        frequency  percentage</span>
<span class="sd">        ===========================================</span>
<span class="sd">        [0]  thing                9  0.321428571429</span>
<span class="sd">        [1]  abstraction          9  0.321428571429</span>
<span class="sd">        [2]  &lt;Missing&gt;            0             0.0</span>
<span class="sd">        [3]  &lt;Other&gt;             10  0.357142857143</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        column_name = &quot;target&quot;</span>
<span class="sd">        [#]  level      frequency  percentage</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  &lt;Missing&gt;          0         0.0</span>
<span class="sd">        [1]  &lt;Other&gt;           28         1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">top_k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top_k</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">top_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">top_k</span><span class="p">]</span>
        <span class="n">top_k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">top_k</span><span class="p">]</span>
        <span class="n">top_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list</span><span class="p">(</span><span class="n">top_k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">]</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
    <span class="n">result_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">categoricalSummary</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">top_k</span><span class="p">),</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">threshold</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CategoricalSummaryOutputList</span><span class="p">([</span><span class="n">CategoricalSummaryOutput</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">])</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.collect">
    <p>def <span class="ident">collect</span>(</p><p>self, columns=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Brings all the rows of data from the frame into a local python list of lists</p>
<p>(Use the 'take' operation for control over row count and offset of the collected data)</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(Optional[str or List[str]):</td><td class='param-desc'>If not None, only the given columns' data will be provided.
                By default, all columns are included.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(List[List[*]]): </td><td class='param-desc'>the frame data represented as a list of lists</td></tr></table></p>

<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; schema = [(&#39;name&#39;,str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)]
&gt;&gt;&gt; rows = [[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;], [&#39;Thurston&#39;, 65, 26, &#39;555-4510&#39;], [&#39;Judy&#39;, 44, 14, &#39;555-2183&#39;]]
&gt;&gt;&gt; frame = tc.frame.create(rows, schema)
&gt;&gt;&gt; frame.collect()
[[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;], [&#39;Thurston&#39;, 65, 26, &#39;555-4510&#39;], [&#39;Judy&#39;, 44, 14, &#39;555-2183&#39;]]

&gt;&gt;&gt; frame.collect([&#39;name&#39;, &#39;phone&#39;])
[[&#39;Fred&#39;, &#39;555-1234&#39;], [&#39;Susan&#39;, &#39;555-0202&#39;], [&#39;Thurston&#39;, &#39;555-4510&#39;], [&#39;Judy&#39;, &#39;555-2183&#39;]]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.collect', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.collect" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Brings all the rows of data from the frame into a local python list of lists</span>

<span class="sd">    (Use the &#39;take&#39; operation for control over row count and offset of the collected data)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (Optional[str or List[str]) If not None, only the given columns&#39; data will be provided.</span>
<span class="sd">                    By default, all columns are included.</span>
<span class="sd">    :return: (List[List[*]]) the frame data represented as a list of lists</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; schema = [(&#39;name&#39;,str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)]</span>
<span class="sd">        &gt;&gt;&gt; rows = [[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;], [&#39;Thurston&#39;, 65, 26, &#39;555-4510&#39;], [&#39;Judy&#39;, 44, 14, &#39;555-2183&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create(rows, schema)</span>
<span class="sd">        &gt;&gt;&gt; frame.collect()</span>
<span class="sd">        [[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;], [&#39;Thurston&#39;, 65, 26, &#39;555-4510&#39;], [&#39;Judy&#39;, 44, 14, &#39;555-2183&#39;]]</span>

<span class="sd">        &gt;&gt;&gt; frame.collect([&#39;name&#39;, &#39;phone&#39;])</span>
<span class="sd">        [[&#39;Fred&#39;, &#39;555-1234&#39;], [&#39;Susan&#39;, &#39;555-0202&#39;], [&#39;Thurston&#39;, &#39;555-4510&#39;], [&#39;Judy&#39;, &#39;555-2183&#39;]]</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">affirm_type</span><span class="o">.</span><span class="n">list_of_str</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s">&quot;columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
        <span class="n">scala_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option_list_string</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">get_schema_for_columns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span> <span class="k">if</span> <span class="n">columns</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">TakeCollectHelper</span><span class="o">.</span><span class="n">scala_rows_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="n">scala_data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">TakeCollectHelper</span><span class="o">.</span><span class="n">get_select_columns_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">select</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.column_median">
    <p>def <span class="ident">column_median</span>(</p><p>self, data_column, weights_column=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the (weighted) median of a column.</p>
<p>The median is the least value X in the range of the distribution so that
the cumulative weight of values strictly below X is strictly less than half
of the total weight and the cumulative weight of values up to and including X
is greater than or equal to one-half of the total weight.</p>
<p>All data elements of weight less than or equal to 0 are excluded from the
calculation, as are all data elements whose weight is NaN or infinite.
If a weight column is provided and no weights are finite numbers greater
than 0, None is returned.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column</td><td class='param-type'>(str):</td><td class='param-desc'>The column whose median is to be calculated.
</td></tr></table>

<table><tr><td class='param-name'>weights_column</td><td class='param-type'>(Option[str]):</td><td class='param-desc'>The column that provides weights (frequencies) for the median calculation.
                       Must contain numerical data.
                       Default is all items have a weight of 1.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(varies): </td><td class='param-desc'>The median of the values.
         If a weight column is provided and no weights are finite numbers greater
         than 0, None is returned.
         The type of the median returned is the same as the contents of the data
         column, so a column of Longs will result in a Long median and a column of
         Floats will result in a Float median.</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Given a frame with column 'a' accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a
=======
[0]   2
[1]   3
[2]   3
[3]   5
[4]   7
[5]  10
[6]  30
</pre></div>


<p>Compute and return middle number of values in column <em>a</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; median = my_frame.column_median(&#39;a&#39;)
[===Job Progress===]
&gt;&gt;&gt; print median
5
</pre></div>


<p>Given a frame with column 'a' and column 'w' as weights accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a   w
============
[0]   2  1.7
[1]   3  0.5
[2]   3  1.2
[3]   5  0.8
[4]   7  1.1
[5]  10  0.8
[6]  30  0.1
</pre></div>


<p>Compute and return middle number of values in column 'a' with weights 'w':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; median = my_frame.column_median(&#39;a&#39;, weights_column=&#39;w&#39;)
[===Job Progress===]
&gt;&gt;&gt; print median
3
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.column_median', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.column_median" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">column_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column</span><span class="p">,</span> <span class="n">weights_column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the (weighted) median of a column.</span>

<span class="sd">    The median is the least value X in the range of the distribution so that</span>
<span class="sd">    the cumulative weight of values strictly below X is strictly less than half</span>
<span class="sd">    of the total weight and the cumulative weight of values up to and including X</span>
<span class="sd">    is greater than or equal to one-half of the total weight.</span>

<span class="sd">    All data elements of weight less than or equal to 0 are excluded from the</span>
<span class="sd">    calculation, as are all data elements whose weight is NaN or infinite.</span>
<span class="sd">    If a weight column is provided and no weights are finite numbers greater</span>
<span class="sd">    than 0, None is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column: (str) The column whose median is to be calculated.</span>
<span class="sd">    :param weights_column: (Option[str]) The column that provides weights (frequencies) for the median calculation.</span>
<span class="sd">                           Must contain numerical data.</span>
<span class="sd">                           Default is all items have a weight of 1.</span>
<span class="sd">    :return: (varies) The median of the values.</span>
<span class="sd">             If a weight column is provided and no weights are finite numbers greater</span>
<span class="sd">             than 0, None is returned.</span>
<span class="sd">             The type of the median returned is the same as the contents of the data</span>
<span class="sd">             column, so a column of Longs will result in a Long median and a column of</span>
<span class="sd">             Floats will result in a Float median.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given a frame with column &#39;a&#39; accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a</span>
<span class="sd">        =======</span>
<span class="sd">        [0]   2</span>
<span class="sd">        [1]   3</span>
<span class="sd">        [2]   3</span>
<span class="sd">        [3]   5</span>
<span class="sd">        [4]   7</span>
<span class="sd">        [5]  10</span>
<span class="sd">        [6]  30</span>

<span class="sd">    Compute and return middle number of values in column *a*:</span>

<span class="sd">        &gt;&gt;&gt; median = my_frame.column_median(&#39;a&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print median</span>
<span class="sd">        5</span>

<span class="sd">    Given a frame with column &#39;a&#39; and column &#39;w&#39; as weights accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a   w</span>
<span class="sd">        ============</span>
<span class="sd">        [0]   2  1.7</span>
<span class="sd">        [1]   3  0.5</span>
<span class="sd">        [2]   3  1.2</span>
<span class="sd">        [3]   5  0.8</span>
<span class="sd">        [4]   7  1.1</span>
<span class="sd">        [5]  10  0.8</span>
<span class="sd">        [6]  30  0.1</span>

<span class="sd">    Compute and return middle number of values in column &#39;a&#39; with weights &#39;w&#39;:</span>

<span class="sd">        &gt;&gt;&gt; median = my_frame.column_median(&#39;a&#39;, weights_column=&#39;w&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print median</span>
<span class="sd">        3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">columnMedian</span><span class="p">(</span><span class="n">data_column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weights_column</span><span class="p">))</span>
    <span class="n">optional_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_scala_option</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">optional_val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">optional_val</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.column_mode">
    <p>def <span class="ident">column_mode</span>(</p><p>self, data_column, weights_column=None, max_modes_returned=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluate the weights assigned to rows.</p>
<p>Calculate the modes of a column.
A mode is a data element of maximum weight.
All data elements of weight less than or equal to 0 are excluded from the
calculation, as are all data elements whose weight is NaN or infinite.
If there are no data elements of finite weight greater than 0,
no mode is returned.</p>
<p>Because data distributions often have multiple modes, it is possible for a
set of modes to be returned.
By default, only one is returned, but by setting the optional parameter
max_modes_returned, a larger number of modes can be returned.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column supplying the data.
</td></tr></table>

<table><tr><td class='param-name'>weights_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>Name of the column supplying the weights.
                       Default is all items have weight of 1.
</td></tr></table>

<table><tr><td class='param-name'>max_modes_returned</td><td class='param-type'>(Option[int]):</td><td class='param-desc'>Maximum number of modes returned. Default is 1.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(ColumnMode): </td><td class='param-desc'>ColumnMode object which includes multiple components (mode, weight_of_mode, total_weight,
                      and mode_count).</td></tr></table></p>

<p>The data returned is composed of multiple components\:</p>
<p>mode : A mode is a data element of maximum net weight.
    A set of modes is returned.
    The empty set is returned when the sum of the weights is 0.
    If the number of modes is less than or equal to the parameter
    max_modes_returned, then all modes of the data are
    returned.
    If the number of modes is greater than the max_modes_returned
    parameter, only the first max_modes_returned many modes (per a
    canonical ordering) are returned.
weight_of_mode : Weight of a mode.
    If there are no data elements of finite weight greater than 0,
    the weight of the mode is 0.
    If no weights column is given, this is the number of appearances
    of each mode.
total_weight : Sum of all weights in the weight column.
    This is the row count if no weights are given.
    If no weights column is given, this is the number of rows in
    the table with non-zero weight.
mode_count : The number of distinct modes in the data.
    In the case that the data is very multimodal, this number may
    exceed max_modes_returned.</p>
<div class='section-header'>Examples:</div>

<p>Given a frame with column 'a' accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a
=======
[0]   2
[1]   3
[2]   3
[3]   5
[4]   7
[5]  10
[6]  30
</pre></div>


<p>Compute and return a ColumnMode object containing summary statistics of column <em>a</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; mode = my_frame.column_mode(&#39;a&#39;)
[===Job Progress===]
&gt;&gt;&gt; print mode
mode_count     = 1
modes          = [3]
total_weight   = 7.0
weight_of_mode = 2.0
</pre></div>


<p>Given a frame with column 'a' and column 'w' as weights accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a   w
============
[0]   2  1.7
[1]   3  0.5
[2]   3  1.2
[3]   5  0.8
[4]   7  1.1
[5]  10  0.8
[6]  30  0.1
</pre></div>


<p>Compute and return ColumnMode object containing summary statistics of column 'a' with weights 'w':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; mode = my_frame.column_mode(&#39;a&#39;, weights_column=&#39;w&#39;)
[===Job Progress===]
&gt;&gt;&gt; print mode
mode_count     = 2
modes          = [2]
total_weight   = 6.2
weight_of_mode = 1.7
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.column_mode', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.column_mode" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">column_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column</span><span class="p">,</span> <span class="n">weights_column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_modes_returned</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the weights assigned to rows.</span>

<span class="sd">    Calculate the modes of a column.</span>
<span class="sd">    A mode is a data element of maximum weight.</span>
<span class="sd">    All data elements of weight less than or equal to 0 are excluded from the</span>
<span class="sd">    calculation, as are all data elements whose weight is NaN or infinite.</span>
<span class="sd">    If there are no data elements of finite weight greater than 0,</span>
<span class="sd">    no mode is returned.</span>

<span class="sd">    Because data distributions often have multiple modes, it is possible for a</span>
<span class="sd">    set of modes to be returned.</span>
<span class="sd">    By default, only one is returned, but by setting the optional parameter</span>
<span class="sd">    max_modes_returned, a larger number of modes can be returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column: (str) Name of the column supplying the data.</span>
<span class="sd">    :param weights_column: (Optional[str]) Name of the column supplying the weights.</span>
<span class="sd">                           Default is all items have weight of 1.</span>
<span class="sd">    :param max_modes_returned: (Option[int]) Maximum number of modes returned. Default is 1.</span>
<span class="sd">    :return: (ColumnMode) ColumnMode object which includes multiple components (mode, weight_of_mode, total_weight,</span>
<span class="sd">                          and mode_count).</span>

<span class="sd">    The data returned is composed of multiple components\:</span>

<span class="sd">    mode : A mode is a data element of maximum net weight.</span>
<span class="sd">        A set of modes is returned.</span>
<span class="sd">        The empty set is returned when the sum of the weights is 0.</span>
<span class="sd">        If the number of modes is less than or equal to the parameter</span>
<span class="sd">        max_modes_returned, then all modes of the data are</span>
<span class="sd">        returned.</span>
<span class="sd">        If the number of modes is greater than the max_modes_returned</span>
<span class="sd">        parameter, only the first max_modes_returned many modes (per a</span>
<span class="sd">        canonical ordering) are returned.</span>
<span class="sd">    weight_of_mode : Weight of a mode.</span>
<span class="sd">        If there are no data elements of finite weight greater than 0,</span>
<span class="sd">        the weight of the mode is 0.</span>
<span class="sd">        If no weights column is given, this is the number of appearances</span>
<span class="sd">        of each mode.</span>
<span class="sd">    total_weight : Sum of all weights in the weight column.</span>
<span class="sd">        This is the row count if no weights are given.</span>
<span class="sd">        If no weights column is given, this is the number of rows in</span>
<span class="sd">        the table with non-zero weight.</span>
<span class="sd">    mode_count : The number of distinct modes in the data.</span>
<span class="sd">        In the case that the data is very multimodal, this number may</span>
<span class="sd">        exceed max_modes_returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given a frame with column &#39;a&#39; accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a</span>
<span class="sd">        =======</span>
<span class="sd">        [0]   2</span>
<span class="sd">        [1]   3</span>
<span class="sd">        [2]   3</span>
<span class="sd">        [3]   5</span>
<span class="sd">        [4]   7</span>
<span class="sd">        [5]  10</span>
<span class="sd">        [6]  30</span>

<span class="sd">    Compute and return a ColumnMode object containing summary statistics of column *a*:</span>

<span class="sd">        &gt;&gt;&gt; mode = my_frame.column_mode(&#39;a&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print mode</span>
<span class="sd">        mode_count     = 1</span>
<span class="sd">        modes          = [3]</span>
<span class="sd">        total_weight   = 7.0</span>
<span class="sd">        weight_of_mode = 2.0</span>

<span class="sd">    Given a frame with column &#39;a&#39; and column &#39;w&#39; as weights accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a   w</span>
<span class="sd">        ============</span>
<span class="sd">        [0]   2  1.7</span>
<span class="sd">        [1]   3  0.5</span>
<span class="sd">        [2]   3  1.2</span>
<span class="sd">        [3]   5  0.8</span>
<span class="sd">        [4]   7  1.1</span>
<span class="sd">        [5]  10  0.8</span>
<span class="sd">        [6]  30  0.1</span>

<span class="sd">    Compute and return ColumnMode object containing summary statistics of column &#39;a&#39; with weights &#39;w&#39;:</span>

<span class="sd">        &gt;&gt;&gt; mode = my_frame.column_mode(&#39;a&#39;, weights_column=&#39;w&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print mode</span>
<span class="sd">        mode_count     = 2</span>
<span class="sd">        modes          = [2]</span>
<span class="sd">        total_weight   = 6.2</span>
<span class="sd">        weight_of_mode = 1.7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ColumnMode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">columnMode</span><span class="p">(</span><span class="n">data_column</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weights_column</span><span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">max_modes_returned</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.column_summary_statistics">
    <p>def <span class="ident">column_summary_statistics</span>(</p><p>self, data_column, weights_column=None, use_popultion_variance=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate multiple statistics for a column.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column</td><td class='param-type'>(str):</td><td class='param-desc'>The column to be statistically summarized.
                    Must contain numerical data; all NaNs and infinite values are excluded from the calculation.
</td></tr></table>

<table><tr><td class='param-name'>weights_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>Name of column holding weights of column values.
</td></tr></table>

<table><tr><td class='param-name'>use_popultion_variance</td><td class='param-type'>(Optional[bool]):</td><td class='param-desc'>If true, the variance is calculated as the population variance.
                               If false, the variance calculated as the sample variance.
                               Because this option affects the variance, it affects the standard deviation and
                               the confidence intervals as well.
                               Default is false.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(ColumnSummaryStatistics): </td><td class='param-desc'>ColumnSummaryStatistics object containing summary statistics.</td></tr></table></p>

<p>The data returned is composed of multiple components:</p>
<ul>
<li>mean : [ double | None ]<br>
    Arithmetic mean of the data.</li>
<li>geometric_mean : [ double | None ]<br>
    Geometric mean of the data. None when there is a data element &lt;= 0, 1.0 when there are no data elements.</li>
<li>variance : [ double | None ]<br>
    None when there are &lt;= 1 many data elements. Sample variance is the weighted sum of the squared distance of each data element from the weighted mean, divided by the total weight minus 1. None when the sum of the weights is &lt;= 1. Population variance is the weighted sum of the squared distance of each data element from the weighted mean, divided by the total weight.</li>
<li>standard_deviation : [ double | None ]<br>
    The square root of the variance. None when  sample variance is being used and the sum of weights is &lt;= 1.</li>
<li>total_weight : long<br>
    The count of all data elements that are finite numbers. In other words, after excluding NaNs and infinite values.</li>
<li>minimum : [ double | None ]<br>
    Minimum value in the data. None when there are no data elements.</li>
<li>maximum : [ double | None ]<br>
    Maximum value in the data. None when there are no data elements.</li>
<li>mean_confidence_lower : [ double | None ]<br>
    Lower limit of the 95% confidence interval about the mean. Assumes a Gaussian distribution. None when there are no elements of positive weight.</li>
<li>mean_confidence_upper : [ double | None ]<br>
    Upper limit of the 95% confidence interval about the mean. Assumes a Gaussian distribution. None when there are no elements of positive weight.</li>
<li>bad_row_count : [ double | None ]<br>
    The number of rows containing a NaN or infinite value in either the data or weights column.</li>
<li>good_row_count : [ double | None ]<br>
    The number of rows not containing a NaN or infinite value in either the data or weights column.</li>
<li>positive_weight_count : [ double | None ]<br>
    The number of valid data elements with weight &gt; 0. This is the number of entries used in the statistical calculation.</li>
<li>non_positive_weight_count : [ double | None ]<br>
    The number valid data elements with finite weight &lt;= 0.</li>
</ul>
<div class='section-header'>Notes:</div>

<ul>
<li>
<p>Sample Variance<br>
    Sample Variance is computed by the following formula:</p>
<p>.. math::</p>
<div class="codehilite"><pre>\left( rac{1}{W - 1}
</pre></div>


<p>ight) * sum_{i}             \left(x_{i} - M 
ight) ^{2}</p>
<p>where :math:<code>W</code> is sum of weights over valid elements of positive
weight, and :math:<code>M</code> is the weighted mean.</p>
</li>
<li>
<p>Population Variance<br>
    Population Variance is computed by the following formula:</p>
<p>.. math::</p>
<div class="codehilite"><pre>\left( rac{1}{W}
</pre></div>


<p>ight) * sum_{i}             \left(x_{i} - M 
ight) ^{2}</p>
<p>where :math:<code>W</code> is sum of weights over valid elements of positive
weight, and :math:<code>M</code> is the weighted mean.</p>
</li>
<li>
<p>Standard Deviation<br>
    The square root of the variance.</p>
</li>
<li>
<p>Logging Invalid Data<br>
    A row is bad when it contains a NaN or infinite value in either
    its data or weights column.
    In this case, it contributes to bad_row_count; otherwise it
    contributes to good row count.</p>
<p>A good row can be skipped because the value in its weight
column is less than or equal to 0.
In this case, it contributes to non_positive_weight_count, otherwise
(when the weight is greater than 0) it contributes to
valid_data_weight_pair_count.</p>
</li>
</ul>
<p><strong>Equations</strong></p>
<div class="codehilite"><pre>bad_row_count + good_row_count = # rows in the frame
positive_weight_count + non_positive_weight_count = good_row_count
</pre></div>


<p>In particular, when no weights column is provided and all weights are 1.0:</p>
<div class="codehilite"><pre>non_positive_weight_count = 0 and
positive_weight_count = good_row_count
</pre></div>


<div class='section-header'>Examples:</div>

<p>Given a frame with column 'a' accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a
=======
[0]   2
[1]   3
[2]   3
[3]   5
[4]   7
[5]  10
[6]  30
</pre></div>


<p>Compute and return summary statistics for values in column <em>a</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; summary_statistics = my_frame.column_summary_statistics(&#39;a&#39;)
[===Job Progress===]
&gt;&gt;&gt; print summary_statistics
bad_row_count             = 0
geometric_mean            = 5.67257514519
good_row_count            = 7
maximum                   = 30.0
mean                      = 8.57142857143
mean_confidence_lower     = 1.27708372993
mean_confidence_upper     = 15.8657734129
minimum                   = 2.0
non_positive_weight_count = 0
positive_weight_count     = 7
standard_deviation        = 9.84644001416
total_weight              = 7.0
variance                  = 96.9523809524
</pre></div>


<p>Given a frame with column 'a' and column 'w' as weights accessed by a Frame object 'my_frame':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Inspect my_frame</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  a   w
============
[0]   2  1.7
[1]   3  0.5
[2]   3  1.2
[3]   5  0.8
[4]   7  1.1
[5]  10  0.8
[6]  30  0.1
</pre></div>


<p>Compute and return summary statistics values in column 'a' with weights 'w':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; summary_statistics = my_frame.column_summary_statistics(&#39;a&#39;, weights_column=&#39;w&#39;)
[===Job Progress===]
&gt;&gt;&gt; print summary_statistics
bad_row_count             = 0
geometric_mean            = 4.03968288152
good_row_count            = 7
maximum                   = 30.0
mean                      = 5.03225806452
mean_confidence_lower     = 1.42847242276
mean_confidence_upper     = 8.63604370627
minimum                   = 2.0
non_positive_weight_count = 0
positive_weight_count     = 7
standard_deviation        = 4.57824177679
total_weight              = 6.2
variance                  = 20.9602977667
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.column_summary_statistics', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.column_summary_statistics" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">column_summary_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column</span><span class="p">,</span> <span class="n">weights_column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">use_popultion_variance</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate multiple statistics for a column.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column: (str) The column to be statistically summarized.</span>
<span class="sd">                        Must contain numerical data; all NaNs and infinite values are excluded from the calculation.</span>
<span class="sd">    :param weights_column: (Optional[str]) Name of column holding weights of column values.</span>
<span class="sd">    :param use_popultion_variance: (Optional[bool]) If true, the variance is calculated as the population variance.</span>
<span class="sd">                                   If false, the variance calculated as the sample variance.</span>
<span class="sd">                                   Because this option affects the variance, it affects the standard deviation and</span>
<span class="sd">                                   the confidence intervals as well.</span>
<span class="sd">                                   Default is false.</span>
<span class="sd">    :return: (ColumnSummaryStatistics) ColumnSummaryStatistics object containing summary statistics.</span>

<span class="sd">    The data returned is composed of multiple components:</span>

<span class="sd">    * mean : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Arithmetic mean of the data.</span>
<span class="sd">    * geometric_mean : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Geometric mean of the data. None when there is a data element &lt;= 0, 1.0 when there are no data elements.</span>
<span class="sd">    * variance : [ double | None ]&lt;br&gt;</span>
<span class="sd">        None when there are &lt;= 1 many data elements. Sample variance is the weighted sum of the squared distance of each data element from the weighted mean, divided by the total weight minus 1. None when the sum of the weights is &lt;= 1. Population variance is the weighted sum of the squared distance of each data element from the weighted mean, divided by the total weight.</span>
<span class="sd">    * standard_deviation : [ double | None ]&lt;br&gt;</span>
<span class="sd">        The square root of the variance. None when  sample variance is being used and the sum of weights is &lt;= 1.</span>
<span class="sd">    * total_weight : long&lt;br&gt;</span>
<span class="sd">        The count of all data elements that are finite numbers. In other words, after excluding NaNs and infinite values.</span>
<span class="sd">    * minimum : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Minimum value in the data. None when there are no data elements.</span>
<span class="sd">    * maximum : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Maximum value in the data. None when there are no data elements.</span>
<span class="sd">    * mean_confidence_lower : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Lower limit of the 95% confidence interval about the mean. Assumes a Gaussian distribution. None when there are no elements of positive weight.</span>
<span class="sd">    * mean_confidence_upper : [ double | None ]&lt;br&gt;</span>
<span class="sd">        Upper limit of the 95% confidence interval about the mean. Assumes a Gaussian distribution. None when there are no elements of positive weight.</span>
<span class="sd">    * bad_row_count : [ double | None ]&lt;br&gt;</span>
<span class="sd">        The number of rows containing a NaN or infinite value in either the data or weights column.</span>
<span class="sd">    * good_row_count : [ double | None ]&lt;br&gt;</span>
<span class="sd">        The number of rows not containing a NaN or infinite value in either the data or weights column.</span>
<span class="sd">    * positive_weight_count : [ double | None ]&lt;br&gt;</span>
<span class="sd">        The number of valid data elements with weight &gt; 0. This is the number of entries used in the statistical calculation.</span>
<span class="sd">    * non_positive_weight_count : [ double | None ]&lt;br&gt;</span>
<span class="sd">        The number valid data elements with finite weight &lt;= 0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    * Sample Variance&lt;br&gt;</span>
<span class="sd">        Sample Variance is computed by the following formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \left( \frac{1}{W - 1} \right) * sum_{i} \</span>
<span class="sd">            \left(x_{i} - M \right) ^{2}</span>

<span class="sd">        where :math:`W` is sum of weights over valid elements of positive</span>
<span class="sd">        weight, and :math:`M` is the weighted mean.</span>

<span class="sd">    * Population Variance&lt;br&gt;</span>
<span class="sd">        Population Variance is computed by the following formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \left( \frac{1}{W} \right) * sum_{i} \</span>
<span class="sd">            \left(x_{i} - M \right) ^{2}</span>

<span class="sd">        where :math:`W` is sum of weights over valid elements of positive</span>
<span class="sd">        weight, and :math:`M` is the weighted mean.</span>

<span class="sd">    * Standard Deviation&lt;br&gt;</span>
<span class="sd">        The square root of the variance.</span>

<span class="sd">    * Logging Invalid Data&lt;br&gt;</span>
<span class="sd">        A row is bad when it contains a NaN or infinite value in either</span>
<span class="sd">        its data or weights column.</span>
<span class="sd">        In this case, it contributes to bad_row_count; otherwise it</span>
<span class="sd">        contributes to good row count.</span>

<span class="sd">        A good row can be skipped because the value in its weight</span>
<span class="sd">        column is less than or equal to 0.</span>
<span class="sd">        In this case, it contributes to non_positive_weight_count, otherwise</span>
<span class="sd">        (when the weight is greater than 0) it contributes to</span>
<span class="sd">        valid_data_weight_pair_count.</span>

<span class="sd">    **Equations**</span>

<span class="sd">        bad_row_count + good_row_count = # rows in the frame</span>
<span class="sd">        positive_weight_count + non_positive_weight_count = good_row_count</span>

<span class="sd">    In particular, when no weights column is provided and all weights are 1.0:</span>

<span class="sd">        non_positive_weight_count = 0 and</span>
<span class="sd">        positive_weight_count = good_row_count</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given a frame with column &#39;a&#39; accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2],[3],[3],[5],[7],[10],[30]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a</span>
<span class="sd">        =======</span>
<span class="sd">        [0]   2</span>
<span class="sd">        [1]   3</span>
<span class="sd">        [2]   3</span>
<span class="sd">        [3]   5</span>
<span class="sd">        [4]   7</span>
<span class="sd">        [5]  10</span>
<span class="sd">        [6]  30</span>

<span class="sd">    Compute and return summary statistics for values in column *a*:</span>

<span class="sd">        &gt;&gt;&gt; summary_statistics = my_frame.column_summary_statistics(&#39;a&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print summary_statistics</span>
<span class="sd">        bad_row_count             = 0</span>
<span class="sd">        geometric_mean            = 5.67257514519</span>
<span class="sd">        good_row_count            = 7</span>
<span class="sd">        maximum                   = 30.0</span>
<span class="sd">        mean                      = 8.57142857143</span>
<span class="sd">        mean_confidence_lower     = 1.27708372993</span>
<span class="sd">        mean_confidence_upper     = 15.8657734129</span>
<span class="sd">        minimum                   = 2.0</span>
<span class="sd">        non_positive_weight_count = 0</span>
<span class="sd">        positive_weight_count     = 7</span>
<span class="sd">        standard_deviation        = 9.84644001416</span>
<span class="sd">        total_weight              = 7.0</span>
<span class="sd">        variance                  = 96.9523809524</span>

<span class="sd">    Given a frame with column &#39;a&#39; and column &#39;w&#39; as weights accessed by a Frame object &#39;my_frame&#39;:</span>

<span class="sd">        &gt;&gt;&gt; data = [[2,1.7],[3,0.5],[3,1.2],[5,0.8],[7,1.1],[10,0.8],[30,0.1]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;w&#39;, float)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Inspect my_frame</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a   w</span>
<span class="sd">        ============</span>
<span class="sd">        [0]   2  1.7</span>
<span class="sd">        [1]   3  0.5</span>
<span class="sd">        [2]   3  1.2</span>
<span class="sd">        [3]   5  0.8</span>
<span class="sd">        [4]   7  1.1</span>
<span class="sd">        [5]  10  0.8</span>
<span class="sd">        [6]  30  0.1</span>

<span class="sd">    Compute and return summary statistics values in column &#39;a&#39; with weights &#39;w&#39;:</span>

<span class="sd">        &gt;&gt;&gt; summary_statistics = my_frame.column_summary_statistics(&#39;a&#39;, weights_column=&#39;w&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; print summary_statistics</span>
<span class="sd">        bad_row_count             = 0</span>
<span class="sd">        geometric_mean            = 4.03968288152</span>
<span class="sd">        good_row_count            = 7</span>
<span class="sd">        maximum                   = 30.0</span>
<span class="sd">        mean                      = 5.03225806452</span>
<span class="sd">        mean_confidence_lower     = 1.42847242276</span>
<span class="sd">        mean_confidence_upper     = 8.63604370627</span>
<span class="sd">        minimum                   = 2.0</span>
<span class="sd">        non_positive_weight_count = 0</span>
<span class="sd">        positive_weight_count     = 7</span>
<span class="sd">        standard_deviation        = 4.57824177679</span>
<span class="sd">        total_weight              = 6.2</span>
<span class="sd">        variance                  = 20.9602977667</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ColumnSummaryStatistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">columnSummaryStatistics</span><span class="p">(</span><span class="n">data_column</span><span class="p">,</span>
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weights_column</span><span class="p">),</span>
                                                                       <span class="n">use_popultion_variance</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.copy">
    <p>def <span class="ident">copy</span>(</p><p>self, columns=None, where=None)</p>
    </div>
    

    
  
    <div class="desc"><p>New frame with copied columns.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(str, List[str], or dictionary(str,str)):</td><td class='param-desc'> If not None, the copy will only include the
                columns specified.  If dict, the string pairs represent a column renaming
                { source_column_name : destination_column_name }
</td></tr></table>

<table><tr><td class='param-name'>where</td><td class='param-type'>(UDF):</td><td class='param-desc'>Optionally provide a where function.  If not None, only those rows for which the UDF
              evaluates to True will be copied.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>New Frame object.</td></tr></table></p>

<p>Copies specified columns into a new Frame object, optionally renaming them and/or filtering them.
Useful for frame query.</p>
<div class='section-header'>Examples:</div>

<p>Consider the following frame of employee names, age, and years of service:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  name      age  years
=========================
[0]  Thurston   64     26
[1]  Judy       44     14
[2]  Emily      37      5
[3]  Frank      50     18
[4]  Joe        43     11
[5]  Ruth       52     21

&gt;&gt;&gt; frame.schema
[(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;age&#39;, &lt;type &#39;int&#39;&gt;), (&#39;years&#39;, &lt;type &#39;int&#39;&gt;)]
</pre></div>


<p>To create a duplicate copy of the frame, use the copy operation with no parameters:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; duplicate = frame.copy()
[===Job Progress===]

&gt;&gt;&gt; duplicate.inspect()
[#]  name      age  years
=========================
[0]  Thurston   64     26
[1]  Judy       44     14
[2]  Emily      37      5
[3]  Frank      50     18
[4]  Joe        43     11
[5]  Ruth       52     21
</pre></div>


<p>Using the copy operation, we can also limit the new frame to just include the 'name' column:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; names = frame.copy(&quot;name&quot;)
[===Job Progress===]

&gt;&gt;&gt; names.inspect()
[#]  name
=============
[0]  Thurston
[1]  Judy
[2]  Emily
[3]  Frank
[4]  Joe
[5]  Ruth
</pre></div>


<p>We could also include a UDF to filter the data that is included in the new frame, and also provide
a dictionary to rename the column(s) in the new frame.  Here we will use copy to create a frame of
names for the employees that have over 20 years of service and also rename of the 'name' column to
'first_name':</p>
<div class="codehilite"><pre>&gt;&gt;&gt; names = frame.copy({&quot;name&quot; : &quot;first_name&quot;}, lambda row: row.years &gt; 20)
[===Job Progress===]

&gt;&gt;&gt; names.inspect()
[#]  first_name
===============
[0]  Thurston
[1]  Ruth
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.copy', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.copy" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    New frame with copied columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (str, List[str], or dictionary(str,str))  If not None, the copy will only include the</span>
<span class="sd">                    columns specified.  If dict, the string pairs represent a column renaming</span>
<span class="sd">                    { source_column_name : destination_column_name }</span>
<span class="sd">    :param where: (UDF) Optionally provide a where function.  If not None, only those rows for which the UDF</span>
<span class="sd">                  evaluates to True will be copied.</span>
<span class="sd">    :return: (Frame) New Frame object.</span>

<span class="sd">    Copies specified columns into a new Frame object, optionally renaming them and/or filtering them.</span>
<span class="sd">    Useful for frame query.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider the following frame of employee names, age, and years of service:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  years</span>
<span class="sd">        =========================</span>
<span class="sd">        [0]  Thurston   64     26</span>
<span class="sd">        [1]  Judy       44     14</span>
<span class="sd">        [2]  Emily      37      5</span>
<span class="sd">        [3]  Frank      50     18</span>
<span class="sd">        [4]  Joe        43     11</span>
<span class="sd">        [5]  Ruth       52     21</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;age&#39;, &lt;type &#39;int&#39;&gt;), (&#39;years&#39;, &lt;type &#39;int&#39;&gt;)]</span>

<span class="sd">    To create a duplicate copy of the frame, use the copy operation with no parameters:</span>

<span class="sd">        &gt;&gt;&gt; duplicate = frame.copy()</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; duplicate.inspect()</span>
<span class="sd">        [#]  name      age  years</span>
<span class="sd">        =========================</span>
<span class="sd">        [0]  Thurston   64     26</span>
<span class="sd">        [1]  Judy       44     14</span>
<span class="sd">        [2]  Emily      37      5</span>
<span class="sd">        [3]  Frank      50     18</span>
<span class="sd">        [4]  Joe        43     11</span>
<span class="sd">        [5]  Ruth       52     21</span>

<span class="sd">    Using the copy operation, we can also limit the new frame to just include the &#39;name&#39; column:</span>

<span class="sd">        &gt;&gt;&gt; names = frame.copy(&quot;name&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; names.inspect()</span>
<span class="sd">        [#]  name</span>
<span class="sd">        =============</span>
<span class="sd">        [0]  Thurston</span>
<span class="sd">        [1]  Judy</span>
<span class="sd">        [2]  Emily</span>
<span class="sd">        [3]  Frank</span>
<span class="sd">        [4]  Joe</span>
<span class="sd">        [5]  Ruth</span>

<span class="sd">    We could also include a UDF to filter the data that is included in the new frame, and also provide</span>
<span class="sd">    a dictionary to rename the column(s) in the new frame.  Here we will use copy to create a frame of</span>
<span class="sd">    names for the employees that have over 20 years of service and also rename of the &#39;name&#39; column to</span>
<span class="sd">    &#39;first_name&#39;:</span>

<span class="sd">        &gt;&gt;&gt; names = frame.copy({&quot;name&quot; : &quot;first_name&quot;}, lambda row: row.years &gt; 20)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; names.inspect()</span>
<span class="sd">        [#]  first_name</span>
<span class="sd">        ===============</span>
<span class="sd">        [0]  Thurston</span>
<span class="sd">        [1]  Ruth</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span>

    <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported type for &#39;where&#39; parameter.  Must be a function or None, but is: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">where</span><span class="p">)))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span> <span class="k">if</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span> <span class="k">if</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">columns</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported type for &#39;columns&#39; parameter. Expected str, list, dict, or None, but was: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">columns</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># If a udf is provided, apply that function and apply the new schema</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">copy_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">new_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">copy_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">):</span>
        <span class="c"># Map rows to only include the specified columns</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">map_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">column_indices</span><span class="p">)</span>
        <span class="n">new_rdd</span> <span class="o">=</span> <span class="n">new_rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">map_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="n">new_schema</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">column_indices</span><span class="p">)</span>

    <span class="c"># If columns are being renamed through a dictionary, alter the schema</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="n">renamed_schema</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">new_schema</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">columns</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">renamed_schema</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_name</span><span class="p">,</span> <span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">new_schema</span> <span class="o">=</span> <span class="n">renamed_schema</span>

    <span class="c"># return new frame with the filtered rdd and new schema</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">new_rdd</span><span class="p">,</span> <span class="n">new_schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.correlation">
    <p>def <span class="ident">correlation</span>(</p><p>self, column_a, column_b)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate correlation for two columns of current frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_a</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the correlation.
</td></tr></table>

<table><tr><td class='param-name'>column_b</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the correlation.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(float): </td><td class='param-desc'>Pearson correlation coefficient of the two columns.</td></tr></table></p>

<div class='section-header'>Notes:</div>

<p>This method applies only to columns containing numerical data.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  idnum  x1   x2   x3   x4
===============================
[0]      0  1.0  4.0  0.0  -1.0
[1]      1  2.0  3.0  0.0  -1.0
[2]      2  3.0  2.0  1.0  -1.0
[3]      3  4.0  1.0  2.0  -1.0
[4]      4  5.0  0.0  2.0  -1.0
</pre></div>


<p>my_frame.correlation computes the common correlation coefficient (Pearson's) on the pair
of columns provided.
In this example, the <em>idnum</em> and most of the columns have trivial correlations: -1, 0, or +1.
Column <em>x3</em> provides a contrasting coefficient of 3 / sqrt(3) = 0.948683298051 .</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.correlation(&quot;x1&quot;, &quot;x2&quot;)
-0.9999999999999998

&gt;&gt;&gt; my_frame.correlation(&quot;x1&quot;, &quot;x4&quot;)
nan

&gt;&gt;&gt; my_frame.correlation(&quot;x2&quot;, &quot;x3&quot;)
-0.9486832980505138
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.correlation', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.correlation" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate correlation for two columns of current frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_a: (str) The name of the column from which to compute the correlation.</span>
<span class="sd">    :param column_b: (str) The name of the column from which to compute the correlation.</span>
<span class="sd">    :return: (float) Pearson correlation coefficient of the two columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    This method applies only to columns containing numerical data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider Frame *my_frame*, which contains the data</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  idnum  x1   x2   x3   x4</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]      0  1.0  4.0  0.0  -1.0</span>
<span class="sd">        [1]      1  2.0  3.0  0.0  -1.0</span>
<span class="sd">        [2]      2  3.0  2.0  1.0  -1.0</span>
<span class="sd">        [3]      3  4.0  1.0  2.0  -1.0</span>
<span class="sd">        [4]      4  5.0  0.0  2.0  -1.0</span>


<span class="sd">    my_frame.correlation computes the common correlation coefficient (Pearson&#39;s) on the pair</span>
<span class="sd">    of columns provided.</span>
<span class="sd">    In this example, the *idnum* and most of the columns have trivial correlations: -1, 0, or +1.</span>
<span class="sd">    Column *x3* provides a contrasting coefficient of 3 / sqrt(3) = 0.948683298051 .</span>


<span class="sd">        &gt;&gt;&gt; my_frame.correlation(&quot;x1&quot;, &quot;x2&quot;)</span>
<span class="sd">        -0.9999999999999998</span>

<span class="sd">        &gt;&gt;&gt; my_frame.correlation(&quot;x1&quot;, &quot;x4&quot;)</span>
<span class="sd">        nan</span>

<span class="sd">        &gt;&gt;&gt; my_frame.correlation(&quot;x2&quot;, &quot;x3&quot;)</span>
<span class="sd">        -0.9486832980505138</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.correlation_matrix">
    <p>def <span class="ident">correlation_matrix</span>(</p><p>self, data_column_names)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate correlation matrix for two or more columns.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column_names</td><td class='param-type'>(List[str]):</td><td class='param-desc'>The names of the columns from which to compute the matrix.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>A Frame with the matrix of the correlation values for the columns.</td></tr></table></p>

<div class='section-header'>Notes:</div>

<p>This method applies only to columns containing numerical data.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
 [#]  idnum  x1   x2   x3   x4
===============================
[0]      0  1.0  4.0  0.0  -1.0
[1]      1  2.0  3.0  0.0  -1.0
[2]      2  3.0  2.0  1.0  -1.0
[3]      3  4.0  1.0  2.0  -1.0
[4]      4  5.0  0.0  2.0  -1.0
</pre></div>


<p>my_frame.correlation_matrix computes the common correlation coefficient (Pearson's) on each pair
of columns in the user-provided list.
In this example, the <em>idnum</em> and most of the columns have trivial correlations: -1, 0, or +1.
Column <em>x3</em> provides a contrasting coefficient of 3 / sqrt(3) = 0.948683298051</p>
<div class="codehilite"><pre>&gt;&gt;&gt; corr_matrix = my_frame.correlation_matrix(my_frame.column_names)
[===Job Progress===]

The resulting table (specifying all columns) is:

&gt;&gt;&gt; corr_matrix.inspect()
[#]  idnum           x1              x2               x3               x4
==========================================================================
[0]             1.0             1.0             -1.0   0.948683298051  nan
[1]             1.0             1.0             -1.0   0.948683298051  nan
[2]            -1.0            -1.0              1.0  -0.948683298051  nan
[3]  0.948683298051  0.948683298051  -0.948683298051              1.0  nan
[4]             nan             nan              nan              nan  1.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.correlation_matrix', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.correlation_matrix" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">correlation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate correlation matrix for two or more columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column_names: (List[str]) The names of the columns from which to compute the matrix.</span>
<span class="sd">    :return: (Frame) A Frame with the matrix of the correlation values for the columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method applies only to columns containing numerical data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame*, which contains the data</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">         [#]  idnum  x1   x2   x3   x4</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]      0  1.0  4.0  0.0  -1.0</span>
<span class="sd">        [1]      1  2.0  3.0  0.0  -1.0</span>
<span class="sd">        [2]      2  3.0  2.0  1.0  -1.0</span>
<span class="sd">        [3]      3  4.0  1.0  2.0  -1.0</span>
<span class="sd">        [4]      4  5.0  0.0  2.0  -1.0</span>


<span class="sd">    my_frame.correlation_matrix computes the common correlation coefficient (Pearson&#39;s) on each pair</span>
<span class="sd">    of columns in the user-provided list.</span>
<span class="sd">    In this example, the *idnum* and most of the columns have trivial correlations: -1, 0, or +1.</span>
<span class="sd">    Column *x3* provides a contrasting coefficient of 3 / sqrt(3) = 0.948683298051</span>

<span class="sd">        &gt;&gt;&gt; corr_matrix = my_frame.correlation_matrix(my_frame.column_names)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        The resulting table (specifying all columns) is:</span>

<span class="sd">        &gt;&gt;&gt; corr_matrix.inspect()</span>
<span class="sd">        [#]  idnum           x1              x2               x3               x4</span>
<span class="sd">        ==========================================================================</span>
<span class="sd">        [0]             1.0             1.0             -1.0   0.948683298051  nan</span>
<span class="sd">        [1]             1.0             1.0             -1.0   0.948683298051  nan</span>
<span class="sd">        [2]            -1.0            -1.0              1.0  -0.948683298051  nan</span>
<span class="sd">        [3]  0.948683298051  0.948683298051  -0.948683298051              1.0  nan</span>
<span class="sd">        [4]             nan             nan              nan              nan  1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">correlationMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">data_column_names</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.count">
    <p>def <span class="ident">count</span>(</p><p>self, where=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Counts all rows or all qualified rows.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>where</td><td class='param-type'>(UDF):</td><td class='param-desc'>Optional function which evaluates a row to a boolean to determine if it should be counted
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(int): </td><td class='param-desc'>Number of rows counted</td></tr></table></p>

<p>Counts all rows or all rows which meet criteria specified by a UDF predicate.</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],
...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],
...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],
...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],
...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Susan      33       3  555-0202
[2]  Thurston   65      26  555-4510
[3]  Judy       44      14  555-2183

&gt;&gt;&gt; frame.count()
4

&gt;&gt;&gt; frame.count(lambda row: row.age &gt; 35)
3
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.count', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.count" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts all rows or all qualified rows.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param where: (UDF) Optional function which evaluates a row to a boolean to determine if it should be counted</span>
<span class="sd">    :return: (int) Number of rows counted</span>

<span class="sd">    Counts all rows or all rows which meet criteria specified by a UDF predicate.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],</span>
<span class="sd">        ...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],</span>
<span class="sd">        ...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],</span>
<span class="sd">        ...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],</span>
<span class="sd">        ...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">        &gt;&gt;&gt; frame.count()</span>
<span class="sd">        4</span>

<span class="sd">        &gt;&gt;&gt; frame.count(lambda row: row.age &gt; 35)</span>
<span class="sd">        3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">where</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">count_where</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">count_where</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">rowCount</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.covariance">
    <p>def <span class="ident">covariance</span>(</p><p>self, column_a, column_b)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate covariance for exactly two columns.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_a</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the covariance.
</td></tr></table>

<table><tr><td class='param-name'>column_b</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the covariance.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(float): </td><td class='param-desc'>Covariance of the two columns.</td></tr></table></p>

<div class='section-header'>Notes:</div>

<p>This method applies only to columns containing numerical data.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  idnum  x1   x2   x3   x4
===============================
[0]      0  1.0  4.0  0.0  -1.0
[1]      1  2.0  3.0  0.0  -1.0
[2]      2  3.0  2.0  1.0  -1.0
[3]      3  4.0  1.0  2.0  -1.0
[4]      4  5.0  0.0  2.0  -1.0
</pre></div>


<p>my_frame.covariance computes the covariance on the pair of columns provided.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.covariance(&quot;x1&quot;, &quot;x2&quot;)
-2.5

&gt;&gt;&gt; my_frame.covariance(&quot;x1&quot;, &quot;x4&quot;)
0.0

&gt;&gt;&gt; my_frame.covariance(&quot;x2&quot;, &quot;x3&quot;)
-1.5
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.covariance', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.covariance" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate covariance for exactly two columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_a: (str) The name of the column from which to compute the covariance.</span>
<span class="sd">    :param column_b: (str) The name of the column from which to compute the covariance.</span>
<span class="sd">    :return: (float) Covariance of the two columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method applies only to columns containing numerical data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame*, which contains the data</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  idnum  x1   x2   x3   x4</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]      0  1.0  4.0  0.0  -1.0</span>
<span class="sd">        [1]      1  2.0  3.0  0.0  -1.0</span>
<span class="sd">        [2]      2  3.0  2.0  1.0  -1.0</span>
<span class="sd">        [3]      3  4.0  1.0  2.0  -1.0</span>
<span class="sd">        [4]      4  5.0  0.0  2.0  -1.0</span>


<span class="sd">    my_frame.covariance computes the covariance on the pair of columns provided.</span>

<span class="sd">        &gt;&gt;&gt; my_frame.covariance(&quot;x1&quot;, &quot;x2&quot;)</span>
<span class="sd">        -2.5</span>

<span class="sd">        &gt;&gt;&gt; my_frame.covariance(&quot;x1&quot;, &quot;x4&quot;)</span>
<span class="sd">        0.0</span>

<span class="sd">        &gt;&gt;&gt; my_frame.covariance(&quot;x2&quot;, &quot;x3&quot;)</span>
<span class="sd">        -1.5</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">covariance</span><span class="p">(</span><span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.covariance_matrix">
    <p>def <span class="ident">covariance_matrix</span>(</p><p>self, data_column_names)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate covariance matrix for two or more columns.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column_names</td><td class='param-type'>(List[str]):</td><td class='param-desc'>The names of the column from which to compute the matrix.
                          Names should refer to a single column of type vector, or two or more
                          columns of numeric scalars.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>A matrix with the covariance values for the columns.</td></tr></table></p>

<div class='section-header'>Notes:</div>

<p>This function applies only to columns containing numerical data.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
 [#]  idnum  x1   x2   x3   x4
===============================
[0]      0  1.0  4.0  0.0  -1.0
[1]      1  2.0  3.0  0.0  -1.0
[2]      2  3.0  2.0  1.0  -1.0
[3]      3  4.0  1.0  2.0  -1.0
[4]      4  5.0  0.0  2.0  -1.0
</pre></div>


<p>my_frame.covariance_matrix computes the covariance on each pair of columns in the user-provided list.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; cov_matrix = my_frame.covariance_matrix(my_frame.column_names)
[===Job Progress===]

The resulting table (specifying all columns) is:

&gt;&gt;&gt; cov_matrix.inspect()
[#]  idnum  x1    x2    x3    x4
=================================
[0]    2.5   2.5  -2.5   1.5  0.0
[1]    2.5   2.5  -2.5   1.5  0.0
[2]   -2.5  -2.5   2.5  -1.5  0.0
[3]    1.5   1.5  -1.5   1.0  0.0
[4]    0.0   0.0   0.0   0.0  0.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.covariance_matrix', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.covariance_matrix" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate covariance matrix for two or more columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column_names: (List[str]) The names of the column from which to compute the matrix.</span>
<span class="sd">                              Names should refer to a single column of type vector, or two or more</span>
<span class="sd">                              columns of numeric scalars.</span>
<span class="sd">    :return: (Frame) A matrix with the covariance values for the columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function applies only to columns containing numerical data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame*, which contains the data</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">         [#]  idnum  x1   x2   x3   x4</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]      0  1.0  4.0  0.0  -1.0</span>
<span class="sd">        [1]      1  2.0  3.0  0.0  -1.0</span>
<span class="sd">        [2]      2  3.0  2.0  1.0  -1.0</span>
<span class="sd">        [3]      3  4.0  1.0  2.0  -1.0</span>
<span class="sd">        [4]      4  5.0  0.0  2.0  -1.0</span>


<span class="sd">    my_frame.covariance_matrix computes the covariance on each pair of columns in the user-provided list.</span>

<span class="sd">        &gt;&gt;&gt; cov_matrix = my_frame.covariance_matrix(my_frame.column_names)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        The resulting table (specifying all columns) is:</span>

<span class="sd">        &gt;&gt;&gt; cov_matrix.inspect()</span>
<span class="sd">        [#]  idnum  x1    x2    x3    x4</span>
<span class="sd">        =================================</span>
<span class="sd">        [0]    2.5   2.5  -2.5   1.5  0.0</span>
<span class="sd">        [1]    2.5   2.5  -2.5   1.5  0.0</span>
<span class="sd">        [2]   -2.5  -2.5   2.5  -1.5  0.0</span>
<span class="sd">        [3]    1.5   1.5  -1.5   1.0  0.0</span>
<span class="sd">        [4]    0.0   0.0   0.0   0.0  0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">covarianceMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">data_column_names</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.cumulative_percent">
    <p>def <span class="ident">cumulative_percent</span>(</p><p>self, sample_col)</p>
    </div>
    

    
  
    <div class="desc"><p>Add column to frame with cumulative percent.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>sample_col</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the cumulative percent.</td></tr></table>

<p>A cumulative percent sum is computed by sequentially stepping through the rows,
observing the column values and keeping track of the current percentage of the
total sum accounted for at the current value.</p>
<div class='section-header'>Notes:</div>

<p>This method applies only to columns containing numerical data.
Although this method will execute for columns containing negative
values, the interpretation of the result will change (for example,
negative percentages).</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em> accessing a frame that contains a single
column named <em>obs</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs
========
[0]    0
[1]    1
[2]    2
[3]    0
[4]    1
[5]    2
</pre></div>


<p>The cumulative percent sum for column <em>obs</em> is obtained by:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.cumulative_percent(&#39;obs&#39;)
[===Job Progress===]
</pre></div>


<p>The Frame <em>my_frame</em> now contains two columns <em>obs</em> and
<em>obsCumulativePercentSum</em>.
They contain the original data and the cumulative percent sum,
respectively:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs  obs_cumulative_percent
================================
[0]    0                     0.0
[1]    1          0.166666666667
[2]    2                     0.5
[3]    0                     0.5
[4]    1          0.666666666667
[5]    2                     1.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.cumulative_percent', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.cumulative_percent" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">cumulative_percent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_col</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add column to frame with cumulative percent.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param sample_col: (str) The name of the column from which to compute the cumulative percent.</span>

<span class="sd">    A cumulative percent sum is computed by sequentially stepping through the rows,</span>
<span class="sd">    observing the column values and keeping track of the current percentage of the</span>
<span class="sd">    total sum accounted for at the current value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method applies only to columns containing numerical data.</span>
<span class="sd">    Although this method will execute for columns containing negative</span>
<span class="sd">    values, the interpretation of the result will change (for example,</span>
<span class="sd">    negative percentages).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame* accessing a frame that contains a single</span>
<span class="sd">    column named *obs*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    0</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    0</span>
<span class="sd">        [4]    1</span>
<span class="sd">        [5]    2</span>

<span class="sd">    The cumulative percent sum for column *obs* is obtained by:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.cumulative_percent(&#39;obs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    The Frame *my_frame* now contains two columns *obs* and</span>
<span class="sd">    *obsCumulativePercentSum*.</span>
<span class="sd">    They contain the original data and the cumulative percent sum,</span>
<span class="sd">    respectively:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs  obs_cumulative_percent</span>
<span class="sd">        ================================</span>
<span class="sd">        [0]    0                     0.0</span>
<span class="sd">        [1]    1          0.166666666667</span>
<span class="sd">        [2]    2                     0.5</span>
<span class="sd">        [3]    0                     0.5</span>
<span class="sd">        [4]    1          0.666666666667</span>
<span class="sd">        [5]    2                     1.0</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">cumulativePercent</span><span class="p">(</span><span class="n">sample_col</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.cumulative_sum">
    <p>def <span class="ident">cumulative_sum</span>(</p><p>self, sample_col)</p>
    </div>
    

    
  
    <div class="desc"><p>Add column to frame with cumulative sum.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>sample_col</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the cumulative sum.</td></tr></table>

<p>A cumulative sum is computed by sequentially stepping through the rows,
observing the column values and keeping track of the cumulative sum for each value.</p>
<div class='section-header'>Notes:</div>

<p>This method applies only to columns containing numerical data.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which accesses a frame that contains a single
column named <em>obs</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs
========
[0]    0
[1]    1
[2]    2
[3]    0
[4]    1
[5]    2
</pre></div>


<p>The cumulative sum for column <em>obs</em> is obtained by:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.cumulative_sum(&#39;obs&#39;)
[===Job Progress===]
</pre></div>


<p>The Frame <em>my_frame</em> accesses the original frame that now contains two
columns, <em>obs</em> that contains the original column values, and
<em>obsCumulativeSum</em> that contains the cumulative percent count:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs  obs_cumulative_sum
============================
[0]    0                 0.0
[1]    1                 1.0
[2]    2                 3.0
[3]    0                 3.0
[4]    1                 4.0
[5]    2                 6.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.cumulative_sum', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.cumulative_sum" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">cumulative_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_col</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add column to frame with cumulative sum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param sample_col: (str) The name of the column from which to compute the cumulative sum.</span>

<span class="sd">    A cumulative sum is computed by sequentially stepping through the rows,</span>
<span class="sd">    observing the column values and keeping track of the cumulative sum for each value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method applies only to columns containing numerical data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider Frame *my_frame*, which accesses a frame that contains a single</span>
<span class="sd">    column named *obs*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    0</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    0</span>
<span class="sd">        [4]    1</span>
<span class="sd">        [5]    2</span>

<span class="sd">    The cumulative sum for column *obs* is obtained by:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.cumulative_sum(&#39;obs&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    The Frame *my_frame* accesses the original frame that now contains two</span>
<span class="sd">    columns, *obs* that contains the original column values, and</span>
<span class="sd">    *obsCumulativeSum* that contains the cumulative percent count:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs  obs_cumulative_sum</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]    0                 0.0</span>
<span class="sd">        [1]    1                 1.0</span>
<span class="sd">        [2]    2                 3.0</span>
<span class="sd">        [3]    0                 3.0</span>
<span class="sd">        [4]    1                 4.0</span>
<span class="sd">        [5]    2                 6.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">cumulativeSum</span><span class="p">(</span><span class="n">sample_col</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.dot_product">
    <p>def <span class="ident">dot_product</span>(</p><p>self, left_column_names, right_column_names, dot_product_column_name, default_left_values=None, default_right_values=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate dot product for each row in current frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>left_column_names</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of columns used to create the left vector (A) for each row.
                            Names should refer to a single column of type vector, or two or more columns of numeric scalars.
</td></tr></table>

<table><tr><td class='param-name'>right_column_names</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of columns used to create right vector (B) for each row.
                           Names should refer to a single column of type vector, or two or more columns of numeric scalars.
</td></tr></table>

<table><tr><td class='param-name'>dot_product_column_name</td><td class='param-type'>(str):</td><td class='param-desc'>Name of column used to store the dot product.
</td></tr></table>

<table><tr><td class='param-name'>default_left_values</td><td class='param-type'>(Optional[List[float]):</td><td class='param-desc'>Default values used to substitute null values in left vector.Default is None.
</td></tr></table>

<table><tr><td class='param-name'>default_right_values</td><td class='param-type'>(Optional[List[float]):</td><td class='param-desc'>Default values used to substitute null values in right vector.Default is None.</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns a frame with give "dot_product" column name</td></tr></table></p>

<p>Calculate the dot product for each row in a frame using values from two equal-length sequences of columns.</p>
<p>Dot product is computed by the following formula:</p>
<p>The dot product of two vectors :math:<code>A=[a_1, a_2, ..., a_n]</code> and :math:<code>B =[b_1, b_2, ..., b_n]</code> is :math:<code>a_1*b_1 + a_2*b_2 + ...+ a_n*b_n</code>.
The dot product for each row is stored in a new column in the existing frame.</p>
<div class='section-header'>Notes:</div>

<ul>
<li>If default_left_values or default_right_values are not specified, any null values will be replaced by zeros.</li>
<li>This method applies only to columns containing numerical data.</li>
</ul>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]
&gt;&gt;&gt; schema = [(&#39;col_0&#39;, int), (&#39;col_1&#39;, float),(&#39;col_2&#39;, int) ,(&#39;col_3&#39;, int)]

&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>Calculate the dot product for a sequence of columns in Frame object <em>my_frame</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  col_0  col_1  col_2  col_3
===============================
[0]      1    0.2     -2      5
[1]      2    0.4     -1      6
[2]      3    0.6      0      7
[3]      4    0.8      1      8
</pre></div>


<p>Modify the frame by computing the dot product for a sequence of columns:</p>
<div class="codehilite"><pre> &gt;&gt;&gt; my_frame.dot_product([&#39;col_0&#39;,&#39;col_1&#39;], [&#39;col_2&#39;, &#39;col_3&#39;], &#39;dot_product&#39;)
 [===Job Progress===]

&gt;&gt;&gt; my_frame.inspect()
[#]  col_0  col_1  col_2  col_3  dot_product
============================================
[0]      1    0.2     -2      5         -1.0
[1]      2    0.4     -1      6          0.4
[2]      3    0.6      0      7          4.2
[3]      4    0.8      1      8         10.4
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.dot_product', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.dot_product" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dot_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_column_names</span><span class="p">,</span><span class="n">right_column_names</span><span class="p">,</span><span class="n">dot_product_column_name</span><span class="p">,</span><span class="n">default_left_values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">default_right_values</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate dot product for each row in current frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param left_column_names: (List[str]) Names of columns used to create the left vector (A) for each row.</span>
<span class="sd">                                Names should refer to a single column of type vector, or two or more columns of numeric scalars.</span>
<span class="sd">    :param right_column_names: (List[str]) Names of columns used to create right vector (B) for each row.</span>
<span class="sd">                               Names should refer to a single column of type vector, or two or more columns of numeric scalars.</span>
<span class="sd">    :param dot_product_column_name: (str) Name of column used to store the dot product.</span>
<span class="sd">    :param default_left_values: (Optional[List[float]) Default values used to substitute null values in left vector.Default is None.</span>
<span class="sd">    :param default_right_values: (Optional[List[float]) Default values used to substitute null values in right vector.Default is None.</span>

<span class="sd">    :return: (Frame) returns a frame with give &quot;dot_product&quot; column name</span>

<span class="sd">    Calculate the dot product for each row in a frame using values from two equal-length sequences of columns.</span>

<span class="sd">    Dot product is computed by the following formula:</span>

<span class="sd">    The dot product of two vectors :math:`A=[a_1, a_2, ..., a_n]` and :math:`B =[b_1, b_2, ..., b_n]` is :math:`a_1*b_1 + a_2*b_2 + ...+ a_n*b_n`.</span>
<span class="sd">    The dot product for each row is stored in a new column in the existing frame.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    * If default_left_values or default_right_values are not specified, any null values will be replaced by zeros.</span>
<span class="sd">    * This method applies only to columns containing numerical data.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;col_0&#39;, int), (&#39;col_1&#39;, float),(&#39;col_2&#39;, int) ,(&#39;col_3&#39;, int)]</span>

<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Calculate the dot product for a sequence of columns in Frame object *my_frame*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  col_0  col_1  col_2  col_3</span>
<span class="sd">        ===============================</span>
<span class="sd">        [0]      1    0.2     -2      5</span>
<span class="sd">        [1]      2    0.4     -1      6</span>
<span class="sd">        [2]      3    0.6      0      7</span>
<span class="sd">        [3]      4    0.8      1      8</span>


<span class="sd">    Modify the frame by computing the dot product for a sequence of columns:</span>

<span class="sd">         &gt;&gt;&gt; my_frame.dot_product([&#39;col_0&#39;,&#39;col_1&#39;], [&#39;col_2&#39;, &#39;col_3&#39;], &#39;dot_product&#39;)</span>
<span class="sd">         [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  col_0  col_1  col_2  col_3  dot_product</span>
<span class="sd">        ============================================</span>
<span class="sd">        [0]      1    0.2     -2      5         -1.0</span>
<span class="sd">        [1]      2    0.4     -1      6          0.4</span>
<span class="sd">        [2]      3    0.6      0      7          4.2</span>
<span class="sd">        [3]      4    0.8      1      8         10.4</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">left_column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_column_names</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">right_column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_column_names</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">dotProduct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">left_column_names</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">right_column_names</span><span class="p">),</span>
                           <span class="n">dot_product_column_name</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option_list_double</span><span class="p">(</span><span class="n">default_left_values</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option_list_double</span><span class="p">(</span><span class="n">default_right_values</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.drop_columns">
    <p>def <span class="ident">drop_columns</span>(</p><p>self, columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Drops columns from the frame</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(str or List[str]):</td><td class='param-desc'>names of the columns to drop</td></tr></table>

<div class='section-header'>Examples:</div>

<p>For this example, the Frame object <em>my_frame</em> accesses a frame with 4 columns
columns <em>column_a</em>, <em>column_b</em>, <em>column_c</em> and <em>column_d</em> and drops 2 columns <em>column_b</em> and <em>column_d</em> using drop columns.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; print frame.schema
[(&#39;column_a&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_b&#39;, &lt;type &#39;int&#39;&gt;), (&#39;column_c&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_d&#39;, &lt;type &#39;int&#39;&gt;)]
</pre></div>


<p>Eliminate columns <em>column_b</em> and <em>column_d</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.drop_columns([&quot;column_b&quot;, &quot;column_d&quot;])
&gt;&gt;&gt; print frame.schema
[(&#39;column_a&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_c&#39;, &lt;type &#39;str&#39;&gt;)]
</pre></div>


<p>Now the frame only has the columns <em>column_a</em> and <em>column_c</em>.
For further examples, see: ref:<code>example_frame.drop_columns</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.drop_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.drop_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">drop_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Drops columns from the frame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (str or List[str]) names of the columns to drop</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For this example, the Frame object *my_frame* accesses a frame with 4 columns</span>
<span class="sd">    columns *column_a*, *column_b*, *column_c* and *column_d* and drops 2 columns *column_b* and *column_d* using drop columns.</span>



<span class="sd">        &gt;&gt;&gt; print frame.schema</span>
<span class="sd">        [(&#39;column_a&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_b&#39;, &lt;type &#39;int&#39;&gt;), (&#39;column_c&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_d&#39;, &lt;type &#39;int&#39;&gt;)]</span>


<span class="sd">    Eliminate columns *column_b* and *column_d*:</span>

<span class="sd">        &gt;&gt;&gt; frame.drop_columns([&quot;column_b&quot;, &quot;column_d&quot;])</span>
<span class="sd">        &gt;&gt;&gt; print frame.schema</span>
<span class="sd">        [(&#39;column_a&#39;, &lt;type &#39;str&#39;&gt;), (&#39;column_c&#39;, &lt;type &#39;str&#39;&gt;)]</span>

<span class="sd">    Now the frame only has the columns *column_a* and *column_c*.</span>
<span class="sd">    For further examples, see: ref:`example_frame.drop_columns`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">dropColumns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_vector_string</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">victim_indices</span> <span class="o">=</span> <span class="n">get_indices_for_selected_columns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">survivor_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">victim_indices</span><span class="p">]</span>
        <span class="n">filtered_schema</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">survivor_indices</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">filter_fields</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">survivor_indices</span><span class="p">]</span>
        <span class="n">filtered_rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">filter_fields</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame</span> <span class="o">=</span> <span class="n">PythonFrame</span><span class="p">(</span><span class="n">filtered_rdd</span><span class="p">,</span> <span class="n">filtered_schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.drop_duplicates">
    <p>def <span class="ident">drop_duplicates</span>(</p><p>self, unique_columns=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Modify the current frame, removing duplicate rows.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>unique_columns</td><td class='param-type'>(Optional[List[str] or str]):</td><td class='param-desc'>Column name(s) to identify duplicates. Default is the entire
                       row is compared.</td></tr></table>

<p>Remove data rows which are the same as other rows.
The entire row can be checked for duplication, or the search for duplicates can be limited to one or more columns.
This modifies the current frame.</p>
<div class='section-header'>Examples:</div>

<p>Given a frame with data:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a    b  c
===============
[0]  200  4  25
[1]  200  5  25
[2]  200  4  25
[3]  200  5  35
[4]  200  6  25
[5]  200  8  35
[6]  200  4  45
[7]  200  4  25
[8]  200  5  25
[9]  201  4  25
</pre></div>


<p>Remove any rows that are identical to a previous row.
The result is a frame of unique rows.
Note that row order may change.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.drop_duplicates()
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  a    b  c
===============
[0]  200  8  35
[1]  200  6  25
[2]  200  5  35
[3]  200  4  45
[4]  200  4  25
[5]  200  5  25
[6]  201  4  25
</pre></div>


<p>Now remove any rows that have the same data in columns <em>a</em> and
<em>c</em> as a previously checked row:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.drop_duplicates([ &quot;a&quot;, &quot;c&quot;])
[===Job Progress===]
</pre></div>


<p>The result is a frame with unique values for the combination of columns <em>a</em>
and <em>c</em>.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a    b  c
===============
[0]  201  4  25
[1]  200  4  45
[2]  200  6  25
[3]  200  8  35
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.drop_duplicates', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.drop_duplicates" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_columns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modify the current frame, removing duplicate rows.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param unique_columns: (Optional[List[str] or str]) Column name(s) to identify duplicates. Default is the entire</span>
<span class="sd">                           row is compared.</span>

<span class="sd">    Remove data rows which are the same as other rows.</span>
<span class="sd">    The entire row can be checked for duplication, or the search for duplicates can be limited to one or more columns.</span>
<span class="sd">    This modifies the current frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given a frame with data:</span>


<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a    b  c</span>
<span class="sd">        ===============</span>
<span class="sd">        [0]  200  4  25</span>
<span class="sd">        [1]  200  5  25</span>
<span class="sd">        [2]  200  4  25</span>
<span class="sd">        [3]  200  5  35</span>
<span class="sd">        [4]  200  6  25</span>
<span class="sd">        [5]  200  8  35</span>
<span class="sd">        [6]  200  4  45</span>
<span class="sd">        [7]  200  4  25</span>
<span class="sd">        [8]  200  5  25</span>
<span class="sd">        [9]  201  4  25</span>

<span class="sd">    Remove any rows that are identical to a previous row.</span>
<span class="sd">    The result is a frame of unique rows.</span>
<span class="sd">    Note that row order may change.</span>

<span class="sd">        &gt;&gt;&gt; frame.drop_duplicates()</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a    b  c</span>
<span class="sd">        ===============</span>
<span class="sd">        [0]  200  8  35</span>
<span class="sd">        [1]  200  6  25</span>
<span class="sd">        [2]  200  5  35</span>
<span class="sd">        [3]  200  4  45</span>
<span class="sd">        [4]  200  4  25</span>
<span class="sd">        [5]  200  5  25</span>
<span class="sd">        [6]  201  4  25</span>

<span class="sd">    Now remove any rows that have the same data in columns *a* and</span>
<span class="sd">    *c* as a previously checked row:</span>

<span class="sd">        &gt;&gt;&gt; frame.drop_duplicates([ &quot;a&quot;, &quot;c&quot;])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    The result is a frame with unique values for the combination of columns *a*</span>
<span class="sd">    and *c*.</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a    b  c</span>
<span class="sd">        ===============</span>
<span class="sd">        [0]  201  4  25</span>
<span class="sd">        [1]  200  4  45</span>
<span class="sd">        [2]  200  6  25</span>
<span class="sd">        [3]  200  8  35</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unique_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unique_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">unique_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique_columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unique_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">unique_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_vector_string</span><span class="p">(</span><span class="n">unique_columns</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">dropDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">unique_columns</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.drop_rows">
    <p>def <span class="ident">drop_rows</span>(</p><p>self, predicate)</p>
    </div>
    

    
  
    <div class="desc"><p>Erase any row in the current frame which qualifies.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>predicate</td><td class='param-type'>(UDF):</td><td class='param-desc'>Function which evaluates a row to a boolean; rows that answer True are dropped from
                  the frame.</td></tr></table>

<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],
...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],
...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],
...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],
...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Susan      33       3  555-0202
[2]  Thurston   65      26  555-4510
[3]  Judy       44      14  555-2183

&gt;&gt;&gt; frame.drop_rows(lambda row: row.name[-1] == &#39;n&#39;)  # drop people whose name ends in &#39;n&#39;

&gt;&gt;&gt; frame.inspect()
[#]  name  age  tenure  phone
================================
[0]  Fred   39      16  555-1234
[1]  Judy   44      14  555-2183
</pre></div>


<p>More information on a |UDF| can be found at :doc:<code>/ds_apir</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.drop_rows', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.drop_rows" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">drop_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Erase any row in the current frame which qualifies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param predicate: (UDF) Function which evaluates a row to a boolean; rows that answer True are dropped from</span>
<span class="sd">                      the frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],</span>
<span class="sd">        ...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],</span>
<span class="sd">        ...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],</span>
<span class="sd">        ...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],</span>
<span class="sd">        ...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">        &gt;&gt;&gt; frame.drop_rows(lambda row: row.name[-1] == &#39;n&#39;)  # drop people whose name ends in &#39;n&#39;</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name  age  tenure  phone</span>
<span class="sd">        ================================</span>
<span class="sd">        [0]  Fred   39      16  555-1234</span>
<span class="sd">        [1]  Judy   44      14  555-2183</span>

<span class="sd">    More information on a |UDF| can be found at :doc:`/ds_apir`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_rows_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">drop_rows_func</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.ecdf">
    <p>def <span class="ident">ecdf</span>(</p><p>self, column)</p>
    </div>
    

    
  
    <div class="desc"><p>Builds new frame with columns for data and distribution.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the input column containing sample.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>A new Frame containing each distinct value in the sample and its corresponding ECDF value.</td></tr></table></p>

<p>Generates the :term:<code>empirical cumulative distribution</code> for the input column.</p>
<div class='section-header'>Examples:</div>

<p>Consider the following sample data set in <em>frame</em> 'frame' containing several numbers.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  numbers
============
[0]        1
[1]        3
[2]        1
[3]        0
[4]        2
[5]        1
[6]        4
[7]        3

&gt;&gt;&gt; ecdf_frame = frame.ecdf(&#39;numbers&#39;)
[===Job Progress===]

&gt;&gt;&gt; ecdf_frame.inspect()
[#]  numbers  numbers_ecdf
==========================
[0]        0         0.125
[1]        1           0.5
[2]        2         0.625
[3]        3         0.875
[4]        4           1.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.ecdf', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.ecdf" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">ecdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds new frame with columns for data and distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column: (str) The name of the input column containing sample.</span>
<span class="sd">    :return: (Frame) A new Frame containing each distinct value in the sample and its corresponding ECDF value.</span>

<span class="sd">    Generates the :term:`empirical cumulative distribution` for the input column.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider the following sample data set in *frame* &#39;frame&#39; containing several numbers.</span>


<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  numbers</span>
<span class="sd">        ============</span>
<span class="sd">        [0]        1</span>
<span class="sd">        [1]        3</span>
<span class="sd">        [2]        1</span>
<span class="sd">        [3]        0</span>
<span class="sd">        [4]        2</span>
<span class="sd">        [5]        1</span>
<span class="sd">        [6]        4</span>
<span class="sd">        [7]        3</span>

<span class="sd">        &gt;&gt;&gt; ecdf_frame = frame.ecdf(&#39;numbers&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; ecdf_frame.inspect()</span>
<span class="sd">        [#]  numbers  numbers_ecdf</span>
<span class="sd">        ==========================</span>
<span class="sd">        [0]        0         0.125</span>
<span class="sd">        [1]        1           0.5</span>
<span class="sd">        [2]        2         0.625</span>
<span class="sd">        [3]        3         0.875</span>
<span class="sd">        [4]        4           1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">ecdf</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.entropy">
    <p>def <span class="ident">entropy</span>(</p><p>self, data_column, weights_column=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the Shannon entropy of a column.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>data_column</td><td class='param-type'>(str):</td><td class='param-desc'>The column whose entropy is to be calculated.
</td></tr></table>

<table><tr><td class='param-name'>weights_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The column that provides weights (frequencies) for the entropy calculation.
                       Must contain numerical data. Default is using uniform weights of 1 for all items.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(float): </td><td class='param-desc'>Entropy.</td></tr></table></p>

<p>The data column is weighted via the weights column.
All data elements of weight &lt;= 0 are excluded from the calculation, as are
all data elements whose weight is NaN or infinite.
If there are no data elements with a finite weight greater than 0,
the entropy is zero.</p>
<div class='section-header'>Examples:</div>

<p>Consider the following sample data set in <em>frame</em> 'frame' containing several numbers.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  data  weight
=================
[0]     0       1
[1]     1       2
[2]     2       4
[3]     4       8
&gt;&gt;&gt; entropy = frame.entropy(&quot;data&quot;, &quot;weight&quot;)
[===Job Progress===]

&gt;&gt;&gt; &quot;%0.8f&quot; % entropy
&#39;1.13691659&#39;
</pre></div>


<p>If we have more choices and weights, the computation is not as simple.
An on-line search for "Shannon Entropy" will provide more detail.</p>
<p>Given a frame of coin flips, half heads and half tails, the entropy is simply ln(2):</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  data
=========
[0]  H
[1]  T
[2]  H
[3]  T
[4]  H
[5]  T
[6]  H
[7]  T
[8]  H
[9]  T

&gt;&gt;&gt; entropy = frame.entropy(&quot;data&quot;)
[===Job Progress===]

&gt;&gt;&gt; &quot;%0.8f&quot; % entropy
&#39;0.69314718&#39;
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.entropy', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.entropy" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_column</span><span class="p">,</span> <span class="n">weights_column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Shannon entropy of a column.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param data_column: (str) The column whose entropy is to be calculated.</span>
<span class="sd">    :param weights_column: (Optional[str]) The column that provides weights (frequencies) for the entropy calculation.</span>
<span class="sd">                           Must contain numerical data. Default is using uniform weights of 1 for all items.</span>
<span class="sd">    :return: (float) Entropy.</span>

<span class="sd">    The data column is weighted via the weights column.</span>
<span class="sd">    All data elements of weight &lt;= 0 are excluded from the calculation, as are</span>
<span class="sd">    all data elements whose weight is NaN or infinite.</span>
<span class="sd">    If there are no data elements with a finite weight greater than 0,</span>
<span class="sd">    the entropy is zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider the following sample data set in *frame* &#39;frame&#39; containing several numbers.</span>


<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  data  weight</span>
<span class="sd">        =================</span>
<span class="sd">        [0]     0       1</span>
<span class="sd">        [1]     1       2</span>
<span class="sd">        [2]     2       4</span>
<span class="sd">        [3]     4       8</span>
<span class="sd">        &gt;&gt;&gt; entropy = frame.entropy(&quot;data&quot;, &quot;weight&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; &quot;%0.8f&quot; % entropy</span>
<span class="sd">        &#39;1.13691659&#39;</span>


<span class="sd">    If we have more choices and weights, the computation is not as simple.</span>
<span class="sd">    An on-line search for &quot;Shannon Entropy&quot; will provide more detail.</span>


<span class="sd">    Given a frame of coin flips, half heads and half tails, the entropy is simply ln(2):</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  data</span>
<span class="sd">        =========</span>
<span class="sd">        [0]  H</span>
<span class="sd">        [1]  T</span>
<span class="sd">        [2]  H</span>
<span class="sd">        [3]  T</span>
<span class="sd">        [4]  H</span>
<span class="sd">        [5]  T</span>
<span class="sd">        [6]  H</span>
<span class="sd">        [7]  T</span>
<span class="sd">        [8]  H</span>
<span class="sd">        [9]  T</span>

<span class="sd">        &gt;&gt;&gt; entropy = frame.entropy(&quot;data&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; &quot;%0.8f&quot; % entropy</span>
<span class="sd">        &#39;0.69314718&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">data_column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weights_column</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.export_to_csv">
    <p>def <span class="ident">export_to_csv</span>(</p><p>self, file_name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.export_to_csv', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.export_to_csv" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">export_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToCsv</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.export_to_hbase">
    <p>def <span class="ident">export_to_hbase</span>(</p><p>self, table_name, key_column_name=None, family_name=&#39;familyColumn&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Write current frame to HBase table.</p>
<p>Table must exist in HBase.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>table_name</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the HBase table that will contain the exported frame
</td></tr></table>

<table><tr><td class='param-name'>key_column_name</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The name of the column to be used as row key in hbase table
</td></tr></table>

<table><tr><td class='param-name'>family_name</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The family name of the HBase table that will contain the exported frame</td></tr></table>

<div class='section-header'>Example:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;b&#39;, float),(&#39;c&#39;, int) ,(&#39;d&#39;, int)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
&gt;&gt;&gt; my_frame.export_to_hbase(&quot;test_demo_hbase&quot;, family_name=&quot;test_family&quot;)
[===Job Progress===]
</pre></div>


<p>Verify exported frame in hbase</p>
<p>From bash shell</p>
<div class="codehilite"><pre><span class="p">$</span><span class="nv">hbase</span><span class="x"> shell</span>

<span class="x">hbase(main):001:0&gt; list</span>
</pre></div>


<p>You should see test_demo_hbase table.</p>
<p>Run hbase(main):001:0&gt; scan 'test_demo_hbase' (to verify frame).</p>
<p>Output:</p>
<div class="codehilite"><pre>ROW     COLUMN+CELL
 0      column=test_family:a, timestamp=1464219662295, value=1
 0      column=test_family:b, timestamp=1464219662295, value=0.2
 0      column=test_family:c, timestamp=1464219662295, value=-2
 0      column=test_family:d, timestamp=1464219662295, value=5
 1      column=test_family:a, timestamp=1464219662295, value=2
 1      column=test_family:b, timestamp=1464219662295, value=0.4
 1      column=test_family:c, timestamp=1464219662295, value=-1
 1      column=test_family:d, timestamp=1464219662295, value=6
 2      column=test_family:a, timestamp=1464219662295, value=3
 2      column=test_family:b, timestamp=1464219662295, value=0.6
 2      column=test_family:c, timestamp=1464219662295, value=0
 2      column=test_family:d, timestamp=1464219662295, value=7
 3      column=test_family:a, timestamp=1464219662295, value=4
 3      column=test_family:b, timestamp=1464219662295, value=0.8
 3      column=test_family:c, timestamp=1464219662295, value=1
 3      column=test_family:d, timestamp=1464219662295, value=8
4 row(s) in 0.1560 seconds
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.export_to_hbase', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.export_to_hbase" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">export_to_hbase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">key_column_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">family_name</span><span class="o">=</span><span class="s">&quot;familyColumn&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write current frame to HBase table.</span>

<span class="sd">    Table must exist in HBase.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param table_name: (str) The name of the HBase table that will contain the exported frame</span>
<span class="sd">    :param key_column_name: (Optional[str]) The name of the column to be used as row key in hbase table</span>
<span class="sd">    :param family_name: (Optional[str]) The family name of the HBase table that will contain the exported frame</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">        &gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;b&#39;, float),(&#39;c&#39;, int) ,(&#39;d&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        &gt;&gt;&gt; my_frame.export_to_hbase(&quot;test_demo_hbase&quot;, family_name=&quot;test_family&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Verify exported frame in hbase</span>

<span class="sd">    From bash shell</span>

<span class="sd">        $hbase shell</span>

<span class="sd">        hbase(main):001:0&gt; list</span>

<span class="sd">    You should see test_demo_hbase table.</span>

<span class="sd">    Run hbase(main):001:0&gt; scan &#39;test_demo_hbase&#39; (to verify frame).</span>

<span class="sd">    Output:</span>

<span class="sd">        ROW     COLUMN+CELL</span>
<span class="sd">         0      column=test_family:a, timestamp=1464219662295, value=1</span>
<span class="sd">         0      column=test_family:b, timestamp=1464219662295, value=0.2</span>
<span class="sd">         0      column=test_family:c, timestamp=1464219662295, value=-2</span>
<span class="sd">         0      column=test_family:d, timestamp=1464219662295, value=5</span>
<span class="sd">         1      column=test_family:a, timestamp=1464219662295, value=2</span>
<span class="sd">         1      column=test_family:b, timestamp=1464219662295, value=0.4</span>
<span class="sd">         1      column=test_family:c, timestamp=1464219662295, value=-1</span>
<span class="sd">         1      column=test_family:d, timestamp=1464219662295, value=6</span>
<span class="sd">         2      column=test_family:a, timestamp=1464219662295, value=3</span>
<span class="sd">         2      column=test_family:b, timestamp=1464219662295, value=0.6</span>
<span class="sd">         2      column=test_family:c, timestamp=1464219662295, value=0</span>
<span class="sd">         2      column=test_family:d, timestamp=1464219662295, value=7</span>
<span class="sd">         3      column=test_family:a, timestamp=1464219662295, value=4</span>
<span class="sd">         3      column=test_family:b, timestamp=1464219662295, value=0.8</span>
<span class="sd">         3      column=test_family:c, timestamp=1464219662295, value=1</span>
<span class="sd">         3      column=test_family:d, timestamp=1464219662295, value=8</span>
<span class="sd">        4 row(s) in 0.1560 seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported &#39;table_name&#39; parameter type.  Expected string, but found </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">table_name</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">family_name</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&quot;Unsupported &#39;family_name&#39; parameter type.  Expected string, but found </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">family_name</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToHbase</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">key_column_name</span><span class="p">),</span> <span class="n">family_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.export_to_hive">
    <p>def <span class="ident">export_to_hive</span>(</p><p>self, hive_table_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Write current frame to Hive table.</p>
<p>Table must not exist in Hive. Hive does not support case sensitive table names and columns names.
Hence column names with uppercase letters will be converted to lower case by Hive.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>hive_table_name</td><td class='param-type'>(str):</td><td class='param-desc'>hive table name</td></tr></table>

<div class='section-header'>Example:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]
&gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;b&#39;, float),(&#39;c&#39;, int) ,(&#39;d&#39;, int)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
[===Job Progress===]
</pre></div>


<p>table_name: (string): table name. It will create new table with given name if it does not exists already.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.export_to_hive(&quot;demo_test_hive&quot;)
[===Job Progress===]
</pre></div>


<p>Verify exported frame in hive</p>
<p>From bash shell</p>
<div class="codehilite"><pre><span class="p">$</span><span class="nv">hive</span><span class="x"></span>
<span class="x">hive&gt; show tables</span>
</pre></div>


<p>You should see demo_test_hive table.</p>
<p>Run hive&gt; select * from demo_test_hive; (to verify frame).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.export_to_hive', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.export_to_hive" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">export_to_hive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hive_table_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write current frame to Hive table.</span>

<span class="sd">    Table must not exist in Hive. Hive does not support case sensitive table names and columns names.</span>
<span class="sd">    Hence column names with uppercase letters will be converted to lower case by Hive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param hive_table_name: (str) hive table name</span>

<span class="sd">    Example</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;b&#39;, float),(&#39;c&#39;, int) ,(&#39;d&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>


<span class="sd">    table_name: (string): table name. It will create new table with given name if it does not exists already.</span>

<span class="sd">        &gt;&gt;&gt; my_frame.export_to_hive(&quot;demo_test_hive&quot;)</span>
<span class="sd">        [===Job Progress===]</span>


<span class="sd">    Verify exported frame in hive</span>

<span class="sd">    From bash shell</span>

<span class="sd">        $hive</span>
<span class="sd">        hive&gt; show tables</span>

<span class="sd">    You should see demo_test_hive table.</span>

<span class="sd">    Run hive&gt; select * from demo_test_hive; (to verify frame).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToHive</span><span class="p">(</span><span class="n">hive_table_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.export_to_jdbc">
    <p>def <span class="ident">export_to_jdbc</span>(</p><p>self, connection_url, table_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Write current frame to JDBC table</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>connection_url</td><td class='param-type'>(str):</td><td class='param-desc'>JDBC connection url to database server
</td></tr></table>

<table><tr><td class='param-name'>table_name</td><td class='param-type'>(str):</td><td class='param-desc'>JDBC table name</td></tr></table>

<div class='section-header'>Example:</div>

<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">TkContext</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">=</span><span class="n">TkContext</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">schema</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="p">,(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="p">[</span><span class="o">===</span><span class="n">Job</span> <span class="n">Progress</span><span class="o">===</span><span class="p">]</span>
</pre></div>


<p>connection_url : (string) : "jdbc:{datasbase_type}://{host}/{database_name}</p>
<p>Sample connection string for postgres
ex: jdbc:postgresql://localhost/postgres [standard connection string to connect to default 'postgres' database]</p>
<p>table_name: (string): table name. It will create new table with given name if it does not exists already.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.export_to_jdbc(&quot;jdbc:postgresql://localhost/postgres&quot;, &quot;demo_test&quot;)
[===Job Progress===]
</pre></div>


<p>Verify exported frame in postgres</p>
<div class="codehilite"><pre><span class="x">From bash shell</span>

<span class="p">$</span><span class="nv">sudo</span><span class="x"> -su ppostgres psql</span>
<span class="x">postgres=</span><span class="err">#</span><span class="x">\d</span>
</pre></div>


<p>You should see demo_test table.</p>
<p>Run postgres=#select * from demo_test (to verify frame).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.export_to_jdbc', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.export_to_jdbc" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">export_to_jdbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_url</span><span class="p">,</span> <span class="n">table_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write current frame to JDBC table</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param connection_url: (str) JDBC connection url to database server</span>
<span class="sd">    :param table_name: (str) JDBC table name</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>


<span class="sd">        &gt;&gt;&gt; from sparktk import TkContext</span>
<span class="sd">        &gt;&gt;&gt; c=TkContext(sc)</span>
<span class="sd">        &gt;&gt;&gt; data = [[1, 0.2, -2, 5], [2, 0.4, -1, 6], [3, 0.6, 0, 7], [4, 0.8, 1, 8]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;a&#39;, int), (&#39;b&#39;, float),(&#39;c&#39;, int) ,(&#39;d&#39;, int)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    connection_url : (string) : &quot;jdbc:{datasbase_type}://{host}/{database_name}</span>

<span class="sd">    Sample connection string for postgres</span>
<span class="sd">    ex: jdbc:postgresql://localhost/postgres [standard connection string to connect to default &#39;postgres&#39; database]</span>

<span class="sd">    table_name: (string): table name. It will create new table with given name if it does not exists already.</span>

<span class="sd">        &gt;&gt;&gt; my_frame.export_to_jdbc(&quot;jdbc:postgresql://localhost/postgres&quot;, &quot;demo_test&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Verify exported frame in postgres</span>

<span class="sd">        From bash shell</span>

<span class="sd">        $sudo -su ppostgres psql</span>
<span class="sd">        postgres=#\d</span>

<span class="sd">    You should see demo_test table.</span>

<span class="sd">    Run postgres=#select * from demo_test (to verify frame).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToJdbc</span><span class="p">(</span><span class="n">connection_url</span><span class="p">,</span> <span class="n">table_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.export_to_json">
    <p>def <span class="ident">export_to_json</span>(</p><p>self, path, count=0, offset=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Write current frame to HDFS in Json format.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>path</td><td class='param-type'>(str):</td><td class='param-desc'>The HDFS folder path where the files will be created.
</td></tr></table>

<table><tr><td class='param-name'>count</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The number of records you want. Default (0), or a non-positive value, is the
               whole frame.
</td></tr></table>

<table><tr><td class='param-name'>offset</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The number of rows to skip before exporting to the file. Default is zero (0).</td></tr></table></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.export_to_json', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.export_to_json" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">export_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write current frame to HDFS in Json format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param path: (str) The HDFS folder path where the files will be created.</span>
<span class="sd">    :param count: (Optional[int]) The number of records you want. Default (0), or a non-positive value, is the</span>
<span class="sd">                   whole frame.</span>
<span class="sd">    :param offset: (Optional[int]) The number of rows to skip before exporting to the file. Default is zero (0).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">exportToJson</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.filter">
    <p>def <span class="ident">filter</span>(</p><p>self, predicate)</p>
    </div>
    

    
  
    <div class="desc"><p>Select all rows which satisfy a predicate.</p>
<p>Modifies the current frame to save defined rows and delete everything
else.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>predicate</td><td class='param-type'>(UDF):</td><td class='param-desc'>Function which evaluates a row to a boolean; rows that answer False are dropped
                  from the frame.</td></tr></table>

<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],
...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],
...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],
...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],
...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Susan      33       3  555-0202
[2]  Thurston   65      26  555-4510
[3]  Judy       44      14  555-2183

&gt;&gt;&gt; frame.filter(lambda row: row.tenure &gt;= 15)  # keep only people with 15 or more years tenure

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Thurston   65      26  555-4510
</pre></div>


<p>More information on a |UDF| can be found at :doc:<code>/ds_apir</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.filter', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.filter" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select all rows which satisfy a predicate.</span>

<span class="sd">    Modifies the current frame to save defined rows and delete everything</span>
<span class="sd">    else.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param predicate: (UDF) Function which evaluates a row to a boolean; rows that answer False are dropped</span>
<span class="sd">                      from the frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],</span>
<span class="sd">        ...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],</span>
<span class="sd">        ...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],</span>
<span class="sd">        ...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],</span>
<span class="sd">        ...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">        &gt;&gt;&gt; frame.filter(lambda row: row.tenure &gt;= 15)  # keep only people with 15 or more years tenure</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Thurston   65      26  555-4510</span>

<span class="sd">    More information on a |UDF| can be found at :doc:`/ds_apir`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predicate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filter_func</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.flatten_columns">
    <p>def <span class="ident">flatten_columns</span>(</p><p>self, *columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Spread data to multiple rows based on cell data.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(str or tuple(str, str)):</td><td class='param-desc'>The the name of the column to be flattened, or a tuple with the column name and
                delimiter string.  The default delimiter is a comma (,).</td></tr></table>

<p>Splits cells in the specified columns into multiple rows according to a string delimiter.
New rows are a full copy of the original row, but the specified columns only contain one value.
The original row is deleted.</p>
<div class='section-header'>Examples:</div>

<p>Given a data file:</p>
<div class="codehilite"><pre>1-solo,mono,single-green,yellow,red
2-duo,double-orange,black
</pre></div>


<p>The commands to bring the data into a frame, where it can be worked on:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a  b                 c
==========================================
[0]  1  solo,mono,single  green|yellow|red
[1]  2  duo,double        orange|black
</pre></div>


<p>Now, spread out those sub-strings in column <em>b</em> and <em>c</em> by specifying the column names and delmiters:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.flatten_columns((&#39;b&#39;, &#39;,&#39;), (&#39;c&#39;, &#39;|&#39;))
[===Job Progress===]
</pre></div>


<p>Note that the delimiters parameter is optional, and if no delimiter is specified, the default
is a comma (,).  So, in the above example, the delimiter parameter for <em>b</em> could be omitted.</p>
<p>Check again:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a  b       c
======================
[0]  1  solo    green
[1]  1  mono    yellow
[2]  1  single  red
[3]  2  duo     orange
[4]  2  double  black
</pre></div>


<p>Alternatively, we can flatten a single column <em>b</em> using the default comma delimiter:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.flatten_columns(&#39;b&#39;)
[===Job Progress===]
</pre></div>


<p>Check again:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a  b       c
================================
[0]  1  solo    green|yellow|red
[1]  1  mono    green|yellow|red
[2]  1  single  green|yellow|red
[3]  2  duo     orange|black
[4]  2  double  orange|black
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.flatten_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.flatten_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">flatten_columns</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spread data to multiple rows based on cell data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (str or tuple(str, str)) The the name of the column to be flattened, or a tuple with the column name and</span>
<span class="sd">                    delimiter string.  The default delimiter is a comma (,).</span>

<span class="sd">    Splits cells in the specified columns into multiple rows according to a string delimiter.</span>
<span class="sd">    New rows are a full copy of the original row, but the specified columns only contain one value.</span>
<span class="sd">    The original row is deleted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given a data file:</span>

<span class="sd">        1-solo,mono,single-green,yellow,red</span>
<span class="sd">        2-duo,double-orange,black</span>

<span class="sd">    The commands to bring the data into a frame, where it can be worked on:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b                 c</span>
<span class="sd">        ==========================================</span>
<span class="sd">        [0]  1  solo,mono,single  green|yellow|red</span>
<span class="sd">        [1]  2  duo,double        orange|black</span>

<span class="sd">    Now, spread out those sub-strings in column *b* and *c* by specifying the column names and delmiters:</span>

<span class="sd">        &gt;&gt;&gt; frame.flatten_columns((&#39;b&#39;, &#39;,&#39;), (&#39;c&#39;, &#39;|&#39;))</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Note that the delimiters parameter is optional, and if no delimiter is specified, the default</span>
<span class="sd">    is a comma (,).  So, in the above example, the delimiter parameter for *b* could be omitted.</span>

<span class="sd">    Check again:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b       c</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]  1  solo    green</span>
<span class="sd">        [1]  1  mono    yellow</span>
<span class="sd">        [2]  1  single  red</span>
<span class="sd">        [3]  2  duo     orange</span>
<span class="sd">        [4]  2  double  black</span>


<span class="sd">    Alternatively, we can flatten a single column *b* using the default comma delimiter:</span>

<span class="sd">        &gt;&gt;&gt; frame.flatten_columns(&#39;b&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Check again:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b       c</span>
<span class="sd">        ================================</span>
<span class="sd">        [0]  1  solo    green|yellow|red</span>
<span class="sd">        [1]  1  mono    green|yellow|red</span>
<span class="sd">        [2]  1  single  green|yellow|red</span>
<span class="sd">        [3]  2  duo     orange|black</span>
<span class="sd">        [4]  2  double  orange|black</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">flattenColumns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string_option_tuple</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.group_by">
    <p>def <span class="ident">group_by</span>(</p><p>self, group_by_columns, *aggregations)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a Summarized Frame with Aggregations (Avg, Count, Max, Min, Mean, Sum, Stdev, ...).</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>group_by_columns</td><td class='param-type'>(List[str]):</td><td class='param-desc'>list of columns to group on
</td></tr></table>

<table><tr><td class='param-name'>aggregations</td><td class='param-type'>(dict):</td><td class='param-desc'>Aggregation function based on entire row, and/or dictionaries (one or more) of { column name str : aggregation function(s) }.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>Summarized Frame</td></tr></table></p>

<p>Creates a new frame and returns a Frame object to access it.Takes a column or group of columns, finds the unique combination of
values, and creates unique rows with these column values.The other columns are combined according to the aggregation argument(s).</p>
<div class='section-header'>Notes:</div>

<ul>
<li>Column order is not guaranteed when columns are added</li>
<li>
<p>The column names created by aggregation functions in the new frame
    are the original column name appended with the '_' character and
    the aggregation function.</p>
<p>For example, if the original field is <em>a</em> and the function is
<em>avg</em>, the resultant column is named <em>a_avg</em>.</p>
</li>
<li>
<p>An aggregation argument of <em>count</em> results in a column named <em>count</em>.</p>
</li>
<li>The aggregation function <em>agg.count</em> is the only full row aggregation function supported at this time.</li>
<li>Aggregation currently supports using the following functions:
        *   avg
        *   count
        *   count_distinct
        *   max
        *   min
        *   stdev
        *   sum
        *   var (see glossary :term:<code>Bias vs Variance</code>)
        *   The aggregation arguments also accepts the User Defined function(UDF). UDF acts on each row
        *   histogram(cutoffs, include_lowest=True, strict_binning=False)
                - cutoffs: (List[int or float or long or double]) An array of values containing bin cutoff points. Array can be list or tuple. If an array is provided,
                            values must be progressively increasing. All bin boundaries must be included, so, with N bins, you need N+1 values.
                            Ex: [1, 5, 8, 12] - creates three bins
                                    0 (bin) - values [1 inclusive - 5 exclusive]
                                    1 (bin) - values [5 inclusive - 8 exclusive]
                                    2 (bin) - values [8 inclusive - 9 exclusive]<div class="codehilite"><pre>        - include_lowest: (Optional[bool]) Specify how the boundary conditions are handled. ``True`` indicates that the lower bound of the bin is inclusive.
                          ``False`` indicates that the upper bound is inclusive. Default is ``True``.

        - strict_binning: (Optional(bool)) Specify how values outside of the cutoffs array should be binned. If set to ``True``, each value less than cutoffs[0]
                          or greater than cutoffs[-1] will be assigned a bin value of -1. If set to ``False``, values less than cutoffs[0] will be included in
                          the first bin while values greater than cutoffs[-1] will be included in the final bin.
</pre></div>


</li>
</ul>
<p>Examples</p>
<hr />
<p>For setup, we will use a Frame <em>my_frame</em> accessing a frame with a column <em>a</em>:</p>
<p>.. code::</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a  b        c     d       e  f    g
========================================
[0]  1  alpha     3.0  small   1  3.0  9
[1]  1  bravo     5.0  medium  1  4.0  9
[2]  1  alpha     5.0  large   1  8.0  8
[3]  2  bravo     8.0  large   1  5.0  7
[4]  2  charlie  12.0  medium  1  6.0  6
[5]  2  bravo     7.0  small   1  8.0  5
[6]  2  bravo    12.0  large   1  6.0  4

Count the groups in column &#39;b&#39;

&gt;&gt;&gt; b_count = frame.group_by(&#39;b&#39;, tc.agg.count)
[===Job Progress===]
&gt;&gt;&gt; b_count.inspect()
[#]  b        count
===================
[0]  alpha        2
[1]  charlie      1
[2]  bravo        4

&gt;&gt;&gt; avg1 = frame.group_by([&#39;a&#39;, &#39;b&#39;], {&#39;c&#39; : tc.agg.avg})
[===Job Progress===]
&gt;&gt;&gt; avg1.inspect()
[#]  a  b        c_AVG
======================
[0]  2  charlie   12.0
[1]  2  bravo      9.0
[2]  1  bravo      5.0
[3]  1  alpha      4.0

&gt;&gt;&gt; mix_frame = frame.group_by(&#39;a&#39;, tc.agg.count, {&#39;f&#39;: [tc.agg.avg, tc.agg.sum, tc.agg.min], &#39;g&#39;: tc.agg.max})
[===Job Progress===]

&gt;&gt;&gt; mix_frame.inspect()
[#]  a  count  g_MAX  f_AVG  f_SUM  f_MIN
=========================================
[0]  2      4      7   6.25   25.0    5.0
[1]  1      3      9    5.0   15.0    3.0

GroupbyHistogram

&gt;&gt;&gt; hist = frame.group_by(&#39;a&#39;, {&#39;g&#39;: tc.agg.histogram([1, 5, 8, 9])})
[===Job Progress===]

&gt;&gt;&gt; hist.inspect()
[#]  a  g_HISTOGRAM
=========================
[0]  2  [0.25, 0.75, 0.0]
[1]  1    [0.0, 0.0, 1.0]

&gt;&gt;&gt; hist = frame.group_by(&#39;a&#39;, {&#39;g&#39;: tc.agg.histogram([1, 5, 8, 9], False)})
[===Job Progress===]

&gt;&gt;&gt; hist.inspect()
[#]  a  g_HISTOGRAM
=============================================
[0]  2                        [0.5, 0.5, 0.0]
[1]  1  [0.0, 0.333333333333, 0.666666666667]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.group_by', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.group_by" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_by_columns</span><span class="p">,</span> <span class="o">*</span><span class="n">aggregations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a Summarized Frame with Aggregations (Avg, Count, Max, Min, Mean, Sum, Stdev, ...).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>


<span class="sd">    :param group_by_columns: (List[str]) list of columns to group on</span>
<span class="sd">    :param aggregations: (dict) Aggregation function based on entire row, and/or dictionaries (one or more) of { column name str : aggregation function(s) }.</span>
<span class="sd">    :return: (Frame) Summarized Frame</span>

<span class="sd">    Creates a new frame and returns a Frame object to access it.Takes a column or group of columns, finds the unique combination of</span>
<span class="sd">    values, and creates unique rows with these column values.The other columns are combined according to the aggregation argument(s).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *   Column order is not guaranteed when columns are added</span>
<span class="sd">    *   The column names created by aggregation functions in the new frame</span>
<span class="sd">        are the original column name appended with the &#39;_&#39; character and</span>
<span class="sd">        the aggregation function.</span>

<span class="sd">        For example, if the original field is *a* and the function is</span>
<span class="sd">        *avg*, the resultant column is named *a_avg*.</span>

<span class="sd">    *   An aggregation argument of *count* results in a column named *count*.</span>
<span class="sd">    *   The aggregation function *agg.count* is the only full row aggregation function supported at this time.</span>
<span class="sd">    *   Aggregation currently supports using the following functions:</span>
<span class="sd">            *   avg</span>
<span class="sd">            *   count</span>
<span class="sd">            *   count_distinct</span>
<span class="sd">            *   max</span>
<span class="sd">            *   min</span>
<span class="sd">            *   stdev</span>
<span class="sd">            *   sum</span>
<span class="sd">            *   var (see glossary :term:`Bias vs Variance`)</span>
<span class="sd">            *   The aggregation arguments also accepts the User Defined function(UDF). UDF acts on each row</span>
<span class="sd">            *   histogram(cutoffs, include_lowest=True, strict_binning=False)</span>
<span class="sd">                    - cutoffs: (List[int or float or long or double]) An array of values containing bin cutoff points. Array can be list or tuple. If an array is provided,</span>
<span class="sd">                                values must be progressively increasing. All bin boundaries must be included, so, with N bins, you need N+1 values.</span>
<span class="sd">                                Ex: [1, 5, 8, 12] - creates three bins</span>
<span class="sd">                                        0 (bin) - values [1 inclusive - 5 exclusive]</span>
<span class="sd">                                        1 (bin) - values [5 inclusive - 8 exclusive]</span>
<span class="sd">                                        2 (bin) - values [8 inclusive - 9 exclusive]</span>

<span class="sd">                    - include_lowest: (Optional[bool]) Specify how the boundary conditions are handled. ``True`` indicates that the lower bound of the bin is inclusive.</span>
<span class="sd">                                      ``False`` indicates that the upper bound is inclusive. Default is ``True``.</span>

<span class="sd">                    - strict_binning: (Optional(bool)) Specify how values outside of the cutoffs array should be binned. If set to ``True``, each value less than cutoffs[0]</span>
<span class="sd">                                      or greater than cutoffs[-1] will be assigned a bin value of -1. If set to ``False``, values less than cutoffs[0] will be included in</span>
<span class="sd">                                      the first bin while values greater than cutoffs[-1] will be included in the final bin.</span>

<span class="sd">     Examples</span>
<span class="sd">     -------</span>
<span class="sd">     For setup, we will use a Frame *my_frame* accessing a frame with a column *a*:</span>

<span class="sd">    .. code::</span>


<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a  b        c     d       e  f    g</span>
<span class="sd">        ========================================</span>
<span class="sd">        [0]  1  alpha     3.0  small   1  3.0  9</span>
<span class="sd">        [1]  1  bravo     5.0  medium  1  4.0  9</span>
<span class="sd">        [2]  1  alpha     5.0  large   1  8.0  8</span>
<span class="sd">        [3]  2  bravo     8.0  large   1  5.0  7</span>
<span class="sd">        [4]  2  charlie  12.0  medium  1  6.0  6</span>
<span class="sd">        [5]  2  bravo     7.0  small   1  8.0  5</span>
<span class="sd">        [6]  2  bravo    12.0  large   1  6.0  4</span>

<span class="sd">        Count the groups in column &#39;b&#39;</span>

<span class="sd">        &gt;&gt;&gt; b_count = frame.group_by(&#39;b&#39;, tc.agg.count)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; b_count.inspect()</span>
<span class="sd">        [#]  b        count</span>
<span class="sd">        ===================</span>
<span class="sd">        [0]  alpha        2</span>
<span class="sd">        [1]  charlie      1</span>
<span class="sd">        [2]  bravo        4</span>

<span class="sd">        &gt;&gt;&gt; avg1 = frame.group_by([&#39;a&#39;, &#39;b&#39;], {&#39;c&#39; : tc.agg.avg})</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; avg1.inspect()</span>
<span class="sd">        [#]  a  b        c_AVG</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]  2  charlie   12.0</span>
<span class="sd">        [1]  2  bravo      9.0</span>
<span class="sd">        [2]  1  bravo      5.0</span>
<span class="sd">        [3]  1  alpha      4.0</span>

<span class="sd">        &gt;&gt;&gt; mix_frame = frame.group_by(&#39;a&#39;, tc.agg.count, {&#39;f&#39;: [tc.agg.avg, tc.agg.sum, tc.agg.min], &#39;g&#39;: tc.agg.max})</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; mix_frame.inspect()</span>
<span class="sd">        [#]  a  count  g_MAX  f_AVG  f_SUM  f_MIN</span>
<span class="sd">        =========================================</span>
<span class="sd">        [0]  2      4      7   6.25   25.0    5.0</span>
<span class="sd">        [1]  1      3      9    5.0   15.0    3.0</span>

<span class="sd">        GroupbyHistogram</span>

<span class="sd">        &gt;&gt;&gt; hist = frame.group_by(&#39;a&#39;, {&#39;g&#39;: tc.agg.histogram([1, 5, 8, 9])})</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; hist.inspect()</span>
<span class="sd">        [#]  a  g_HISTOGRAM</span>
<span class="sd">        =========================</span>
<span class="sd">        [0]  2  [0.25, 0.75, 0.0]</span>
<span class="sd">        [1]  1    [0.0, 0.0, 1.0]</span>

<span class="sd">        &gt;&gt;&gt; hist = frame.group_by(&#39;a&#39;, {&#39;g&#39;: tc.agg.histogram([1, 5, 8, 9], False)})</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; hist.inspect()</span>
<span class="sd">        [#]  a  g_HISTOGRAM</span>
<span class="sd">        =============================================</span>
<span class="sd">        [0]  2                        [0.5, 0.5, 0.0]</span>
<span class="sd">        [1]  1  [0.0, 0.333333333333, 0.666666666667]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">group_by_columns</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">group_by_columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by_columns</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">group_by_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_by_columns</span><span class="p">]</span>

    <span class="n">first_column_name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">aggregation_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># aggregationFunction : String, columnName : String, newColumnName</span>

    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">aggregations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first_column_name</span><span class="p">:</span>
                <span class="c"># only make this call once, since it goes to http - TODO, ultimately should be handled server-side</span>
                <span class="n">first_column_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">aggregation_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s">&#39;function&#39;</span><span class="p">:</span> <span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="s">&#39;column_name&#39;</span><span class="p">:</span> <span class="n">first_column_name</span><span class="p">,</span> <span class="s">&#39;new_column_name&#39;</span><span class="p">:</span> <span class="s">&quot;count&quot;</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="c"># leave the valid column check to the server</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">agg</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a valid aggregation function, like agg.max.  Supported agg methods: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="n">item</span><span class="p">,</span> <span class="n">agg</span><span class="p">))</span>
                        <span class="n">aggregation_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">{</span><span class="s">&#39;function&#39;</span><span class="p">:</span> <span class="n">item</span><span class="p">,</span> <span class="s">&#39;column_name&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;new_column_name&#39;</span><span class="p">:</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aggregation_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">{</span><span class="s">&#39;function&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="s">&#39;column_name&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;new_column_name&#39;</span><span class="p">:</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&quot;Bad type </span><span class="si">%s</span><span class="s"> provided in aggregation arguments; expecting an aggregation function or a dictionary of column_name:[func]&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span>
                    <span class="n">arg</span><span class="p">))</span>

    <span class="n">scala_group_by_aggregation_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">aggregation_list</span><span class="p">:</span>
        <span class="n">scala_group_by_aggregation_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_group_by_aggregation_args</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">group_by_columns</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list</span><span class="p">(</span><span class="n">scala_group_by_aggregation_args</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.histogram">
    <p>def <span class="ident">histogram</span>(</p><p>self, column_name, num_bins=None, weight_column_name=None, bin_type=&#39;equalwidth&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the histogram for a column in a frame.</p>
<p>The returned value is a Histogram object containing 3 lists one each for:
the cutoff points of the bins, size of each bin, and density of each bin.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name</td><td class='param-type'>(str):</td><td class='param-desc'>Name of column to be evaluated.
</td></tr></table>

<table><tr><td class='param-name'>num_bins</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>Number of bins in histogram.
                 Default is Square-root choice will be used
                 (in other words math.floor(math.sqrt(frame.count())).
</td></tr></table>

<table><tr><td class='param-name'>weight_column_name</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>Name of column containing weights.
                           Default is all observations are weighted equally.
</td></tr></table>

<table><tr><td class='param-name'>bin_type</td><td class='param-type'>(str["equalwidth"|"equaldepth"]):</td><td class='param-desc'>The type of binning algorithm to use:
                 ["equalwidth"|"equaldepth"] Defaults is "equalwidth".
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Histogram): </td><td class='param-desc'>A Histogram object containing the result set.
            The data returned is composed of multiple components:<br>
        cutoffs : array of float<br>
            A list containing the edges of each bin.<br>
        hist : array of float<br>
            A list containing count of the weighted observations found in each bin.<br>
        density : array of float<br>
            A list containing a decimal containing the percentage of
            observations found in the total set per bin.</td></tr></table></p>

<div class='section-header'>Notes:</div>

<p>The num_bins parameter is considered to be the maximum permissible number
of bins because the data may dictate fewer bins.
With equal depth binning, for example, if the column to be binned has 10
elements with only 2 distinct values and the <em>num_bins</em> parameter is
greater than 2, then the number of actual number of bins will only be 2.
This is due to a restriction that elements with an identical value must
belong to the same bin.</p>
<div class='section-header'>Examples:</div>

<p>Consider the following sample data set:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
    [#]  a  b
    =========
    [0]  a  2
    [1]  b  7
    [2]  c  3
    [3]  d  9
    [4]  e  1
</pre></div>


<p>A simple call for 3 equal-width bins gives:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; hist = frame.histogram(&quot;b&quot;, num_bins=3)
[===Job Progress===]
&gt;&gt;&gt; hist.cutoffs
[1.0, 3.6666666666666665, 6.333333333333333, 9.0]

&gt;&gt;&gt; hist.hist
[3.0, 0.0, 2.0]

&gt;&gt;&gt; hist.density
[0.6, 0.0, 0.4]
</pre></div>


<p>Switching to equal depth gives\:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; hist = frame.histogram(&quot;b&quot;, num_bins=3, bin_type=&#39;equaldepth&#39;)
[===Job Progress===]

&gt;&gt;&gt; hist.cutoffs
[1.0, 2.0, 7.0, 9.0]

&gt;&gt;&gt; hist.hist
[1.0, 2.0, 2.0]

&gt;&gt;&gt; hist.density
[0.2, 0.4, 0.4]
</pre></div>


<p>Plot hist as a bar chart using matplotlib:</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span><span class="n">cutoffs</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">hist</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">hist</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>


<p>Plot hist as a bar chart using matplotlib\:</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">hist</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
<span class="o">...</span> <span class="n">hist</span><span class="p">[</span><span class="s">&quot;cutoffs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.histogram', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.histogram" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weight_column_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bin_type</span><span class="o">=</span><span class="s">&quot;equalwidth&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the histogram for a column in a frame.</span>

<span class="sd">    The returned value is a Histogram object containing 3 lists one each for:</span>
<span class="sd">    the cutoff points of the bins, size of each bin, and density of each bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: (str) Name of column to be evaluated.</span>
<span class="sd">    :param num_bins: (Optional[int]) Number of bins in histogram.</span>
<span class="sd">                     Default is Square-root choice will be used</span>
<span class="sd">                     (in other words math.floor(math.sqrt(frame.count())).</span>
<span class="sd">    :param weight_column_name: (Optional[str]) Name of column containing weights.</span>
<span class="sd">                               Default is all observations are weighted equally.</span>
<span class="sd">    :param bin_type: (str[&quot;equalwidth&quot;|&quot;equaldepth&quot;]) The type of binning algorithm to use:</span>
<span class="sd">                     [&quot;equalwidth&quot;|&quot;equaldepth&quot;] Defaults is &quot;equalwidth&quot;.</span>
<span class="sd">    :return: (Histogram) A Histogram object containing the result set.</span>
<span class="sd">                The data returned is composed of multiple components:&lt;br&gt;</span>
<span class="sd">            cutoffs : array of float&lt;br&gt;</span>
<span class="sd">                A list containing the edges of each bin.&lt;br&gt;</span>
<span class="sd">            hist : array of float&lt;br&gt;</span>
<span class="sd">                A list containing count of the weighted observations found in each bin.&lt;br&gt;</span>
<span class="sd">            density : array of float&lt;br&gt;</span>
<span class="sd">                A list containing a decimal containing the percentage of</span>
<span class="sd">                observations found in the total set per bin.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The num_bins parameter is considered to be the maximum permissible number</span>
<span class="sd">    of bins because the data may dictate fewer bins.</span>
<span class="sd">    With equal depth binning, for example, if the column to be binned has 10</span>
<span class="sd">    elements with only 2 distinct values and the *num_bins* parameter is</span>
<span class="sd">    greater than 2, then the number of actual number of bins will only be 2.</span>
<span class="sd">    This is due to a restriction that elements with an identical value must</span>
<span class="sd">    belong to the same bin.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider the following sample data set:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">            [#]  a  b</span>
<span class="sd">            =========</span>
<span class="sd">            [0]  a  2</span>
<span class="sd">            [1]  b  7</span>
<span class="sd">            [2]  c  3</span>
<span class="sd">            [3]  d  9</span>
<span class="sd">            [4]  e  1</span>

<span class="sd">    A simple call for 3 equal-width bins gives:</span>

<span class="sd">        &gt;&gt;&gt; hist = frame.histogram(&quot;b&quot;, num_bins=3)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; hist.cutoffs</span>
<span class="sd">        [1.0, 3.6666666666666665, 6.333333333333333, 9.0]</span>

<span class="sd">        &gt;&gt;&gt; hist.hist</span>
<span class="sd">        [3.0, 0.0, 2.0]</span>

<span class="sd">        &gt;&gt;&gt; hist.density</span>
<span class="sd">        [0.6, 0.0, 0.4]</span>

<span class="sd">    Switching to equal depth gives\:</span>

<span class="sd">        &gt;&gt;&gt; hist = frame.histogram(&quot;b&quot;, num_bins=3, bin_type=&#39;equaldepth&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; hist.cutoffs</span>
<span class="sd">        [1.0, 2.0, 7.0, 9.0]</span>

<span class="sd">        &gt;&gt;&gt; hist.hist</span>
<span class="sd">        [1.0, 2.0, 2.0]</span>

<span class="sd">        &gt;&gt;&gt; hist.density</span>
<span class="sd">        [0.2, 0.4, 0.4]</span>

<span class="sd">    Plot hist as a bar chart using matplotlib:</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">        &gt;&gt;&gt; plt.bar(hist,cutoffs[:1], hist.hist, width=hist.cutoffs[1] - hist.cutoffs[0])</span>

<span class="sd">    Plot hist as a bar chart using matplotlib\:</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">        &gt;&gt;&gt; plt.bar(hist.cutoffs[:1], hist.hist, width=hist.cutoffs[1] -</span>
<span class="sd">        ... hist[&quot;cutoffs&quot;][0])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">scala_map_to_python_with_iterable_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">num_bins</span><span class="p">),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weight_column_name</span><span class="p">),</span>
                          <span class="n">bin_type</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Histogram</span><span class="p">(</span><span class="o">**</span><span class="n">results</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.inspect">
    <p>def <span class="ident">inspect</span>(</p><p>self, n=10, offset=0, columns=None, wrap=&#39;inspect_settings&#39;, truncate=&#39;inspect_settings&#39;, round=&#39;inspect_settings&#39;, width=&#39;inspect_settings&#39;, margin=&#39;inspect_settings&#39;, with_types=&#39;inspect_settings&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Pretty-print of the frame data</p>
<p>Essentially returns a string, but technically returns a RowInspection object which renders a string.
The RowInspection object naturally converts to a str when needed, like when printed or when displayed
by python REPL (i.e. using the object's <strong>repr</strong>).  If running in a script and want the inspect output
to be printed, then it must be explicitly printed, then <code>print frame.inspect()</code></p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>n</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The number of rows to print
</td></tr></table>

<table><tr><td class='param-name'>offset</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The number of rows to skip before printing.
</td></tr></table>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(Optional[List[str]]):</td><td class='param-desc'>Filter columns to be included.  By default, all columns are included.
</td></tr></table>

<table><tr><td class='param-name'>wrap</td><td class='param-type'>(Optional[int or 'stripes']):</td><td class='param-desc'>If set to 'stripes' then inspect prints rows in stripes; if set to an
             integer N, rows will be printed in clumps of N columns, where the columns are wrapped.
</td></tr></table>

<table><tr><td class='param-name'>truncate</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>If set to integer N, all strings will be truncated to length N, including all
                 tagged ellipses.
</td></tr></table>

<table><tr><td class='param-name'>round</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>If set to integer N, all floating point numbers will be rounded and truncated to
              N digits.
</td></tr></table>

<table><tr><td class='param-name'>width</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>If set to integer N, the print out will try to honor a max line width of N.
</td></tr></table>

<table><tr><td class='param-name'>margin</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>Applies to 'stripes' mode only.  If set to integer N, the margin for printing names
               in a stripe will be limited to N characters.
</td></tr></table>

<table><tr><td class='param-name'>with_types</td><td class='param-type'>(Optinoal[bool]):</td><td class='param-desc'>If set to True, header will include the data_type of each column.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(RowsInspection): </td><td class='param-desc'>An object which naturally converts to a pretty-print string.</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>To look at the first 4 rows of data in a frame:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect(4)
[#]  animal    name    age  weight
==================================
[0]  human     George    8   542.5
[1]  human     Ursula    6   495.0
[2]  ape       Ape      41   400.0
[3]  elephant  Shep      5  8630.0
</pre></div>


<h1>For other examples, see :ref:<code>example_frame.inspect</code>.</h1>
<p>Note: if the frame data contains unicode characters, this method may raise a Unicode exception when
running in an interactive REPL or otherwise which triggers the standard python repr().  To get around
this problem, explicitly print the unicode of the returned object:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; print unicode(frame.inspect())
</pre></div>


<p><strong>Global Settings</strong></p>
<p>If not specified, the arguments that control formatting receive default values from
'sparktk.inspect_settings'.  Make changes there to affect all calls to inspect.</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sparktk</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span>
<span class="n">wrap</span>             <span class="mi">20</span>
<span class="n">truncate</span>       <span class="bp">None</span>
<span class="nb">round</span>          <span class="bp">None</span>
<span class="n">width</span>            <span class="mi">80</span>
<span class="n">margin</span>         <span class="bp">None</span>
<span class="n">with_types</span>    <span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">120</span>  <span class="c"># changes inspect to use 120 width globally</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">truncate</span> <span class="o">=</span> <span class="mi">16</span>  <span class="c"># changes inspect to always truncate strings to 16 chars</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span>
<span class="n">wrap</span>             <span class="mi">20</span>
<span class="n">truncate</span>         <span class="mi">16</span>
<span class="nb">round</span>          <span class="bp">None</span>
<span class="n">width</span>           <span class="mi">120</span>
<span class="n">margin</span>         <span class="bp">None</span>
<span class="n">with_types</span>    <span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># return value back to default</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span>
<span class="n">wrap</span>             <span class="mi">20</span>
<span class="n">truncate</span>         <span class="mi">16</span>
<span class="nb">round</span>          <span class="bp">None</span>
<span class="n">width</span>            <span class="mi">80</span>
<span class="n">margin</span>         <span class="bp">None</span>
<span class="n">with_types</span>    <span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c"># set everything back to default</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">inspect_settings</span>
<span class="n">wrap</span>             <span class="mi">20</span>
<span class="n">truncate</span>       <span class="bp">None</span>
<span class="nb">round</span>          <span class="bp">None</span>
<span class="n">width</span>            <span class="mi">80</span>
<span class="n">margin</span>         <span class="bp">None</span>
<span class="n">with_types</span>    <span class="bp">False</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.inspect', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.inspect" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">wrap</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">,</span>
            <span class="n">truncate</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">,</span>
            <span class="nb">round</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">,</span>
            <span class="n">margin</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">,</span>
            <span class="n">with_types</span><span class="o">=</span><span class="n">inspect_settings</span><span class="o">.</span><span class="n">_unspecified</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty-print of the frame data</span>

<span class="sd">    Essentially returns a string, but technically returns a RowInspection object which renders a string.</span>
<span class="sd">    The RowInspection object naturally converts to a str when needed, like when printed or when displayed</span>
<span class="sd">    by python REPL (i.e. using the object&#39;s __repr__).  If running in a script and want the inspect output</span>
<span class="sd">    to be printed, then it must be explicitly printed, then `print frame.inspect()`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param n: (Optional[int]) The number of rows to print</span>
<span class="sd">    :param offset: (Optional[int]) The number of rows to skip before printing.</span>
<span class="sd">    :param columns: (Optional[List[str]]) Filter columns to be included.  By default, all columns are included.</span>
<span class="sd">    :param wrap: (Optional[int or &#39;stripes&#39;]) If set to &#39;stripes&#39; then inspect prints rows in stripes; if set to an</span>
<span class="sd">                 integer N, rows will be printed in clumps of N columns, where the columns are wrapped.</span>
<span class="sd">    :param truncate: (Optional[int]) If set to integer N, all strings will be truncated to length N, including all</span>
<span class="sd">                     tagged ellipses.</span>
<span class="sd">    :param round: (Optional[int]) If set to integer N, all floating point numbers will be rounded and truncated to</span>
<span class="sd">                  N digits.</span>
<span class="sd">    :param width: (Optional[int]) If set to integer N, the print out will try to honor a max line width of N.</span>
<span class="sd">    :param margin: (Optional[int]) Applies to &#39;stripes&#39; mode only.  If set to integer N, the margin for printing names</span>
<span class="sd">                   in a stripe will be limited to N characters.</span>
<span class="sd">    :param with_types: (Optinoal[bool]) If set to True, header will include the data_type of each column.</span>
<span class="sd">    :return: (RowsInspection) An object which naturally converts to a pretty-print string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To look at the first 4 rows of data in a frame:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(4)</span>
<span class="sd">        [#]  animal    name    age  weight</span>
<span class="sd">        ==================================</span>
<span class="sd">        [0]  human     George    8   542.5</span>
<span class="sd">        [1]  human     Ursula    6   495.0</span>
<span class="sd">        [2]  ape       Ape      41   400.0</span>
<span class="sd">        [3]  elephant  Shep      5  8630.0</span>

<span class="sd">    # For other examples, see :ref:`example_frame.inspect`.</span>

<span class="sd">    Note: if the frame data contains unicode characters, this method may raise a Unicode exception when</span>
<span class="sd">    running in an interactive REPL or otherwise which triggers the standard python repr().  To get around</span>
<span class="sd">    this problem, explicitly print the unicode of the returned object:</span>

<span class="sd">        &gt;&gt;&gt; print unicode(frame.inspect())</span>


<span class="sd">    **Global Settings**</span>

<span class="sd">    If not specified, the arguments that control formatting receive default values from</span>
<span class="sd">    &#39;sparktk.inspect_settings&#39;.  Make changes there to affect all calls to inspect.</span>

<span class="sd">        &gt;&gt;&gt; import sparktk</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings</span>
<span class="sd">        wrap             20</span>
<span class="sd">        truncate       None</span>
<span class="sd">        round          None</span>
<span class="sd">        width            80</span>
<span class="sd">        margin         None</span>
<span class="sd">        with_types    False</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings.width = 120  # changes inspect to use 120 width globally</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings.truncate = 16  # changes inspect to always truncate strings to 16 chars</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings</span>
<span class="sd">        wrap             20</span>
<span class="sd">        truncate         16</span>
<span class="sd">        round          None</span>
<span class="sd">        width           120</span>
<span class="sd">        margin         None</span>
<span class="sd">        with_types    False</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings.width = None  # return value back to default</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings</span>
<span class="sd">        wrap             20</span>
<span class="sd">        truncate         16</span>
<span class="sd">        round          None</span>
<span class="sd">        width            80</span>
<span class="sd">        margin         None</span>
<span class="sd">        with_types    False</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings.reset()  # set everything back to default</span>
<span class="sd">        &gt;&gt;&gt; sparktk.inspect_settings</span>
<span class="sd">        wrap             20</span>
<span class="sd">        truncate       None</span>
<span class="sd">        round          None</span>
<span class="sd">        width            80</span>
<span class="sd">        margin         None</span>
<span class="sd">        with_types    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.take</span> <span class="kn">import</span> <span class="n">take_rich</span>
    <span class="n">format_settings</span> <span class="o">=</span> <span class="n">inspect_settings</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">wrap</span><span class="p">,</span> <span class="n">truncate</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">with_types</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">take_rich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">RowsInspection</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">format_settings</span><span class="o">=</span><span class="n">format_settings</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.is_python_rdd">
    <p>def <span class="ident">is_python_rdd</span>(</p><p>self, item)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.is_python_rdd', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.is_python_rdd" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">is_python_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">RDD</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.is_scala_dataframe">
    <p>def <span class="ident">is_scala_dataframe</span>(</p><p>self, item)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.is_scala_dataframe', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.is_scala_dataframe" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">is_scala_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.is_scala_rdd">
    <p>def <span class="ident">is_scala_rdd</span>(</p><p>self, item)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.is_scala_rdd', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.is_scala_rdd" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">is_scala_rdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">_jutils</span><span class="o">.</span><span class="n">is_jvm_instance_of</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">RDD</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.join_inner">
    <p>def <span class="ident">join_inner</span>(</p><p>self, right, left_on, right_on=None, use_broadcast=None)</p>
    </div>
    

    
  
    <div class="desc"><p>join_inner performs inner join operation on one or two frames, creating a new frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>right</td><td class='param-type'>(Frame):</td><td class='param-desc'>Another frame to join with
</td></tr></table>

<table><tr><td class='param-name'>left_on</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of the columns in the left frame used to match up the two frames.
</td></tr></table>

<table><tr><td class='param-name'>right_on</td><td class='param-type'>(Optional[List[str]]):</td><td class='param-desc'>Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.
</td></tr></table>

<table><tr><td class='param-name'>use_broadcast</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>If one of your tables is small enough to fit in the memory of a single machine, you can use a broadcast join.
        Specify that table to broadcast (left or right) to possibly improve performance. Default is None.</td></tr></table>

<p>:returns: (Frame) A new frame with the results of the join</p>
<p>Create a new frame from a SQL JOIN operation with another frame.
The frame on the 'left' is the currently active frame.
The frame on the 'right' is another frame.
This method take column(s) in the left frame and matches its values
with column(s) in the right frame.
'inner' join will only allow data in the resultant frame if both the left and right frames have the same value
in the matching column(s).</p>
<div class='section-header'>Notes:</div>

<p>When a column is named the same in both frames, it will result in two
columns in the new frame.
The column from the <em>left</em> frame (originally the current frame) will be
copied and the column name will have the string "_L" added to it.
The same thing will happen with the column from the <em>right</em> frame,
except its name has the string "_R" appended. The order of columns
after this method is called is not guaranteed.</p>
<p>It is recommended that you rename the columns to meaningful terms prior
to using the <code>join</code> method.</p>
<div class='section-header'>Examples:</div>

<p>Consider two frames: codes and colors</p>
<blockquote>
<blockquote>
<blockquote>
<p>codes.inspect()
[#]  numbers
============
[0]        1
[1]        3
[2]        1
[3]        0
[4]        2
[5]        1
[6]        5
[7]        3</p>
<p>colors.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        2  yellow
[2]        3  green
[3]        4  blue</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inner join using hash joins.</p>
<blockquote>
<blockquote>
<blockquote>
<p>j = codes.join_inner(colors, 'numbers')
[===Job Progress===]</p>
<p>j.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        1  red
[2]        1  red
[3]        2  yellow
[4]        3  green
[5]        3  green</p>
</blockquote>
</blockquote>
</blockquote>
<p>(The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</p>
<p>Consider two frames: country_codes_frame and country_names_frame</p>
<blockquote>
<blockquote>
<blockquote>
<p>country_codes_frame.inspect()
[#]  country_code  area_code  test_str
======================================
[0]             1        354  a
[1]             2         91  a
[2]             2        100  b
[3]             3         47  a
[4]             4        968  c
[5]             5         50  c</p>
<p>country_names_frame.inspect()
[#]  country_code  country_name  test_str
=========================================
[0]             1  Iceland       a
[1]             1  Ice-land      a
[2]             2  India         b
[3]             3  Norway        a
[4]             4  Oman          c
[5]             6  Germany       c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Join them on the 'country_code' and 'test_str' columns ('inner' join by default)</p>
<blockquote>
<blockquote>
<blockquote>
<p>composite_join = country_codes_frame.join_inner(country_names_frame, ['country_code', 'test_str'])
[===Job Progress===]</p>
<p>composite_join.inspect()
[#]  country_code  area_code  test_str  country_name
====================================================
[0]             1        354  a         Iceland
[1]             1        354  a         Ice-land
[2]             2        100  b         India
[3]             3         47  a         Norway
[4]             4        968  c         Oman</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inner join broadcasting the left table</p>
<blockquote>
<blockquote>
<blockquote>
<p>j = codes.join_inner(colors, 'numbers',use_broadcast="left")
[===Job Progress===]</p>
<p>j.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        1  red
[2]        1  red
[3]        2  yellow
[4]        3  green
[5]        3  green</p>
<p>composite_join_left = country_codes_frame.join_inner(country_names_frame, ['country_code', 'test_str'],use_broadcast="left")
[===Job Progress===]</p>
<p>composite_join_left.inspect()
[#]  country_code  area_code  test_str  country_name
====================================================
[0]             1        354  a         Iceland
[1]             1        354  a         Ice-land
[2]             2        100  b         India
[3]             3         47  a         Norway
[4]             4        968  c         Oman</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inner join broadcasting right table</p>
<blockquote>
<blockquote>
<blockquote>
<p>j = codes.join_inner(colors, 'numbers',use_broadcast="right")
[===Job Progress===]</p>
<p>j.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        3  green
[2]        1  red
[3]        2  yellow
[4]        1  red
[5]        3  green</p>
<p>composite_join_right = country_codes_frame.join_inner(country_names_frame, ['country_code', 'test_str'],use_broadcast="right")
[===Job Progress===]</p>
<p>composite_join_right.inspect()
[#]  country_code  area_code  test_str  country_name
====================================================
[0]             1        354  a         Iceland
[1]             1        354  a         Ice-land
[2]             2        100  b         India
[3]             3         47  a         Norway
[4]             4        968  c         Oman</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.join_inner', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.join_inner" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">join_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">right</span><span class="p">,</span>
               <span class="n">left_on</span><span class="p">,</span>
               <span class="n">right_on</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">use_broadcast</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    join_inner performs inner join operation on one or two frames, creating a new frame.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param right: (Frame) Another frame to join with</span>
<span class="sd">    :param left_on: (List[str]) Names of the columns in the left frame used to match up the two frames.</span>
<span class="sd">    :param right_on: (Optional[List[str]]) Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.</span>
<span class="sd">    :param use_broadcast: (Optional[str]) If one of your tables is small enough to fit in the memory of a single machine, you can use a broadcast join.</span>
<span class="sd">            Specify that table to broadcast (left or right) to possibly improve performance. Default is None.</span>

<span class="sd">    :returns: (Frame) A new frame with the results of the join</span>

<span class="sd">    Create a new frame from a SQL JOIN operation with another frame.</span>
<span class="sd">    The frame on the &#39;left&#39; is the currently active frame.</span>
<span class="sd">    The frame on the &#39;right&#39; is another frame.</span>
<span class="sd">    This method take column(s) in the left frame and matches its values</span>
<span class="sd">    with column(s) in the right frame.</span>
<span class="sd">    &#39;inner&#39; join will only allow data in the resultant frame if both the left and right frames have the same value</span>
<span class="sd">    in the matching column(s).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When a column is named the same in both frames, it will result in two</span>
<span class="sd">    columns in the new frame.</span>
<span class="sd">    The column from the *left* frame (originally the current frame) will be</span>
<span class="sd">    copied and the column name will have the string &quot;_L&quot; added to it.</span>
<span class="sd">    The same thing will happen with the column from the *right* frame,</span>
<span class="sd">    except its name has the string &quot;_R&quot; appended. The order of columns</span>
<span class="sd">    after this method is called is not guaranteed.</span>

<span class="sd">    It is recommended that you rename the columns to meaningful terms prior</span>
<span class="sd">    to using the ``join`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider two frames: codes and colors</span>

<span class="sd">    &gt;&gt;&gt; codes.inspect()</span>
<span class="sd">    [#]  numbers</span>
<span class="sd">    ============</span>
<span class="sd">    [0]        1</span>
<span class="sd">    [1]        3</span>
<span class="sd">    [2]        1</span>
<span class="sd">    [3]        0</span>
<span class="sd">    [4]        2</span>
<span class="sd">    [5]        1</span>
<span class="sd">    [6]        5</span>
<span class="sd">    [7]        3</span>


<span class="sd">    &gt;&gt;&gt; colors.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        2  yellow</span>
<span class="sd">    [2]        3  green</span>
<span class="sd">    [3]        4  blue</span>

<span class="sd">    Inner join using hash joins.</span>

<span class="sd">    &gt;&gt;&gt; j = codes.join_inner(colors, &#39;numbers&#39;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        1  red</span>
<span class="sd">    [2]        1  red</span>
<span class="sd">    [3]        2  yellow</span>
<span class="sd">    [4]        3  green</span>
<span class="sd">    [5]        3  green</span>

<span class="sd">    (The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</span>

<span class="sd">    Consider two frames: country_codes_frame and country_names_frame</span>

<span class="sd">    &gt;&gt;&gt; country_codes_frame.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str</span>
<span class="sd">    ======================================</span>
<span class="sd">    [0]             1        354  a</span>
<span class="sd">    [1]             2         91  a</span>
<span class="sd">    [2]             2        100  b</span>
<span class="sd">    [3]             3         47  a</span>
<span class="sd">    [4]             4        968  c</span>
<span class="sd">    [5]             5         50  c</span>


<span class="sd">    &gt;&gt;&gt; country_names_frame.inspect()</span>
<span class="sd">    [#]  country_code  country_name  test_str</span>
<span class="sd">    =========================================</span>
<span class="sd">    [0]             1  Iceland       a</span>
<span class="sd">    [1]             1  Ice-land      a</span>
<span class="sd">    [2]             2  India         b</span>
<span class="sd">    [3]             3  Norway        a</span>
<span class="sd">    [4]             4  Oman          c</span>
<span class="sd">    [5]             6  Germany       c</span>

<span class="sd">    Join them on the &#39;country_code&#39; and &#39;test_str&#39; columns (&#39;inner&#39; join by default)</span>

<span class="sd">    &gt;&gt;&gt; composite_join = country_codes_frame.join_inner(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;])</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str  country_name</span>
<span class="sd">    ====================================================</span>
<span class="sd">    [0]             1        354  a         Iceland</span>
<span class="sd">    [1]             1        354  a         Ice-land</span>
<span class="sd">    [2]             2        100  b         India</span>
<span class="sd">    [3]             3         47  a         Norway</span>
<span class="sd">    [4]             4        968  c         Oman</span>


<span class="sd">    Inner join broadcasting the left table</span>

<span class="sd">    &gt;&gt;&gt; j = codes.join_inner(colors, &#39;numbers&#39;,use_broadcast=&quot;left&quot;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        1  red</span>
<span class="sd">    [2]        1  red</span>
<span class="sd">    [3]        2  yellow</span>
<span class="sd">    [4]        3  green</span>
<span class="sd">    [5]        3  green</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left = country_codes_frame.join_inner(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;],use_broadcast=&quot;left&quot;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str  country_name</span>
<span class="sd">    ====================================================</span>
<span class="sd">    [0]             1        354  a         Iceland</span>
<span class="sd">    [1]             1        354  a         Ice-land</span>
<span class="sd">    [2]             2        100  b         India</span>
<span class="sd">    [3]             3         47  a         Norway</span>
<span class="sd">    [4]             4        968  c         Oman</span>

<span class="sd">    Inner join broadcasting right table</span>

<span class="sd">    &gt;&gt;&gt; j = codes.join_inner(colors, &#39;numbers&#39;,use_broadcast=&quot;right&quot;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        3  green</span>
<span class="sd">    [2]        1  red</span>
<span class="sd">    [3]        2  yellow</span>
<span class="sd">    [4]        1  red</span>
<span class="sd">    [5]        3  green</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right = country_codes_frame.join_inner(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;],use_broadcast=&quot;right&quot;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str  country_name</span>
<span class="sd">    ====================================================</span>
<span class="sd">    [0]             1        354  a         Iceland</span>
<span class="sd">    [1]             1        354  a         Ice-land</span>
<span class="sd">    [2]             2        100  b         India</span>
<span class="sd">    [3]             3         47  a         Norway</span>
<span class="sd">    [4]             4        968  c         Oman</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide column name on which join should be performed&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">left_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="n">left_on</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_on</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_on</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide equal number of join columns&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">joinInner</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">_scala</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">left_on</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">right_on</span><span class="p">)),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">use_broadcast</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.join_left">
    <p>def <span class="ident">join_left</span>(</p><p>self, right, left_on, right_on=None, use_broadcast_right=False)</p>
    </div>
    

    
  
    <div class="desc"><p>join_left performs left join(Left outer) operation on one or two frames, creating a new frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>right</td><td class='param-type'>(Frame):</td><td class='param-desc'>Another frame to join with
</td></tr></table>

<table><tr><td class='param-name'>left_on</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of the columns in the left frame used to match up the two frames.
</td></tr></table>

<table><tr><td class='param-name'>right_on</td><td class='param-type'>(Optional[List[str]]):</td><td class='param-desc'>Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.
</td></tr></table>

<table><tr><td class='param-name'>use_broadcast_right</td><td class='param-type'>(bool):</td><td class='param-desc'>If right table is small enough to fit in the memory of a single machine,
        you can set use_broadcast_right to True to possibly improve performance using broadcast join. Default is False.</td></tr></table>

<p>:returns: (Frame) A new frame with the results of the join</p>
<p>Create a new frame from a SQL JOIN operation with another frame.
The frame on the 'left' is the currently active frame.
The frame on the 'right' is another frame.
This method take column(s) in the left frame and matches its values
with column(s) in the right frame.
'left' join will allow any data in the resultant
frame if it exists in the left frame, but will allow any data from the
right frame if it has a value in its column(s) which matches the value in
the left frame column(s).</p>
<div class='section-header'>Notes:</div>

<p>When a column is named the same in both frames, it will result in two
columns in the new frame.
The column from the <em>left</em> frame (originally the current frame) will be
copied and the column name will have the string "_L" added to it.
The same thing will happen with the column from the <em>right</em> frame,
except its name has the string "_R" appended. The order of columns
after this method is called is not guaranteed.</p>
<p>It is recommended that you rename the columns to meaningful terms prior
to using the <code>join</code> method.</p>
<div class='section-header'>Examples:</div>

<p>Consider two frames: codes and colors</p>
<blockquote>
<blockquote>
<blockquote>
<p>codes.inspect()
[#]  numbers
============
[0]        1
[1]        3
[2]        1
[3]        0
[4]        2
[5]        1
[6]        5
[7]        3</p>
<p>colors.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        2  yellow
[2]        3  green
[3]        4  blue</p>
<p>j_left = codes.join_left(colors, 'numbers')
[===Job Progress===]</p>
<p>j_left.inspect()
[#]  numbers_L  color
======================
[0]          0  None
[1]          1  red
[2]          1  red
[3]          1  red
[4]          2  yellow
[5]          3  green
[6]          3  green
[7]          5  None</p>
</blockquote>
</blockquote>
</blockquote>
<p>(The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</p>
<p>Consider two frames: country_codes_frame and country_names_frame</p>
<blockquote>
<blockquote>
<blockquote>
<p>country_codes_frame.inspect()
[#]  country_code  area_code  test_str
======================================
[0]             1        354  a
[1]             2         91  a
[2]             2        100  b
[3]             3         47  a
[4]             4        968  c
[5]             5         50  c</p>
<p>country_names_frame.inspect()
[#]  country_code  country_name  test_str
=========================================
[0]             1  Iceland       a
[1]             1  Ice-land      a
[2]             2  India         b
[3]             3  Norway        a
[4]             4  Oman          c
[5]             6  Germany       c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Join them on the 'country_code' and 'test_str' columns  ('inner' join by default)</p>
<blockquote>
<blockquote>
<blockquote>
<p>composite_join_left = country_codes_frame.join_left(country_names_frame, ['country_code', 'test_str'])
[===Job Progress===]</p>
<p>composite_join_left.inspect()
[#]  country_code_L  area_code  test_str_L  country_name
========================================================
[0]               1        354  a           Iceland
[1]               1        354  a           Ice-land
[2]               2         91  a           None
[3]               2        100  b           India
[4]               3         47  a           Norway
[5]               4        968  c           Oman
[6]               5         50  c           None</p>
</blockquote>
</blockquote>
</blockquote>
<p>Left join broadcasting right table</p>
<blockquote>
<blockquote>
<blockquote>
<p>j_left = codes.join_left(colors, 'numbers', use_broadcast_right=True)
[===Job Progress===]</p>
<p>j_left.inspect()
[#]  numbers_L  color
======================
[0]          1  red
[1]          3  green
[2]          1  red
[3]          0  None
[4]          2  yellow
[5]          1  red
[6]          5  None
[7]          3  green</p>
<p>composite_join_left = country_codes_frame.join_left(country_names_frame, ['country_code', 'test_str'], use_broadcast_right=True)
[===Job Progress===]</p>
<p>composite_join_left.inspect()
[#]  country_code_L  area_code  test_str_L  country_name
========================================================
[0]               1        354  a           Iceland
[1]               1        354  a           Ice-land
[2]               2         91  a           None
[3]               2        100  b           India
[4]               3         47  a           Norway
[5]               4        968  c           Oman
[6]               5         50  c           None</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.join_left', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.join_left" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">join_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">right</span><span class="p">,</span>
              <span class="n">left_on</span><span class="p">,</span>
              <span class="n">right_on</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">use_broadcast_right</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    join_left performs left join(Left outer) operation on one or two frames, creating a new frame.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>

<span class="sd">    :param right: (Frame) Another frame to join with</span>
<span class="sd">    :param left_on: (List[str]) Names of the columns in the left frame used to match up the two frames.</span>
<span class="sd">    :param right_on: (Optional[List[str]]) Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.</span>
<span class="sd">    :param use_broadcast_right: (bool) If right table is small enough to fit in the memory of a single machine,</span>
<span class="sd">            you can set use_broadcast_right to True to possibly improve performance using broadcast join. Default is False.</span>

<span class="sd">    :returns: (Frame) A new frame with the results of the join</span>

<span class="sd">    Create a new frame from a SQL JOIN operation with another frame.</span>
<span class="sd">    The frame on the &#39;left&#39; is the currently active frame.</span>
<span class="sd">    The frame on the &#39;right&#39; is another frame.</span>
<span class="sd">    This method take column(s) in the left frame and matches its values</span>
<span class="sd">    with column(s) in the right frame.</span>
<span class="sd">    &#39;left&#39; join will allow any data in the resultant</span>
<span class="sd">    frame if it exists in the left frame, but will allow any data from the</span>
<span class="sd">    right frame if it has a value in its column(s) which matches the value in</span>
<span class="sd">    the left frame column(s).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When a column is named the same in both frames, it will result in two</span>
<span class="sd">    columns in the new frame.</span>
<span class="sd">    The column from the *left* frame (originally the current frame) will be</span>
<span class="sd">    copied and the column name will have the string &quot;_L&quot; added to it.</span>
<span class="sd">    The same thing will happen with the column from the *right* frame,</span>
<span class="sd">    except its name has the string &quot;_R&quot; appended. The order of columns</span>
<span class="sd">    after this method is called is not guaranteed.</span>

<span class="sd">    It is recommended that you rename the columns to meaningful terms prior</span>
<span class="sd">    to using the ``join`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider two frames: codes and colors</span>

<span class="sd">    &gt;&gt;&gt; codes.inspect()</span>
<span class="sd">    [#]  numbers</span>
<span class="sd">    ============</span>
<span class="sd">    [0]        1</span>
<span class="sd">    [1]        3</span>
<span class="sd">    [2]        1</span>
<span class="sd">    [3]        0</span>
<span class="sd">    [4]        2</span>
<span class="sd">    [5]        1</span>
<span class="sd">    [6]        5</span>
<span class="sd">    [7]        3</span>


<span class="sd">    &gt;&gt;&gt; colors.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        2  yellow</span>
<span class="sd">    [2]        3  green</span>
<span class="sd">    [3]        4  blue</span>

<span class="sd">    &gt;&gt;&gt; j_left = codes.join_left(colors, &#39;numbers&#39;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j_left.inspect()</span>
<span class="sd">    [#]  numbers_L  color</span>
<span class="sd">    ======================</span>
<span class="sd">    [0]          0  None</span>
<span class="sd">    [1]          1  red</span>
<span class="sd">    [2]          1  red</span>
<span class="sd">    [3]          1  red</span>
<span class="sd">    [4]          2  yellow</span>
<span class="sd">    [5]          3  green</span>
<span class="sd">    [6]          3  green</span>
<span class="sd">    [7]          5  None</span>

<span class="sd">    (The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</span>

<span class="sd">    Consider two frames: country_codes_frame and country_names_frame</span>

<span class="sd">    &gt;&gt;&gt; country_codes_frame.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str</span>
<span class="sd">    ======================================</span>
<span class="sd">    [0]             1        354  a</span>
<span class="sd">    [1]             2         91  a</span>
<span class="sd">    [2]             2        100  b</span>
<span class="sd">    [3]             3         47  a</span>
<span class="sd">    [4]             4        968  c</span>
<span class="sd">    [5]             5         50  c</span>


<span class="sd">    &gt;&gt;&gt; country_names_frame.inspect()</span>
<span class="sd">    [#]  country_code  country_name  test_str</span>
<span class="sd">    =========================================</span>
<span class="sd">    [0]             1  Iceland       a</span>
<span class="sd">    [1]             1  Ice-land      a</span>
<span class="sd">    [2]             2  India         b</span>
<span class="sd">    [3]             3  Norway        a</span>
<span class="sd">    [4]             4  Oman          c</span>
<span class="sd">    [5]             6  Germany       c</span>

<span class="sd">    Join them on the &#39;country_code&#39; and &#39;test_str&#39; columns  (&#39;inner&#39; join by default)</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left = country_codes_frame.join_left(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;])</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left.inspect()</span>
<span class="sd">    [#]  country_code_L  area_code  test_str_L  country_name</span>
<span class="sd">    ========================================================</span>
<span class="sd">    [0]               1        354  a           Iceland</span>
<span class="sd">    [1]               1        354  a           Ice-land</span>
<span class="sd">    [2]               2         91  a           None</span>
<span class="sd">    [3]               2        100  b           India</span>
<span class="sd">    [4]               3         47  a           Norway</span>
<span class="sd">    [5]               4        968  c           Oman</span>
<span class="sd">    [6]               5         50  c           None</span>

<span class="sd">    Left join broadcasting right table</span>

<span class="sd">    &gt;&gt;&gt; j_left = codes.join_left(colors, &#39;numbers&#39;, use_broadcast_right=True)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j_left.inspect()</span>
<span class="sd">    [#]  numbers_L  color</span>
<span class="sd">    ======================</span>
<span class="sd">    [0]          1  red</span>
<span class="sd">    [1]          3  green</span>
<span class="sd">    [2]          1  red</span>
<span class="sd">    [3]          0  None</span>
<span class="sd">    [4]          2  yellow</span>
<span class="sd">    [5]          1  red</span>
<span class="sd">    [6]          5  None</span>
<span class="sd">    [7]          3  green</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left = country_codes_frame.join_left(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;], use_broadcast_right=True)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_left.inspect()</span>
<span class="sd">    [#]  country_code_L  area_code  test_str_L  country_name</span>
<span class="sd">    ========================================================</span>
<span class="sd">    [0]               1        354  a           Iceland</span>
<span class="sd">    [1]               1        354  a           Ice-land</span>
<span class="sd">    [2]               2         91  a           None</span>
<span class="sd">    [3]               2        100  b           India</span>
<span class="sd">    [4]               3         47  a           Norway</span>
<span class="sd">    [5]               4        968  c           Oman</span>
<span class="sd">    [6]               5         50  c           None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide column name on which join should be performed&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">left_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="n">left_on</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_on</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_on</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide equal number of join columns&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">joinLeft</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">_scala</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">left_on</span><span class="p">),</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">right_on</span><span class="p">)),</span>
                                                <span class="n">use_broadcast_right</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.join_outer">
    <p>def <span class="ident">join_outer</span>(</p><p>self, right, left_on, right_on=None)</p>
    </div>
    

    
  
    <div class="desc"><p>join_outer performs outer join operation on one or two frames, creating a new frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>right</td><td class='param-type'>(Frame):</td><td class='param-desc'>Another frame to join with
</td></tr></table>

<table><tr><td class='param-name'>left_on</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of the columns in the left frame used to match up the two frames.
</td></tr></table>

<table><tr><td class='param-name'>right_on</td><td class='param-type'>(Optional[List[str]]):</td><td class='param-desc'>Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.</td></tr></table>

<p>:returns: (Frame) A new frame with the results of the join</p>
<p>Create a new frame from a SQL JOIN operation with another frame.
The frame on the 'left' is the currently active frame.
The frame on the 'right' is another frame.
This method take column(s) in the left frame and matches its values
with column(s) in the right frame.
The 'outer' join provides a frame with data from both frames where
the left and right frames did not have the same value in the matching
column(s).</p>
<div class='section-header'>Notes:</div>

<p>When a column is named the same in both frames, it will result in two
columns in the new frame.
The column from the <em>left</em> frame (originally the current frame) will be
copied and the column name will have the string "_L" added to it.
The same thing will happen with the column from the <em>right</em> frame,
except its name has the string "_R" appended. The order of columns
after this method is called is not guaranteed.</p>
<p>It is recommended that you rename the columns to meaningful terms prior
to using the <code>join</code> method.</p>
<div class='section-header'>Examples:</div>

<p>Consider two frames: codes and colors</p>
<blockquote>
<blockquote>
<blockquote>
<p>codes.inspect()
[#]  numbers
============
[0]        1
[1]        3
[2]        1
[3]        0
[4]        2
[5]        1
[6]        5
[7]        3</p>
<p>colors.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        2  yellow
[2]        3  green
[3]        4  blue</p>
</blockquote>
</blockquote>
</blockquote>
<p>Join them on the 'numbers' column ('inner' join by default)</p>
<blockquote>
<blockquote>
<blockquote>
<p>j_outer = codes.join_outer(colors, 'numbers')
[===Job Progress===]</p>
<p>j_outer.inspect()
[#]  numbers_L  color
======================
[0]          0  None
[1]          1  red
[2]          1  red
[3]          1  red
[4]          2  yellow
[5]          3  green
[6]          3  green
[7]          4  blue
[8]          5  None</p>
</blockquote>
</blockquote>
</blockquote>
<p>(The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</p>
<p>Consider two frames: country_codes_frame and country_names_frame</p>
<blockquote>
<blockquote>
<blockquote>
<p>country_codes_frame.inspect()
[#]  country_code  area_code  test_str
======================================
[0]             1        354  a
[1]             2         91  a
[2]             2        100  b
[3]             3         47  a
[4]             4        968  c
[5]             5         50  c</p>
<p>country_names_frame.inspect()
[#]  country_code  country_name  test_str
=========================================
[0]             1  Iceland       a
[1]             1  Ice-land      a
[2]             2  India         b
[3]             3  Norway        a
[4]             4  Oman          c
[5]             6  Germany       c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Join them on the 'country_code' and 'test_str' columns  ('inner' join by default)</p>
<blockquote>
<blockquote>
<blockquote>
<p>composite_join_outer = country_codes_frame.join_outer(country_names_frame, ['country_code', 'test_str'])
[===Job Progress===]</p>
<p>composite_join_outer.inspect()
[#]  country_code_L  area_code  test_str_L  country_name
========================================================
[0]               6       None  c           Germany
[1]               1        354  a           Iceland
[2]               1        354  a           Ice-land
[3]               2         91  a           None
[4]               2        100  b           India
[5]               3         47  a           Norway
[6]               4        968  c           Oman
[7]               5         50  c           None</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.join_outer', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.join_outer" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">join_outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">right</span><span class="p">,</span>
               <span class="n">left_on</span><span class="p">,</span>
               <span class="n">right_on</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    join_outer performs outer join operation on one or two frames, creating a new frame.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param right: (Frame) Another frame to join with</span>
<span class="sd">    :param left_on: (List[str]) Names of the columns in the left frame used to match up the two frames.</span>
<span class="sd">    :param right_on: (Optional[List[str]]) Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.</span>

<span class="sd">    :returns: (Frame) A new frame with the results of the join</span>

<span class="sd">    Create a new frame from a SQL JOIN operation with another frame.</span>
<span class="sd">    The frame on the &#39;left&#39; is the currently active frame.</span>
<span class="sd">    The frame on the &#39;right&#39; is another frame.</span>
<span class="sd">    This method take column(s) in the left frame and matches its values</span>
<span class="sd">    with column(s) in the right frame.</span>
<span class="sd">    The &#39;outer&#39; join provides a frame with data from both frames where</span>
<span class="sd">    the left and right frames did not have the same value in the matching</span>
<span class="sd">    column(s).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When a column is named the same in both frames, it will result in two</span>
<span class="sd">    columns in the new frame.</span>
<span class="sd">    The column from the *left* frame (originally the current frame) will be</span>
<span class="sd">    copied and the column name will have the string &quot;_L&quot; added to it.</span>
<span class="sd">    The same thing will happen with the column from the *right* frame,</span>
<span class="sd">    except its name has the string &quot;_R&quot; appended. The order of columns</span>
<span class="sd">    after this method is called is not guaranteed.</span>

<span class="sd">    It is recommended that you rename the columns to meaningful terms prior</span>
<span class="sd">    to using the ``join`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider two frames: codes and colors</span>

<span class="sd">    &gt;&gt;&gt; codes.inspect()</span>
<span class="sd">    [#]  numbers</span>
<span class="sd">    ============</span>
<span class="sd">    [0]        1</span>
<span class="sd">    [1]        3</span>
<span class="sd">    [2]        1</span>
<span class="sd">    [3]        0</span>
<span class="sd">    [4]        2</span>
<span class="sd">    [5]        1</span>
<span class="sd">    [6]        5</span>
<span class="sd">    [7]        3</span>


<span class="sd">    &gt;&gt;&gt; colors.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        2  yellow</span>
<span class="sd">    [2]        3  green</span>
<span class="sd">    [3]        4  blue</span>


<span class="sd">    Join them on the &#39;numbers&#39; column (&#39;inner&#39; join by default)</span>

<span class="sd">    &gt;&gt;&gt; j_outer = codes.join_outer(colors, &#39;numbers&#39;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j_outer.inspect()</span>
<span class="sd">    [#]  numbers_L  color</span>
<span class="sd">    ======================</span>
<span class="sd">    [0]          0  None</span>
<span class="sd">    [1]          1  red</span>
<span class="sd">    [2]          1  red</span>
<span class="sd">    [3]          1  red</span>
<span class="sd">    [4]          2  yellow</span>
<span class="sd">    [5]          3  green</span>
<span class="sd">    [6]          3  green</span>
<span class="sd">    [7]          4  blue</span>
<span class="sd">    [8]          5  None</span>


<span class="sd">    (The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</span>

<span class="sd">    Consider two frames: country_codes_frame and country_names_frame</span>

<span class="sd">    &gt;&gt;&gt; country_codes_frame.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str</span>
<span class="sd">    ======================================</span>
<span class="sd">    [0]             1        354  a</span>
<span class="sd">    [1]             2         91  a</span>
<span class="sd">    [2]             2        100  b</span>
<span class="sd">    [3]             3         47  a</span>
<span class="sd">    [4]             4        968  c</span>
<span class="sd">    [5]             5         50  c</span>


<span class="sd">    &gt;&gt;&gt; country_names_frame.inspect()</span>
<span class="sd">    [#]  country_code  country_name  test_str</span>
<span class="sd">    =========================================</span>
<span class="sd">    [0]             1  Iceland       a</span>
<span class="sd">    [1]             1  Ice-land      a</span>
<span class="sd">    [2]             2  India         b</span>
<span class="sd">    [3]             3  Norway        a</span>
<span class="sd">    [4]             4  Oman          c</span>
<span class="sd">    [5]             6  Germany       c</span>

<span class="sd">    Join them on the &#39;country_code&#39; and &#39;test_str&#39; columns  (&#39;inner&#39; join by default)</span>

<span class="sd">    &gt;&gt;&gt; composite_join_outer = country_codes_frame.join_outer(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;])</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_outer.inspect()</span>
<span class="sd">    [#]  country_code_L  area_code  test_str_L  country_name</span>
<span class="sd">    ========================================================</span>
<span class="sd">    [0]               6       None  c           Germany</span>
<span class="sd">    [1]               1        354  a           Iceland</span>
<span class="sd">    [2]               1        354  a           Ice-land</span>
<span class="sd">    [3]               2         91  a           None</span>
<span class="sd">    [4]               2        100  b           India</span>
<span class="sd">    [5]               3         47  a           Norway</span>
<span class="sd">    [6]               4        968  c           Oman</span>
<span class="sd">    [7]               5         50  c           None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide column name on which join should be performed&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">left_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="n">left_on</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_on</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_on</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide equal number of join columns&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">joinOuter</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">_scala</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">left_on</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">right_on</span><span class="p">))))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.join_right">
    <p>def <span class="ident">join_right</span>(</p><p>self, right, left_on, right_on=None, use_broadcast_left=False)</p>
    </div>
    

    
  
    <div class="desc"><p>join_right performs right join(right outer) operation on one or two frames, creating a new frame.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>right</td><td class='param-type'>(Frame):</td><td class='param-desc'>Another frame to join with
</td></tr></table>

<table><tr><td class='param-name'>left_on</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Names of the columns in the left frame used to match up the two frames.
</td></tr></table>

<table><tr><td class='param-name'>right_on</td><td class='param-type'>(Optional[List[str]])Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.
<table><tr><td class='param-name'>use_broadcast_left: </td><td class='param-desc'>(bool):</td><td class='param-desc'>If left table is small enough to fit in the memory of a single machine,
        you can set use_broadcast_left to True to possibly improve performance using broadcast join. Default is False.</td></tr></table></td></tr></table>

<p>:returns: (Frame) A new frame with the results of the join</p>
<p>Create a new frame from a SQL JOIN operation with another frame.
The frame on the 'left' is the currently active frame.
The frame on the 'right' is another frame.
This method take column(s) in the left frame and matches its values
with column(s) in the right frame.
'right' join works similarly to join_left, except it keeps all the data
from the right frame and only the data from the left frame when it
matches.</p>
<div class='section-header'>Notes:</div>

<p>When a column is named the same in both frames, it will result in two
columns in the new frame.
The column from the <em>left</em> frame (originally the current frame) will be
copied and the column name will have the string "_L" added to it.
The same thing will happen with the column from the <em>right</em> frame,
except its name has the string "_R" appended. The order of columns
after this method is called is not guaranteed.</p>
<p>It is recommended that you rename the columns to meaningful terms prior
to using the <code>join</code> method.</p>
<div class='section-header'>Examples:</div>

<p>Consider two frames: codes and colors</p>
<blockquote>
<blockquote>
<blockquote>
<p>codes.inspect()
[#]  numbers
============
[0]        1
[1]        3
[2]        1
[3]        0
[4]        2
[5]        1
[6]        5
[7]        3</p>
<p>colors.inspect()
[#]  numbers  color
====================
[0]        1  red
[1]        2  yellow
[2]        3  green
[3]        4  blue</p>
<p>j_right = codes.join_right(colors, 'numbers')
[===Job Progress===]</p>
<p>j_right.inspect()
[#]  numbers_R  color
======================
[0]          1  red
[1]          1  red
[2]          1  red
[3]          2  yellow
[4]          3  green
[5]          3  green
[6]          4  blue</p>
</blockquote>
</blockquote>
</blockquote>
<p>(The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</p>
<p>Consider two frames: country_codes_frame and country_names_frame</p>
<blockquote>
<blockquote>
<blockquote>
<p>country_codes_frame.inspect()
[#]  country_code  area_code  test_str
======================================
[0]             1        354  a
[1]             2         91  a
[2]             2        100  b
[3]             3         47  a
[4]             4        968  c
[5]             5         50  c</p>
<p>country_names_frame.inspect()
[#]  country_code  country_name  test_str
=========================================
[0]             1  Iceland       a
[1]             1  Ice-land      a
[2]             2  India         b
[3]             3  Norway        a
[4]             4  Oman          c
[5]             6  Germany       c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Join them on the 'country_code' and 'test_str' columns ('inner' join by default)</p>
<blockquote>
<blockquote>
<blockquote>
<p>composite_join_right = country_codes_frame.join_right(country_names_frame, ['country_code', 'test_str'])
[===Job Progress===]</p>
<p>composite_join_right.inspect()
[#]  area_code  country_code_R  country_name  test_str_R
========================================================
[0]       None               6  Germany       c
[1]        354               1  Iceland       a
[2]        354               1  Ice-land      a
[3]        100               2  India         b
[4]         47               3  Norway        a
[5]        968               4  Oman          c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Right join broadcasting left table</p>
<blockquote>
<blockquote>
<blockquote>
<p>j_right = codes.join_right(colors, 'numbers', use_broadcast_left=True)
[===Job Progress===]</p>
<p>j_right.inspect()
[#]  numbers_R  color
======================
[0]          1  red
[1]          1  red
[2]          1  red
[3]          2  yellow
[4]          3  green
[5]          3  green
[6]          4  blue</p>
<p>composite_join_right = country_codes_frame.join_right(country_names_frame, ['country_code', 'test_str'], use_broadcast_left=True)
[===Job Progress===]</p>
<p>composite_join_right.inspect()
[#]  area_code  country_code_R  country_name  test_str_R
========================================================
[0]        354               1  Iceland       a
[1]        354               1  Ice-land      a
[2]        100               2  India         b
[3]         47               3  Norway        a
[4]        968               4  Oman          c
[5]       None               6  Germany       c</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.join_right', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.join_right" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">join_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">right</span><span class="p">,</span>
              <span class="n">left_on</span><span class="p">,</span>
              <span class="n">right_on</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">use_broadcast_left</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    join_right performs right join(right outer) operation on one or two frames, creating a new frame.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param right: (Frame) Another frame to join with</span>
<span class="sd">    :param left_on: (List[str]) Names of the columns in the left frame used to match up the two frames.</span>
<span class="sd">    :param right_on: (Optional[List[str]])Names of the columns in the right frame used to match up the two frames. Default is the same as the left frame.</span>
<span class="sd">    :param use_broadcast_left: (bool) If left table is small enough to fit in the memory of a single machine,</span>
<span class="sd">            you can set use_broadcast_left to True to possibly improve performance using broadcast join. Default is False.</span>

<span class="sd">    :returns: (Frame) A new frame with the results of the join</span>

<span class="sd">    Create a new frame from a SQL JOIN operation with another frame.</span>
<span class="sd">    The frame on the &#39;left&#39; is the currently active frame.</span>
<span class="sd">    The frame on the &#39;right&#39; is another frame.</span>
<span class="sd">    This method take column(s) in the left frame and matches its values</span>
<span class="sd">    with column(s) in the right frame.</span>
<span class="sd">    &#39;right&#39; join works similarly to join_left, except it keeps all the data</span>
<span class="sd">    from the right frame and only the data from the left frame when it</span>
<span class="sd">    matches.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When a column is named the same in both frames, it will result in two</span>
<span class="sd">    columns in the new frame.</span>
<span class="sd">    The column from the *left* frame (originally the current frame) will be</span>
<span class="sd">    copied and the column name will have the string &quot;_L&quot; added to it.</span>
<span class="sd">    The same thing will happen with the column from the *right* frame,</span>
<span class="sd">    except its name has the string &quot;_R&quot; appended. The order of columns</span>
<span class="sd">    after this method is called is not guaranteed.</span>

<span class="sd">    It is recommended that you rename the columns to meaningful terms prior</span>
<span class="sd">    to using the ``join`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider two frames: codes and colors</span>

<span class="sd">    &gt;&gt;&gt; codes.inspect()</span>
<span class="sd">    [#]  numbers</span>
<span class="sd">    ============</span>
<span class="sd">    [0]        1</span>
<span class="sd">    [1]        3</span>
<span class="sd">    [2]        1</span>
<span class="sd">    [3]        0</span>
<span class="sd">    [4]        2</span>
<span class="sd">    [5]        1</span>
<span class="sd">    [6]        5</span>
<span class="sd">    [7]        3</span>


<span class="sd">    &gt;&gt;&gt; colors.inspect()</span>
<span class="sd">    [#]  numbers  color</span>
<span class="sd">    ====================</span>
<span class="sd">    [0]        1  red</span>
<span class="sd">    [1]        2  yellow</span>
<span class="sd">    [2]        3  green</span>
<span class="sd">    [3]        4  blue</span>

<span class="sd">    &gt;&gt;&gt; j_right = codes.join_right(colors, &#39;numbers&#39;)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j_right.inspect()</span>
<span class="sd">    [#]  numbers_R  color</span>
<span class="sd">    ======================</span>
<span class="sd">    [0]          1  red</span>
<span class="sd">    [1]          1  red</span>
<span class="sd">    [2]          1  red</span>
<span class="sd">    [3]          2  yellow</span>
<span class="sd">    [4]          3  green</span>
<span class="sd">    [5]          3  green</span>
<span class="sd">    [6]          4  blue</span>


<span class="sd">    (The join adds an extra column *_R which is the join column from the right frame; it may be disregarded)</span>

<span class="sd">    Consider two frames: country_codes_frame and country_names_frame</span>

<span class="sd">    &gt;&gt;&gt; country_codes_frame.inspect()</span>
<span class="sd">    [#]  country_code  area_code  test_str</span>
<span class="sd">    ======================================</span>
<span class="sd">    [0]             1        354  a</span>
<span class="sd">    [1]             2         91  a</span>
<span class="sd">    [2]             2        100  b</span>
<span class="sd">    [3]             3         47  a</span>
<span class="sd">    [4]             4        968  c</span>
<span class="sd">    [5]             5         50  c</span>


<span class="sd">    &gt;&gt;&gt; country_names_frame.inspect()</span>
<span class="sd">    [#]  country_code  country_name  test_str</span>
<span class="sd">    =========================================</span>
<span class="sd">    [0]             1  Iceland       a</span>
<span class="sd">    [1]             1  Ice-land      a</span>
<span class="sd">    [2]             2  India         b</span>
<span class="sd">    [3]             3  Norway        a</span>
<span class="sd">    [4]             4  Oman          c</span>
<span class="sd">    [5]             6  Germany       c</span>

<span class="sd">    Join them on the &#39;country_code&#39; and &#39;test_str&#39; columns (&#39;inner&#39; join by default)</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right = country_codes_frame.join_right(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;])</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right.inspect()</span>
<span class="sd">    [#]  area_code  country_code_R  country_name  test_str_R</span>
<span class="sd">    ========================================================</span>
<span class="sd">    [0]       None               6  Germany       c</span>
<span class="sd">    [1]        354               1  Iceland       a</span>
<span class="sd">    [2]        354               1  Ice-land      a</span>
<span class="sd">    [3]        100               2  India         b</span>
<span class="sd">    [4]         47               3  Norway        a</span>
<span class="sd">    [5]        968               4  Oman          c</span>

<span class="sd">    Right join broadcasting left table</span>

<span class="sd">    &gt;&gt;&gt; j_right = codes.join_right(colors, &#39;numbers&#39;, use_broadcast_left=True)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; j_right.inspect()</span>
<span class="sd">    [#]  numbers_R  color</span>
<span class="sd">    ======================</span>
<span class="sd">    [0]          1  red</span>
<span class="sd">    [1]          1  red</span>
<span class="sd">    [2]          1  red</span>
<span class="sd">    [3]          2  yellow</span>
<span class="sd">    [4]          3  green</span>
<span class="sd">    [5]          3  green</span>
<span class="sd">    [6]          4  blue</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right = country_codes_frame.join_right(country_names_frame, [&#39;country_code&#39;, &#39;test_str&#39;], use_broadcast_left=True)</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    &gt;&gt;&gt; composite_join_right.inspect()</span>
<span class="sd">    [#]  area_code  country_code_R  country_name  test_str_R</span>
<span class="sd">    ========================================================</span>
<span class="sd">    [0]        354               1  Iceland       a</span>
<span class="sd">    [1]        354               1  Ice-land      a</span>
<span class="sd">    [2]        100               2  India         b</span>
<span class="sd">    [3]         47               3  Norway        a</span>
<span class="sd">    [4]        968               4  Oman          c</span>
<span class="sd">    [5]       None               6  Germany       c</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide column name on which join should be performed&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">left_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="n">left_on</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_on</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">right_on</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_on</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_on</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_on</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Please provide equal number of join columns&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">joinRight</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">_scala</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">left_on</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">right_on</span><span class="p">)),</span>
                                                 <span class="n">use_broadcast_left</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.map_columns">
    <p>def <span class="ident">map_columns</span>(</p><p>self, func, schema)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a new frame from the output of a UDF which over each row of the current frame.</p>
<div class='section-header'>Notes:</div>

<ol>
<li>The row |UDF| ('func') must return a value in the same format as
    specified by the schema.</li>
</ol>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>func</td><td class='param-type'>(UDF):</td><td class='param-desc'>Function which takes the values in the row and produces a value, or collection of values, for the new cell(s).
</td></tr></table>

<table><tr><td class='param-name'>schema</td><td class='param-type'>(List[(str,type)]):</td><td class='param-desc'>Schema for the column(s) being added.</td></tr></table>

<div class='section-header'>Examples:</div>

<p>Given our frame, let's create a new frame with the name and a column with how many years the person has been over 18</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],
...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],
...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],
...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],
...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])

&gt;&gt;&gt; frame.inspect()
[#]  name      age  tenure  phone
====================================
[0]  Fred       39      16  555-1234
[1]  Susan      33       3  555-0202
[2]  Thurston   65      26  555-4510
[3]  Judy       44      14  555-2183

&gt;&gt;&gt; adult = frame.map_columns(lambda row: [row.name, row.age - 18], [(&#39;name&#39;, str), (&#39;adult_years&#39;, int)])

&gt;&gt;&gt; adult.inspect()
[#]  name      adult_years
==========================
[0]  Fred               21
[1]  Susan              15
[2]  Thurston           47
[3]  Judy               26
</pre></div>


<p>Note that the function returns a list, and therefore the schema also needs to be a list.</p>
<p>It is not necessary to use lambda syntax, any function will do, as long as it takes a single row argument.  We
can also call other local functions within.</p>
<p>(see also the 'add_columns' frame operation)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.map_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.map_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">map_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new frame from the output of a UDF which over each row of the current frame.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    1.  The row |UDF| (&#39;func&#39;) must return a value in the same format as</span>
<span class="sd">        specified by the schema.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param func: (UDF) Function which takes the values in the row and produces a value, or collection of values, for the new cell(s).</span>
<span class="sd">    :param schema: (List[(str,type)]) Schema for the column(s) being added.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given our frame, let&#39;s create a new frame with the name and a column with how many years the person has been over 18</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[&#39;Fred&#39;,39,16,&#39;555-1234&#39;],</span>
<span class="sd">        ...                          [&#39;Susan&#39;,33,3,&#39;555-0202&#39;],</span>
<span class="sd">        ...                          [&#39;Thurston&#39;,65,26,&#39;555-4510&#39;],</span>
<span class="sd">        ...                          [&#39;Judy&#39;,44,14,&#39;555-2183&#39;]],</span>
<span class="sd">        ...                         schema=[(&#39;name&#39;, str), (&#39;age&#39;, int), (&#39;tenure&#39;, int), (&#39;phone&#39;, str)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">        &gt;&gt;&gt; adult = frame.map_columns(lambda row: [row.name, row.age - 18], [(&#39;name&#39;, str), (&#39;adult_years&#39;, int)])</span>

<span class="sd">        &gt;&gt;&gt; adult.inspect()</span>
<span class="sd">        [#]  name      adult_years</span>
<span class="sd">        ==========================</span>
<span class="sd">        [0]  Fred               21</span>
<span class="sd">        [1]  Susan              15</span>
<span class="sd">        [2]  Thurston           47</span>
<span class="sd">        [3]  Judy               26</span>


<span class="sd">    Note that the function returns a list, and therefore the schema also needs to be a list.</span>

<span class="sd">    It is not necessary to use lambda syntax, any function will do, as long as it takes a single row argument.  We</span>
<span class="sd">    can also call other local functions within.</span>

<span class="sd">    (see also the &#39;add_columns&#39; frame operation)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">schema_helper</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">row</span><span class="o">.</span><span class="n">_set_data</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">map_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="p">[</span><span class="n">map_columns_func</span><span class="p">(</span><span class="n">r</span><span class="p">)])</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.matrix_covariance_matrix">
    <p>def <span class="ident">matrix_covariance_matrix</span>(</p><p>self, matrix_column_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the Covariance Matrix of matrices stored in a frame</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>matrix_column_name: </td><td class='param-desc'>Name of the column to compute the covariance matrix on
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns the frame with a new column storing the covariance matrix for the corresponding matrix</td></tr></table></p>

<p>Calculate the covariance matrix for each matrix in column 'matrix_column_name' of a frame using the following:</p>
<p>Element (i,j) of the covariance matrix for a given matrix X is computed as: ((Xi - Mi)(Xj - Mj))
where Mi is the mean</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">schema</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">matrix</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>


<span class="n">Compute</span> <span class="n">the</span> <span class="n">covariance</span> <span class="n">matrix</span> <span class="k">for</span> <span class="n">the</span> <span class="n">matrices</span> <span class="ow">in</span> <span class="s">&#39;pixeldata&#39;</span> <span class="n">column</span> <span class="n">of</span> <span class="n">the</span> <span class="n">frame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">matrix_covariance_matrix</span><span class="p">(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">)</span>

<span class="n">A</span> <span class="n">new</span> <span class="n">column</span> <span class="n">gets</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">existing</span> <span class="n">frame</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">covariance</span> <span class="n">matrix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  CovarianceMatrix_pixeldata</span>
<span class="o">============================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span>  <span class="mf">2.91666667</span>   <span class="mf">3.</span>          <span class="o">-</span><span class="mf">1.</span>          <span class="o">-</span><span class="mf">3.75</span>      <span class="p">]</span>
<span class="p">[</span>  <span class="mf">3.</span>           <span class="mf">3.33333333</span>  <span class="o">-</span><span class="mf">0.33333333</span>  <span class="o">-</span><span class="mf">5.</span>        <span class="p">]</span>
<span class="p">[</span> <span class="o">-</span><span class="mf">1.</span>          <span class="o">-</span><span class="mf">0.33333333</span>   <span class="mf">3.33333333</span>  <span class="o">-</span><span class="mf">1.</span>        <span class="p">]</span>
<span class="p">[</span> <span class="o">-</span><span class="mf">3.75</span>        <span class="o">-</span><span class="mf">5.</span>          <span class="o">-</span><span class="mf">1.</span>          <span class="mf">10.91666667</span><span class="p">]]</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.matrix_covariance_matrix', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.matrix_covariance_matrix" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">matrix_covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix_column_name</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the Covariance Matrix of matrices stored in a frame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param matrix_column_name: Name of the column to compute the covariance matrix on</span>
<span class="sd">    :return: (Frame) returns the frame with a new column storing the covariance matrix for the corresponding matrix</span>

<span class="sd">    Calculate the covariance matrix for each matrix in column &#39;matrix_column_name&#39; of a frame using the following:</span>

<span class="sd">    Element (i,j) of the covariance matrix for a given matrix X is computed as: ((Xi - Mi)(Xj - Mj))</span>
<span class="sd">    where Mi is the mean</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; from sparktk import dtypes</span>
<span class="sd">        &gt;&gt;&gt; data = [[1, [[1,2,3,5],[2,3,5,6],[4,6,7,3],[8,9,2,4]]]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;id&#39;, int),(&#39;pixeldata&#39;, dtypes.matrix)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>


<span class="sd">        Compute the covariance matrix for the matrices in &#39;pixeldata&#39; column of the frame</span>
<span class="sd">        &gt;&gt;&gt; my_frame.matrix_covariance_matrix(&#39;pixeldata&#39;)</span>

<span class="sd">        A new column gets added to the existing frame storing the covariance matrix</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  CovarianceMatrix_pixeldata</span>
<span class="sd">        ============================================================</span>
<span class="sd">        [0]  [[  2.91666667   3.          -1.          -3.75      ]</span>
<span class="sd">        [  3.           3.33333333  -0.33333333  -5.        ]</span>
<span class="sd">        [ -1.          -0.33333333   3.33333333  -1.        ]</span>
<span class="sd">        [ -3.75        -5.          -1.          10.91666667]]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">matrixCovarianceMatrix</span><span class="p">(</span><span class="n">matrix_column_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.matrix_pca">
    <p>def <span class="ident">matrix_pca</span>(</p><p>self, matrix_column_name, v_matrix_column_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the Principal Component Analysis of a matrix</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>matrix_column_name: </td><td class='param-desc'>Name of the column storing the matrices whose principal components are to be computed
</td></tr></table>

<table><tr><td class='param-name'>v_matrix_column_name: </td><td class='param-desc'>Name of the column storing the V matrix
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns the frame with new column storing the principal components for the corresponding matrix</td></tr></table></p>

<p>Calculate the Principal Components for each matrix in column 'matrix_column_name' using the V matrix</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">schema</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">matrix</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">Compute</span> <span class="n">the</span> <span class="n">singular</span> <span class="n">value</span> <span class="n">decomposition</span> <span class="k">for</span> <span class="n">the</span> <span class="n">matrices</span> <span class="ow">in</span> <span class="s">&#39;pixeldata&#39;</span> <span class="n">column</span> <span class="n">of</span> <span class="n">the</span> <span class="n">frame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">matrix_svd</span><span class="p">(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">)</span>

<span class="n">Three</span> <span class="n">new</span> <span class="n">columns</span> <span class="n">get</span> <span class="n">added</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">U</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">V</span> <span class="n">matrix</span> <span class="ow">and</span> <span class="n">Singular</span> <span class="n">Vectors</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  U_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.29128979</span> <span class="o">-</span><span class="mf">0.43716238</span> <span class="o">-</span><span class="mf">0.44530839</span>  <span class="mf">0.72507913</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.42474933</span> <span class="o">-</span><span class="mf">0.55066945</span> <span class="o">-</span><span class="mf">0.26749936</span> <span class="o">-</span><span class="mf">0.66692972</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.55099141</span> <span class="o">-</span><span class="mf">0.16785045</span>  <span class="mf">0.79986267</span>  <span class="mf">0.16868433</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.65661765</span>  <span class="mf">0.69099814</span> <span class="o">-</span><span class="mf">0.30060644</span> <span class="o">-</span><span class="mf">0.0317899</span> <span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  V_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.47195872</span>  <span class="mf">0.50289367</span> <span class="o">-</span><span class="mf">0.05244699</span> <span class="o">-</span><span class="mf">0.72222035</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.60780067</span>  <span class="mf">0.40702574</span>  <span class="mf">0.11313693</span>  <span class="mf">0.67239008</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.44835972</span> <span class="o">-</span><span class="mf">0.58469285</span>  <span class="mf">0.65644993</span> <span class="o">-</span><span class="mf">0.16180641</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.45476024</span> <span class="o">-</span><span class="mf">0.48945099</span> <span class="o">-</span><span class="mf">0.74399115</span>  <span class="mf">0.01039344</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  SingularVectors_pixeldata</span>
<span class="o">============================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span> <span class="mf">18.21704938</span>   <span class="mf">6.59797925</span>   <span class="mf">3.54086993</span>   <span class="mf">0.26080987</span><span class="p">]]</span>

<span class="n">Compute</span> <span class="n">the</span> <span class="n">principal</span> <span class="n">components</span> <span class="n">using</span> <span class="n">the</span> <span class="n">V</span> <span class="n">matrices</span> <span class="n">computed</span> <span class="k">for</span> <span class="n">matrices</span> <span class="ow">in</span> <span class="s">&#39;pixeldata&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">matrix_pca</span><span class="p">(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">,</span> <span class="s">&#39;V_pixeldata&#39;</span><span class="p">)</span>

<span class="n">A</span> <span class="n">new</span> <span class="n">column</span> <span class="n">gets</span> <span class="n">added</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">Principal</span> <span class="n">components</span> <span class="n">matrix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  U_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.29128979</span> <span class="o">-</span><span class="mf">0.43716238</span> <span class="o">-</span><span class="mf">0.44530839</span>  <span class="mf">0.72507913</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.42474933</span> <span class="o">-</span><span class="mf">0.55066945</span> <span class="o">-</span><span class="mf">0.26749936</span> <span class="o">-</span><span class="mf">0.66692972</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.55099141</span> <span class="o">-</span><span class="mf">0.16785045</span>  <span class="mf">0.79986267</span>  <span class="mf">0.16868433</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.65661765</span>  <span class="mf">0.69099814</span> <span class="o">-</span><span class="mf">0.30060644</span> <span class="o">-</span><span class="mf">0.0317899</span> <span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  V_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.47195872</span>  <span class="mf">0.50289367</span> <span class="o">-</span><span class="mf">0.05244699</span> <span class="o">-</span><span class="mf">0.72222035</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.60780067</span>  <span class="mf">0.40702574</span>  <span class="mf">0.11313693</span>  <span class="mf">0.67239008</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.44835972</span> <span class="o">-</span><span class="mf">0.58469285</span>  <span class="mf">0.65644993</span> <span class="o">-</span><span class="mf">0.16180641</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.45476024</span> <span class="o">-</span><span class="mf">0.48945099</span> <span class="o">-</span><span class="mf">0.74399115</span>  <span class="mf">0.01039344</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  SingularVectors_pixeldata</span>
<span class="o">============================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span> <span class="mf">18.21704938</span>   <span class="mf">6.59797925</span>   <span class="mf">3.54086993</span>   <span class="mf">0.26080987</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  PrincipalComponents_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.47195872</span>  <span class="mf">1.00578734</span> <span class="o">-</span><span class="mf">0.15734098</span> <span class="o">-</span><span class="mf">3.61110176</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">1.21560134</span>  <span class="mf">1.22107722</span>  <span class="mf">0.56568466</span>  <span class="mf">4.0343405</span> <span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">1.79343888</span> <span class="o">-</span><span class="mf">3.50815713</span>  <span class="mf">4.59514953</span> <span class="o">-</span><span class="mf">0.48541923</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">3.63808191</span> <span class="o">-</span><span class="mf">4.40505888</span> <span class="o">-</span><span class="mf">1.4879823</span>   <span class="mf">0.04157377</span><span class="p">]]</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.matrix_pca', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.matrix_pca" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">matrix_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix_column_name</span><span class="p">,</span> <span class="n">v_matrix_column_name</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Principal Component Analysis of a matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param matrix_column_name: Name of the column storing the matrices whose principal components are to be computed</span>
<span class="sd">    :param v_matrix_column_name: Name of the column storing the V matrix</span>
<span class="sd">    :return: (Frame) returns the frame with new column storing the principal components for the corresponding matrix</span>

<span class="sd">    Calculate the Principal Components for each matrix in column &#39;matrix_column_name&#39; using the V matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; from sparktk import dtypes</span>
<span class="sd">        &gt;&gt;&gt; data = [[1, [[1,2,3,5],[2,3,5,6],[4,6,7,3],[8,9,2,4]]]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;id&#39;, int),(&#39;pixeldata&#39;, dtypes.matrix)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>

<span class="sd">        Compute the singular value decomposition for the matrices in &#39;pixeldata&#39; column of the frame</span>
<span class="sd">        &gt;&gt;&gt; my_frame.matrix_svd(&#39;pixeldata&#39;)</span>

<span class="sd">        Three new columns get added storing the U matrix, V matrix and Singular Vectors</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  U_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.29128979 -0.43716238 -0.44530839  0.72507913]</span>
<span class="sd">        [-0.42474933 -0.55066945 -0.26749936 -0.66692972]</span>
<span class="sd">        [-0.55099141 -0.16785045  0.79986267  0.16868433]</span>
<span class="sd">        [-0.65661765  0.69099814 -0.30060644 -0.0317899 ]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  V_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.47195872  0.50289367 -0.05244699 -0.72222035]</span>
<span class="sd">        [-0.60780067  0.40702574  0.11313693  0.67239008]</span>
<span class="sd">        [-0.44835972 -0.58469285  0.65644993 -0.16180641]</span>
<span class="sd">        [-0.45476024 -0.48945099 -0.74399115  0.01039344]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  SingularVectors_pixeldata</span>
<span class="sd">        ============================================================</span>
<span class="sd">        [0]  [[ 18.21704938   6.59797925   3.54086993   0.26080987]]</span>

<span class="sd">        Compute the principal components using the V matrices computed for matrices in &#39;pixeldata&#39;</span>
<span class="sd">        &gt;&gt;&gt; my_frame.matrix_pca(&#39;pixeldata&#39;, &#39;V_pixeldata&#39;)</span>

<span class="sd">        A new column gets added storing the Principal components matrix</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  U_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.29128979 -0.43716238 -0.44530839  0.72507913]</span>
<span class="sd">        [-0.42474933 -0.55066945 -0.26749936 -0.66692972]</span>
<span class="sd">        [-0.55099141 -0.16785045  0.79986267  0.16868433]</span>
<span class="sd">        [-0.65661765  0.69099814 -0.30060644 -0.0317899 ]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  V_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.47195872  0.50289367 -0.05244699 -0.72222035]</span>
<span class="sd">        [-0.60780067  0.40702574  0.11313693  0.67239008]</span>
<span class="sd">        [-0.44835972 -0.58469285  0.65644993 -0.16180641]</span>
<span class="sd">        [-0.45476024 -0.48945099 -0.74399115  0.01039344]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  SingularVectors_pixeldata</span>
<span class="sd">        ============================================================</span>
<span class="sd">        [0]  [[ 18.21704938   6.59797925   3.54086993   0.26080987]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  PrincipalComponents_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.47195872  1.00578734 -0.15734098 -3.61110176]</span>
<span class="sd">        [-1.21560134  1.22107722  0.56568466  4.0343405 ]</span>
<span class="sd">        [-1.79343888 -3.50815713  4.59514953 -0.48541923]</span>
<span class="sd">        [-3.63808191 -4.40505888 -1.4879823   0.04157377]]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">matrixPca</span><span class="p">(</span><span class="n">matrix_column_name</span><span class="p">,</span> <span class="n">v_matrix_column_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.matrix_svd">
    <p>def <span class="ident">matrix_svd</span>(</p><p>self, matrix_column_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the Singular Value Decomposition of a matrix</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>matrix_column_name: </td><td class='param-desc'>Name of the column to compute the svd on
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns the frame with three new columns storing the U matrix, V matrix and Singular Vectors</td></tr></table></p>

<p>Calculate the Singular Value Decomposition for each matrix in column 'matrix_column_name'</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">schema</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">matrix</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">Compute</span> <span class="n">the</span> <span class="n">singular</span> <span class="n">value</span> <span class="n">decomposition</span> <span class="k">for</span> <span class="n">the</span> <span class="n">matrices</span> <span class="ow">in</span> <span class="s">&#39;pixeldata&#39;</span> <span class="n">column</span> <span class="n">of</span> <span class="n">the</span> <span class="n">frame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">matrix_svd</span><span class="p">(</span><span class="s">&#39;pixeldata&#39;</span><span class="p">)</span>

<span class="n">Three</span> <span class="n">new</span> <span class="n">columns</span> <span class="n">get</span> <span class="n">added</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">U</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">V</span> <span class="n">matrix</span> <span class="ow">and</span> <span class="n">Singular</span> <span class="n">Vectors</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">my_frame</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="p">[</span><span class="c">#]  id  pixeldata</span>
<span class="o">============================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="mi">1</span>  <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2.</span>  <span class="mf">3.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">4.</span>  <span class="mf">6.</span>  <span class="mf">7.</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">9.</span>  <span class="mf">2.</span>  <span class="mf">4.</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  U_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.29128979</span> <span class="o">-</span><span class="mf">0.43716238</span> <span class="o">-</span><span class="mf">0.44530839</span>  <span class="mf">0.72507913</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.42474933</span> <span class="o">-</span><span class="mf">0.55066945</span> <span class="o">-</span><span class="mf">0.26749936</span> <span class="o">-</span><span class="mf">0.66692972</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.55099141</span> <span class="o">-</span><span class="mf">0.16785045</span>  <span class="mf">0.79986267</span>  <span class="mf">0.16868433</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.65661765</span>  <span class="mf">0.69099814</span> <span class="o">-</span><span class="mf">0.30060644</span> <span class="o">-</span><span class="mf">0.0317899</span> <span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  V_pixeldata</span>
<span class="o">========================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span><span class="o">-</span><span class="mf">0.47195872</span>  <span class="mf">0.50289367</span> <span class="o">-</span><span class="mf">0.05244699</span> <span class="o">-</span><span class="mf">0.72222035</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.60780067</span>  <span class="mf">0.40702574</span>  <span class="mf">0.11313693</span>  <span class="mf">0.67239008</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.44835972</span> <span class="o">-</span><span class="mf">0.58469285</span>  <span class="mf">0.65644993</span> <span class="o">-</span><span class="mf">0.16180641</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.45476024</span> <span class="o">-</span><span class="mf">0.48945099</span> <span class="o">-</span><span class="mf">0.74399115</span>  <span class="mf">0.01039344</span><span class="p">]]</span>
<span class="o">&lt;</span><span class="n">BLANKLINE</span><span class="o">&gt;</span>
<span class="p">[</span><span class="c">#]  SingularVectors_pixeldata</span>
<span class="o">============================================================</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[[</span> <span class="mf">18.21704938</span>   <span class="mf">6.59797925</span>   <span class="mf">3.54086993</span>   <span class="mf">0.26080987</span><span class="p">]]</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.matrix_svd', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.matrix_svd" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">matrix_svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix_column_name</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Compute the Singular Value Decomposition of a matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param matrix_column_name: Name of the column to compute the svd on</span>
<span class="sd">    :return: (Frame) returns the frame with three new columns storing the U matrix, V matrix and Singular Vectors</span>

<span class="sd">    Calculate the Singular Value Decomposition for each matrix in column &#39;matrix_column_name&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; from sparktk import dtypes</span>
<span class="sd">        &gt;&gt;&gt; data = [[1, [[1,2,3,5],[2,3,5,6],[4,6,7,3],[8,9,2,4]]]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&#39;id&#39;, int),(&#39;pixeldata&#39;, dtypes.matrix)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>

<span class="sd">        Compute the singular value decomposition for the matrices in &#39;pixeldata&#39; column of the frame</span>
<span class="sd">        &gt;&gt;&gt; my_frame.matrix_svd(&#39;pixeldata&#39;)</span>

<span class="sd">        Three new columns get added storing the U matrix, V matrix and Singular Vectors</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  id  pixeldata</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]   1  [[ 1.  2.  3.  5.]</span>
<span class="sd">        [ 2.  3.  5.  6.]</span>
<span class="sd">        [ 4.  6.  7.  3.]</span>
<span class="sd">        [ 8.  9.  2.  4.]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  U_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.29128979 -0.43716238 -0.44530839  0.72507913]</span>
<span class="sd">        [-0.42474933 -0.55066945 -0.26749936 -0.66692972]</span>
<span class="sd">        [-0.55099141 -0.16785045  0.79986267  0.16868433]</span>
<span class="sd">        [-0.65661765  0.69099814 -0.30060644 -0.0317899 ]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  V_pixeldata</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  [[-0.47195872  0.50289367 -0.05244699 -0.72222035]</span>
<span class="sd">        [-0.60780067  0.40702574  0.11313693  0.67239008]</span>
<span class="sd">        [-0.44835972 -0.58469285  0.65644993 -0.16180641]</span>
<span class="sd">        [-0.45476024 -0.48945099 -0.74399115  0.01039344]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        [#]  SingularVectors_pixeldata</span>
<span class="sd">        ============================================================</span>
<span class="sd">        [0]  [[ 18.21704938   6.59797925   3.54086993   0.26080987]]</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">matrixSvd</span><span class="p">(</span><span class="n">matrix_column_name</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.multiclass_classification_metrics">
    <p>def <span class="ident">multiclass_classification_metrics</span>(</p><p>self, label_column, pred_column, beta=1.0, frequency_column=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Statistics of accuracy, precision, and others for a multi-class classification model.</p>
<p>Parameters:</p>
<p><table><tr><td class='param-name'>label_column</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column containing the correct label for each instance.
 </td></tr></table><table><tr><td class='param-name'>pred_column</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column containing the predicted label for each instance.
 </td></tr></table><table><tr><td class='param-name'>beta</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>This is the beta value to use for :math:<code>F_{ eta}</code> measure (default F1 measure is computed);
             must be greater than zero. Defaults is 1.
 </td></tr></table><table><tr><td class='param-name'>frequency_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The name of an optional column containing the frequency of observations.
 </td></tr></table><p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(ClassificationMetricsValue): </td><td class='param-desc'>The data returned is composed of multiple components:<br>
         &lt;object&gt;.accuracy : double<br>
         &lt;object&gt;.confusion_matrix : table<br>
         &lt;object&gt;.f_measure : double<br>
         &lt;object&gt;.precision : double<br>
         &lt;object&gt;.recall : double</td></tr></table></p></p>
<p>Calculate the accuracy, precision, confusion_matrix, recall and :math:<code>F_{ eta}</code> measure for a
classification model.</p>
<ul>
<li>
<p>The <strong>f_measure</strong> result is the :math:<code>F_{ eta}</code> measure for a
    classification model.
    The :math:<code>F_{ eta}</code> measure of a binary classification model is the
    harmonic mean of precision and recall.
    If we let:</p>
<ul>
<li>beta :math:<code>\equiv eta</code>,</li>
<li>:math:<code>T_{P}</code> denotes the number of true positives,</li>
<li>:math:<code>F_{P}</code> denotes the number of false positives, and</li>
<li>:math:<code>F_{N}</code> denotes the number of false negatives</li>
</ul>
<p>then:</p>
<p>.. math::</p>
<div class="codehilite"><pre>F_{ eta} = (1 + eta ^ 2) * rac{ rac{T_{P}}{T_{P} + F_{P}} *            rac{T_{P}}{T_{P} + F_{N}}}{ eta ^ 2 * rac{T_{P}}{T_{P} +            F_{P}}  + rac{T_{P}}{T_{P} + F_{N}}}
</pre></div>


<p>The :math:<code>F_{ eta}</code> measure for a multi-class classification model is
computed as the weighted average of the :math:<code>F_{ eta}</code> measure for
each label, where the weight is the number of instances of each label.
The determination of binary vs. multi-class is automatically inferred
from the data.</p>
</li>
<li>
<p>For multi-class classification models, the <strong>recall</strong> measure is computed as
    the weighted average of the recall for each label, where the weight is
    the number of instances of each label.
    The determination of binary vs. multi-class is automatically inferred
    from the data.</p>
</li>
<li>
<p>For multi-class classification models, the <strong>precision</strong> measure is computed
    as the weighted average of the precision for each label, where the
    weight is the number of instances of each label.
    The determination of binary vs. multi-class is automatically inferred
    from the data.</p>
</li>
<li>
<p>The <strong>accuracy</strong> of a classification model is the proportion of
    predictions that are correctly identified.
    If we let :math:<code>T_{P}</code> denote the number of true positives,
    :math:<code>T_{N}</code> denote the number of true negatives, and :math:<code>K</code> denote
    the total number of classified instances, then the model accuracy is
    given by: :math:<code>rac{T_{P} + T_{N}}{K}</code>.</p>
</li>
<li>
<p>The <strong>confusion_matrix</strong> result is a confusion matrix for a
    classifier model, formatted for human readability.</p>
</li>
</ul>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which contains the data</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
 [#]  a      b  labels  predictions
 ==================================
 [0]  red    1       0            0
 [1]  blue   3       1            0
 [2]  green  1       0            0
 [3]  green  0       1            1
 [4]  red    0       5            4

&gt;&gt;&gt; cm = my_frame.multiclass_classification_metrics(&#39;labels&#39;, &#39;predictions&#39;)
[===Job Progress===]

&gt;&gt;&gt; cm.f_measure
0.5866666666666667

&gt;&gt;&gt; cm.recall
0.6

&gt;&gt;&gt; cm.accuracy
0.6

&gt;&gt;&gt; cm.precision
0.6666666666666666

&gt;&gt;&gt; cm.confusion_matrix
                  Predicted_0  Predicted_1  Predicted_4
 Actual_0            2            0            0
 Actual_1            1            1            0
 Actual_5            0            0            1
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.multiclass_classification_metrics', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.multiclass_classification_metrics" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">multiclass_classification_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_column</span><span class="p">,</span> <span class="n">pred_column</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">frequency_column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Statistics of accuracy, precision, and others for a multi-class classification model.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    :param label_column: (str) The name of the column containing the correct label for each instance.</span>
<span class="sd">    :param pred_column: (str) The name of the column containing the predicted label for each instance.</span>
<span class="sd">    :param beta: (Optional[int]) This is the beta value to use for :math:`F_{ \beta}` measure (default F1 measure is computed);</span>
<span class="sd">                must be greater than zero. Defaults is 1.</span>
<span class="sd">    :param frequency_column: (Optional[str]) The name of an optional column containing the frequency of observations.</span>
<span class="sd">    :return: (ClassificationMetricsValue) The data returned is composed of multiple components:&lt;br&gt;</span>
<span class="sd">            &amp;lt;object&amp;gt;.accuracy : double&lt;br&gt;</span>
<span class="sd">            &amp;lt;object&amp;gt;.confusion_matrix : table&lt;br&gt;</span>
<span class="sd">            &amp;lt;object&amp;gt;.f_measure : double&lt;br&gt;</span>
<span class="sd">            &amp;lt;object&amp;gt;.precision : double&lt;br&gt;</span>
<span class="sd">            &amp;lt;object&amp;gt;.recall : double</span>

<span class="sd">   Calculate the accuracy, precision, confusion_matrix, recall and :math:`F_{ \beta}` measure for a</span>
<span class="sd">   classification model.</span>

<span class="sd">   *   The **f_measure** result is the :math:`F_{ \beta}` measure for a</span>
<span class="sd">       classification model.</span>
<span class="sd">       The :math:`F_{ \beta}` measure of a binary classification model is the</span>
<span class="sd">       harmonic mean of precision and recall.</span>
<span class="sd">       If we let:</span>

<span class="sd">       * beta :math:`\equiv \beta`,</span>
<span class="sd">       * :math:`T_{P}` denotes the number of true positives,</span>
<span class="sd">       * :math:`F_{P}` denotes the number of false positives, and</span>
<span class="sd">       * :math:`F_{N}` denotes the number of false negatives</span>

<span class="sd">       then:</span>

<span class="sd">       .. math::</span>

<span class="sd">           F_{ \beta} = (1 + \beta ^ 2) * \frac{ \frac{T_{P}}{T_{P} + F_{P}} * \</span>
<span class="sd">           \frac{T_{P}}{T_{P} + F_{N}}}{ \beta ^ 2 * \frac{T_{P}}{T_{P} + \</span>
<span class="sd">           F_{P}}  + \frac{T_{P}}{T_{P} + F_{N}}}</span>

<span class="sd">       The :math:`F_{ \beta}` measure for a multi-class classification model is</span>
<span class="sd">       computed as the weighted average of the :math:`F_{ \beta}` measure for</span>
<span class="sd">       each label, where the weight is the number of instances of each label.</span>
<span class="sd">       The determination of binary vs. multi-class is automatically inferred</span>
<span class="sd">       from the data.</span>

<span class="sd">   *   For multi-class classification models, the **recall** measure is computed as</span>
<span class="sd">       the weighted average of the recall for each label, where the weight is</span>
<span class="sd">       the number of instances of each label.</span>
<span class="sd">       The determination of binary vs. multi-class is automatically inferred</span>
<span class="sd">       from the data.</span>

<span class="sd">   *   For multi-class classification models, the **precision** measure is computed</span>
<span class="sd">       as the weighted average of the precision for each label, where the</span>
<span class="sd">       weight is the number of instances of each label.</span>
<span class="sd">       The determination of binary vs. multi-class is automatically inferred</span>
<span class="sd">       from the data.</span>

<span class="sd">   *   The **accuracy** of a classification model is the proportion of</span>
<span class="sd">       predictions that are correctly identified.</span>
<span class="sd">       If we let :math:`T_{P}` denote the number of true positives,</span>
<span class="sd">       :math:`T_{N}` denote the number of true negatives, and :math:`K` denote</span>
<span class="sd">       the total number of classified instances, then the model accuracy is</span>
<span class="sd">       given by: :math:`\frac{T_{P} + T_{N}}{K}`.</span>

<span class="sd">   *   The **confusion_matrix** result is a confusion matrix for a</span>
<span class="sd">       classifier model, formatted for human readability.</span>

<span class="sd">   Examples</span>
<span class="sd">   --------</span>
<span class="sd">   Consider Frame *my_frame*, which contains the data</span>

<span class="sd">       &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  a      b  labels  predictions</span>
<span class="sd">        ==================================</span>
<span class="sd">        [0]  red    1       0            0</span>
<span class="sd">        [1]  blue   3       1            0</span>
<span class="sd">        [2]  green  1       0            0</span>
<span class="sd">        [3]  green  0       1            1</span>
<span class="sd">        [4]  red    0       5            4</span>

<span class="sd">       &gt;&gt;&gt; cm = my_frame.multiclass_classification_metrics(&#39;labels&#39;, &#39;predictions&#39;)</span>
<span class="sd">       [===Job Progress===]</span>

<span class="sd">       &gt;&gt;&gt; cm.f_measure</span>
<span class="sd">       0.5866666666666667</span>

<span class="sd">       &gt;&gt;&gt; cm.recall</span>
<span class="sd">       0.6</span>

<span class="sd">       &gt;&gt;&gt; cm.accuracy</span>
<span class="sd">       0.6</span>

<span class="sd">       &gt;&gt;&gt; cm.precision</span>
<span class="sd">       0.6666666666666666</span>

<span class="sd">       &gt;&gt;&gt; cm.confusion_matrix</span>
<span class="sd">                         Predicted_0  Predicted_1  Predicted_4</span>
<span class="sd">        Actual_0            2            0            0</span>
<span class="sd">        Actual_1            1            1            0</span>
<span class="sd">        Actual_5            0            0            1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ClassificationMetricsValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">multiClassClassificationMetrics</span><span class="p">(</span><span class="n">label_column</span><span class="p">,</span>
                                      <span class="n">pred_column</span><span class="p">,</span>
                                      <span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">frequency_column</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.power_iteration_clustering">
    <p>def <span class="ident">power_iteration_clustering</span>(</p><p>self, source_column, destination_column, similarity_column, k=2, max_iterations=100, initialization_mode=&#39;random&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Power Iteration Clustering finds a low-dimensional embedding of a dataset using truncated power iteration on a
normalized pair-wise similarity matrix of the data.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>source_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column containing the source node
</td></tr></table>

<table><tr><td class='param-name'>destination_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column containing the destination node
</td></tr></table>

<table><tr><td class='param-name'>similarity_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column containing the similarity
</td></tr></table>

<table><tr><td class='param-name'>k</td><td class='param-type'>(Optional(int)):</td><td class='param-desc'>Number of clusters to cluster the graph into. Default is 2
</td></tr></table>

<table><tr><td class='param-name'>max_iterations</td><td class='param-type'>(Optional(int)):</td><td class='param-desc'>Maximum number of iterations of the power iteration loop. Default is 100
</td></tr></table>

<table><tr><td class='param-name'>initialization_mode</td><td class='param-type'>(Optional(str)):</td><td class='param-desc'>Initialization mode of power iteration clustering. This can be either
 "random" to use a random vector as vertex properties, or "degree" to use normalized sum similarities. Default is "random".
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(namedtuple): </td><td class='param-desc'>Returns namedtuple containing the results frame(node and cluster), k (number of clusters),
 and cluster_sizes(a map of clusters and respective size)</td></tr></table></p>

<div class='section-header'>Example:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; frame = tc.frame.create([[1,2,1.0],
...                         [1,3,0.3],
...                         [2,3,0.3],
...                         [3,0,0.03],
...                         [0,5,0.01],
...                         [5,4,0.3],
...                         [5,6,1.0],
...                         [4,6,0.3]],
...                         [(&#39;Source&#39;, int), (&#39;Destination&#39;, int), (&#39;Similarity&#39;,float)])

&gt;&gt;&gt; frame.inspect()
[#]  Source  Destination  Similarity
====================================
[0]       1            2         1.0
[1]       1            3         0.3
[2]       2            3         0.3
[3]       3            0        0.03
[4]       0            5        0.01
[5]       5            4         0.3
[6]       5            6         1.0
[7]       4            6         0.3

&gt;&gt;&gt; x = frame.power_iteration_clustering(&#39;Source&#39;, &#39;Destination&#39;, &#39;Similarity&#39;, k=3)

&gt;&gt;&gt; x.frame.inspect()
[#]  id  cluster
================
[0]   4        2
[1]   0        3
[2]   6        2
[3]   2        1
[4]   1        1
[5]   3        1
[6]   5        2

&gt;&gt;&gt; x.k
3
&gt;&gt;&gt; x.cluster_sizes
{u&#39;2&#39;: 3, u&#39;3&#39;: 1, u&#39;1&#39;: 3}
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.power_iteration_clustering', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.power_iteration_clustering" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">power_iteration_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_column</span><span class="p">,</span> <span class="n">destination_column</span><span class="p">,</span> <span class="n">similarity_column</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                               <span class="n">initialization_mode</span> <span class="o">=</span> <span class="s">&quot;random&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Power Iteration Clustering finds a low-dimensional embedding of a dataset using truncated power iteration on a</span>
<span class="sd">    normalized pair-wise similarity matrix of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param source_column: (str) Name of the column containing the source node</span>
<span class="sd">    :param destination_column: (str) Name of the column containing the destination node</span>
<span class="sd">    :param similarity_column: (str) Name of the column containing the similarity</span>
<span class="sd">    :param k: (Optional(int)) Number of clusters to cluster the graph into. Default is 2</span>
<span class="sd">    :param max_iterations: (Optional(int)) Maximum number of iterations of the power iteration loop. Default is 100</span>
<span class="sd">    :param initialization_mode: (Optional(str)) Initialization mode of power iteration clustering. This can be either</span>
<span class="sd">     &quot;random&quot; to use a random vector as vertex properties, or &quot;degree&quot; to use normalized sum similarities. Default is &quot;random&quot;.</span>
<span class="sd">    :return: (namedtuple) Returns namedtuple containing the results frame(node and cluster), k (number of clusters),</span>
<span class="sd">     and cluster_sizes(a map of clusters and respective size)</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">        &gt;&gt;&gt; frame = tc.frame.create([[1,2,1.0],</span>
<span class="sd">        ...                         [1,3,0.3],</span>
<span class="sd">        ...                         [2,3,0.3],</span>
<span class="sd">        ...                         [3,0,0.03],</span>
<span class="sd">        ...                         [0,5,0.01],</span>
<span class="sd">        ...                         [5,4,0.3],</span>
<span class="sd">        ...                         [5,6,1.0],</span>
<span class="sd">        ...                         [4,6,0.3]],</span>
<span class="sd">        ...                         [(&#39;Source&#39;, int), (&#39;Destination&#39;, int), (&#39;Similarity&#39;,float)])</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  Source  Destination  Similarity</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]       1            2         1.0</span>
<span class="sd">        [1]       1            3         0.3</span>
<span class="sd">        [2]       2            3         0.3</span>
<span class="sd">        [3]       3            0        0.03</span>
<span class="sd">        [4]       0            5        0.01</span>
<span class="sd">        [5]       5            4         0.3</span>
<span class="sd">        [6]       5            6         1.0</span>
<span class="sd">        [7]       4            6         0.3</span>

<span class="sd">        &gt;&gt;&gt; x = frame.power_iteration_clustering(&#39;Source&#39;, &#39;Destination&#39;, &#39;Similarity&#39;, k=3)</span>

<span class="sd">        &gt;&gt;&gt; x.frame.inspect()</span>
<span class="sd">        [#]  id  cluster</span>
<span class="sd">        ================</span>
<span class="sd">        [0]   4        2</span>
<span class="sd">        [1]   0        3</span>
<span class="sd">        [2]   6        2</span>
<span class="sd">        [3]   2        1</span>
<span class="sd">        [4]   1        1</span>
<span class="sd">        [5]   3        1</span>
<span class="sd">        [6]   5        2</span>

<span class="sd">        &gt;&gt;&gt; x.k</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; x.cluster_sizes</span>
<span class="sd">        {u&#39;2&#39;: 3, u&#39;3&#39;: 1, u&#39;1&#39;: 3}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">powerIterationClustering</span><span class="p">(</span><span class="n">source_column</span><span class="p">,</span>
                                                  <span class="n">destination_column</span><span class="p">,</span>
                                                  <span class="n">similarity_column</span><span class="p">,</span>
                                                  <span class="n">k</span><span class="p">,</span>
                                                  <span class="n">max_iterations</span><span class="p">,</span>
                                                  <span class="n">initialization_mode</span><span class="p">)</span>
    <span class="n">k_val</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">k</span><span class="p">()</span>
    <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">scala_map_to_python</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">clusterSizes</span><span class="p">())</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="n">py_frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">clusterMapFrame</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">PicResult</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">py_frame</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k_val</span><span class="p">,</span> <span class="n">cluster_sizes</span><span class="o">=</span><span class="n">cluster_sizes</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.quantile_bin_column">
    <p>def <span class="ident">quantile_bin_column</span>(</p><p>self, column_name, num_bins=None, bin_column_name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Classify column into groups with the same frequency.</p>
<p>Group rows of data based on the value in a single column and add a label
to identify grouping.</p>
<p>Equal depth binning attempts to label rows such that each bin contains the
same number of elements.
For :math:<code>n</code> bins of a column :math:<code>C</code> of length :math:<code>m</code>, the bin
number is determined by:</p>
<p>.. math::</p>
<div class="codehilite"><pre>\lceil n * rac { f(C) }{ m }
</pre></div>


<p>ceil</p>
<p>where :math:<code>f</code> is a tie-adjusted ranking function over values of
:math:<code>C</code>.
If there are multiples of the same value in :math:<code>C</code>, then their
tie-adjusted rank is the average of their ordered rank values.</p>
<div class='section-header'>Notes:</div>

<ol>
<li>The num_bins parameter is considered to be the maximum permissible number
    of bins because the data may dictate fewer bins.
    For example, if the column to be binned has a quantity of :math"<code>X</code>
    elements with only 2 distinct values and the <em>num_bins</em> parameter is
    greater than 2, then the actual number of bins will only be 2.
    This is due to a restriction that elements with an identical value must
    belong to the same bin.</li>
</ol>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name</td><td class='param-type'>(str):</td><td class='param-desc'>The column whose values are to be binned.
</td></tr></table>

<table><tr><td class='param-name'>num_bins</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The maximum number of quantiles.
                 Default is the Square-root choice
                 :math:`\lfloor \sqrt{m} 
floor`, where :math:`m` is the number of rows.
</td></tr></table>

<table><tr><td class='param-name'>bin_column_name</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The name for the new column holding the grouping labels.
                        Default is <column_name>_binned
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(List[float]): </td><td class='param-desc'>A list containing the edges of each bin</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Given a frame with column <em>a</em> accessed by a Frame object <em>my_frame</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect( n=11 )
[##]  a
========
[0]    1
[1]    1
[2]    2
[3]    3
[4]    5
[5]    8
[6]   13
[7]   21
[8]   34
[9]   55
[10]  89
</pre></div>


<p>Modify the frame, adding a column showing what bin the data is in.
The data should be grouped into a maximum of five bins.
Note that each bin will have the same quantity of members (as much as
possible):</p>
<div class="codehilite"><pre>&gt;&gt;&gt; cutoffs = my_frame.quantile_bin_column(&#39;a&#39;, 5, &#39;aEDBinned&#39;)
[===Job Progress===]

&gt;&gt;&gt; my_frame.inspect( n=11 )
[##]  a   aEDBinned
===================
[0]    1          0
[1]    1          0
[2]    2          1
[3]    3          1
[4]    5          2
[5]    8          2
[6]   13          3
[7]   21          3
[8]   34          4
[9]   55          4
[10]  89          4

&gt;&gt;&gt; print cutoffs
[1.0, 2.0, 5.0, 13.0, 34.0, 89.0]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.quantile_bin_column', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.quantile_bin_column" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">quantile_bin_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bin_column_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classify column into groups with the same frequency.</span>

<span class="sd">    Group rows of data based on the value in a single column and add a label</span>
<span class="sd">    to identify grouping.</span>

<span class="sd">    Equal depth binning attempts to label rows such that each bin contains the</span>
<span class="sd">    same number of elements.</span>
<span class="sd">    For :math:`n` bins of a column :math:`C` of length :math:`m`, the bin</span>
<span class="sd">    number is determined by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \lceil n * \frac { f(C) }{ m } \rceil</span>

<span class="sd">    where :math:`f` is a tie-adjusted ranking function over values of</span>
<span class="sd">    :math:`C`.</span>
<span class="sd">    If there are multiples of the same value in :math:`C`, then their</span>
<span class="sd">    tie-adjusted rank is the average of their ordered rank values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    1.  The num_bins parameter is considered to be the maximum permissible number</span>
<span class="sd">        of bins because the data may dictate fewer bins.</span>
<span class="sd">        For example, if the column to be binned has a quantity of :math&quot;`X`</span>
<span class="sd">        elements with only 2 distinct values and the *num_bins* parameter is</span>
<span class="sd">        greater than 2, then the actual number of bins will only be 2.</span>
<span class="sd">        This is due to a restriction that elements with an identical value must</span>
<span class="sd">        belong to the same bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: (str) The column whose values are to be binned.</span>
<span class="sd">    :param num_bins: (Optional[int]) The maximum number of quantiles.</span>
<span class="sd">                     Default is the Square-root choice</span>
<span class="sd">                     :math:`\lfloor \sqrt{m} \rfloor`, where :math:`m` is the number of rows.</span>
<span class="sd">    :param bin_column_name: (Optional[str]) The name for the new column holding the grouping labels.</span>
<span class="sd">                            Default is &lt;column_name&gt;_binned</span>
<span class="sd">    :return: (List[float]) A list containing the edges of each bin</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Given a frame with column *a* accessed by a Frame object *my_frame*:</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect( n=11 )</span>
<span class="sd">        [##]  a</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    1</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    3</span>
<span class="sd">        [4]    5</span>
<span class="sd">        [5]    8</span>
<span class="sd">        [6]   13</span>
<span class="sd">        [7]   21</span>
<span class="sd">        [8]   34</span>
<span class="sd">        [9]   55</span>
<span class="sd">        [10]  89</span>


<span class="sd">    Modify the frame, adding a column showing what bin the data is in.</span>
<span class="sd">    The data should be grouped into a maximum of five bins.</span>
<span class="sd">    Note that each bin will have the same quantity of members (as much as</span>
<span class="sd">    possible):</span>

<span class="sd">        &gt;&gt;&gt; cutoffs = my_frame.quantile_bin_column(&#39;a&#39;, 5, &#39;aEDBinned&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect( n=11 )</span>
<span class="sd">        [##]  a   aEDBinned</span>
<span class="sd">        ===================</span>
<span class="sd">        [0]    1          0</span>
<span class="sd">        [1]    1          0</span>
<span class="sd">        [2]    2          1</span>
<span class="sd">        [3]    3          1</span>
<span class="sd">        [4]    5          2</span>
<span class="sd">        [5]    8          2</span>
<span class="sd">        [6]   13          3</span>
<span class="sd">        [7]   21          3</span>
<span class="sd">        [8]   34          4</span>
<span class="sd">        [9]   55          4</span>
<span class="sd">        [10]  89          4</span>

<span class="sd">        &gt;&gt;&gt; print cutoffs</span>
<span class="sd">        [1.0, 2.0, 5.0, 13.0, 34.0, 89.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_scala_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">quantileBinColumn</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">num_bins</span><span class="p">),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">bin_column_name</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.quantiles">
    <p>def <span class="ident">quantiles</span>(</p><p>self, column_name, quantiles)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a new frame with Quantiles and their values.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name</td><td class='param-type'>(str):</td><td class='param-desc'>The column to calculate quantiles on
</td></tr></table>

<table><tr><td class='param-name'>quantiles</td><td class='param-type'>(List[float]):</td><td class='param-desc'>The quantiles being requested
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>A new frame with two columns (float64): requested Quantiles and their respective values.</td></tr></table></p>

<p>Calculates quantiles on the given column.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which accesses a frame that contains a single
column <em>final_sale_price</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  final_sale_price
=====================
[0]               100
[1]               250
[2]                95
[3]               179
[4]               315
[5]               660
[6]               540
[7]               420
[8]               250
[9]               335
</pre></div>


<p>To calculate 10th, 50th, and 100th quantile:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; quantiles_frame = my_frame.quantiles(&#39;final_sale_price&#39;, [10, 50, 100])
[===Job Progress===]
</pre></div>


<p>A new Frame containing the requested Quantiles and their respective values
will be returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>quantiles_frame.inspect()
   [#]  Quantiles  final_sale_price_QuantileValue
   ==============================================
   [0]       10.0                            95.0
   [1]       50.0                           250.0
   [2]      100.0                           660.0</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.quantiles', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.quantiles" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">quantiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a new frame with Quantiles and their values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: (str) The column to calculate quantiles on</span>
<span class="sd">    :param quantiles: (List[float]) The quantiles being requested</span>
<span class="sd">    :return: (Frame) A new frame with two columns (float64): requested Quantiles and their respective values.</span>

<span class="sd">    Calculates quantiles on the given column.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider Frame *my_frame*, which accesses a frame that contains a single</span>
<span class="sd">    column *final_sale_price*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  final_sale_price</span>
<span class="sd">        =====================</span>
<span class="sd">        [0]               100</span>
<span class="sd">        [1]               250</span>
<span class="sd">        [2]                95</span>
<span class="sd">        [3]               179</span>
<span class="sd">        [4]               315</span>
<span class="sd">        [5]               660</span>
<span class="sd">        [6]               540</span>
<span class="sd">        [7]               420</span>
<span class="sd">        [8]               250</span>
<span class="sd">        [9]               335</span>

<span class="sd">    To calculate 10th, 50th, and 100th quantile:</span>

<span class="sd">        &gt;&gt;&gt; quantiles_frame = my_frame.quantiles(&#39;final_sale_price&#39;, [10, 50, 100])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    A new Frame containing the requested Quantiles and their respective values</span>
<span class="sd">    will be returned:</span>

<span class="sd">       &gt;&gt;&gt; quantiles_frame.inspect()</span>
<span class="sd">       [#]  Quantiles  final_sale_price_QuantileValue</span>
<span class="sd">       ==============================================</span>
<span class="sd">       [0]       10.0                            95.0</span>
<span class="sd">       [1]       50.0                           250.0</span>
<span class="sd">       [2]      100.0                           660.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">quantiles</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_double</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.rename_columns">
    <p>def <span class="ident">rename_columns</span>(</p><p>self, names)</p>
    </div>
    

    
  
    <div class="desc"><p>Rename columns</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>names</td><td class='param-type'>(dict):</td><td class='param-desc'>Dictionary of old names to new names.</td></tr></table>

<div class='section-header'>Examples:</div>

<p>Start with a frame with columns <em>Black</em> and <em>White</em>.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; print my_frame.schema
[(&#39;Black&#39;, &lt;type &#39;unicode&#39;&gt;), (&#39;White&#39;, &lt;type &#39;unicode&#39;&gt;)]
</pre></div>


<p>Rename the columns to <em>Mercury</em> and <em>Venus</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.rename_columns({&quot;Black&quot;: &quot;Mercury&quot;, &quot;White&quot;: &quot;Venus&quot;})

&gt;&gt;&gt; print my_frame.schema
[(u&#39;Mercury&#39;, &lt;type &#39;unicode&#39;&gt;), (u&#39;Venus&#39;, &lt;type &#39;unicode&#39;&gt;)]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.rename_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.rename_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rename columns</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param names: (dict) Dictionary of old names to new names.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Start with a frame with columns *Black* and *White*.</span>


<span class="sd">        &gt;&gt;&gt; print my_frame.schema</span>
<span class="sd">        [(&#39;Black&#39;, &lt;type &#39;unicode&#39;&gt;), (&#39;White&#39;, &lt;type &#39;unicode&#39;&gt;)]</span>

<span class="sd">    Rename the columns to *Mercury* and *Venus*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.rename_columns({&quot;Black&quot;: &quot;Mercury&quot;, &quot;White&quot;: &quot;Venus&quot;})</span>

<span class="sd">        &gt;&gt;&gt; print my_frame.schema</span>
<span class="sd">        [(u&#39;Mercury&#39;, &lt;type &#39;unicode&#39;&gt;), (u&#39;Venus&#39;, &lt;type &#39;unicode&#39;&gt;)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported &#39;names&#39; parameter type.  Expected dictionary, but found </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Unable rename column(s), because the frame&#39;s schema has not been defined.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_python</span><span class="p">:</span>
        <span class="n">scala_rename_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_map</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">scala_schema</span> <span class="o">=</span> <span class="n">schema_to_scala</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">rename_scala_schema</span> <span class="o">=</span> <span class="n">scala_schema</span><span class="o">.</span><span class="n">renameColumns</span><span class="p">(</span><span class="n">scala_rename_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">schema_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">rename_scala_schema</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">renameColumns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_map</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.reverse_box_cox">
    <p>def <span class="ident">reverse_box_cox</span>(</p><p>self, column_name, lambda_value=0.0, reverse_box_cox_column_name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the reverse box-cox transformation for each row on a given column_name of the current frame</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name: </td><td class='param-desc'>Name of the column to perform the reverse transformation on
</td></tr></table>

<table><tr><td class='param-name'>lambda_value: </td><td class='param-desc'>Lambda power parameter. Default is 0.0
</td></tr></table>

<table><tr><td class='param-name'>reverse_box_cox_column_name: </td><td class='param-desc'>Optional column name for the reverse box cox value
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>returns a frame with a new column storing the reverse box-cox transformed value</td></tr></table></p>

<p>Calculate the reverse box-cox transformation for each row in column 'column_name' of a frame using the lambda_value.</p>
<p>Reverse Box-cox transformation is computed by the following formula:</p>
<p>reverse_box_cox = exp(boxcox); if lambda=0,
reverse_box_cox = (lambda * boxcox + 1)^(1/lambda) ; else</p>
<div class='section-header'>Examples:</div>

<div class="codehilite"><pre>&gt;&gt;&gt; data = [[7.7132064326674596, 2.81913279907],[0.207519493594015, -1.25365381375],[6.336482349262754, 2.46673638752], [7.4880388253861181, 2.76469126003],[4.9850701230259045, 2.06401101556]]
&gt;&gt;&gt; schema = [(&quot;input&quot;, float), (&quot;input_lambda_0.3&quot;, float)]
&gt;&gt;&gt; my_frame = tc.frame.create(data, schema)
&gt;&gt;&gt; my_frame.inspect()
[#]  input           input_lambda_0.3
=====================================
[0]   7.71320643267     2.81913279907
[1]  0.207519493594    -1.25365381375
[2]   6.33648234926     2.46673638752
[3]   7.48803882539     2.76469126003
[4]   4.98507012303     2.06401101556

Compute the reverse box-cox transformation on the &#39;input_lambda_0.3&#39; column which stores the box-cox transformed
value on column &#39;input&#39; with lambda 0.3
&gt;&gt;&gt; my_frame.reverse_box_cox(&#39;input_lambda_0.3&#39;,0.3)

A new column gets added to the frame which stores the reverse box-cox transformation for each row.
This value is equal to the original vales in &#39;input&#39; column
&gt;&gt;&gt; my_frame.inspect()
[#]  input           input_lambda_0.3  input_lambda_0.3_reverse_lambda_0.3
==========================================================================
[0]   7.71320643267     2.81913279907                        7.71320643267
[1]  0.207519493594    -1.25365381375                       0.207519493594
[2]   6.33648234926     2.46673638752                        6.33648234926
[3]   7.48803882539     2.76469126003                         7.4880388254
[4]   4.98507012303     2.06401101556                        4.98507012301
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.reverse_box_cox', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.reverse_box_cox" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">reverse_box_cox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lambda_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">reverse_box_cox_column_name</span><span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the reverse box-cox transformation for each row on a given column_name of the current frame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: Name of the column to perform the reverse transformation on</span>
<span class="sd">    :param lambda_value: Lambda power parameter. Default is 0.0</span>
<span class="sd">    :param reverse_box_cox_column_name: Optional column name for the reverse box cox value</span>
<span class="sd">    :return: (Frame) returns a frame with a new column storing the reverse box-cox transformed value</span>

<span class="sd">    Calculate the reverse box-cox transformation for each row in column &#39;column_name&#39; of a frame using the lambda_value.</span>

<span class="sd">    Reverse Box-cox transformation is computed by the following formula:</span>

<span class="sd">    reverse_box_cox = exp(boxcox); if lambda=0,</span>
<span class="sd">    reverse_box_cox = (lambda * boxcox + 1)^(1/lambda) ; else</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">        &gt;&gt;&gt; data = [[7.7132064326674596, 2.81913279907],[0.207519493594015, -1.25365381375],[6.336482349262754, 2.46673638752], [7.4880388253861181, 2.76469126003],[4.9850701230259045, 2.06401101556]]</span>
<span class="sd">        &gt;&gt;&gt; schema = [(&quot;input&quot;, float), (&quot;input_lambda_0.3&quot;, float)]</span>
<span class="sd">        &gt;&gt;&gt; my_frame = tc.frame.create(data, schema)</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  input           input_lambda_0.3</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]   7.71320643267     2.81913279907</span>
<span class="sd">        [1]  0.207519493594    -1.25365381375</span>
<span class="sd">        [2]   6.33648234926     2.46673638752</span>
<span class="sd">        [3]   7.48803882539     2.76469126003</span>
<span class="sd">        [4]   4.98507012303     2.06401101556</span>

<span class="sd">        Compute the reverse box-cox transformation on the &#39;input_lambda_0.3&#39; column which stores the box-cox transformed</span>
<span class="sd">        value on column &#39;input&#39; with lambda 0.3</span>
<span class="sd">        &gt;&gt;&gt; my_frame.reverse_box_cox(&#39;input_lambda_0.3&#39;,0.3)</span>

<span class="sd">        A new column gets added to the frame which stores the reverse box-cox transformation for each row.</span>
<span class="sd">        This value is equal to the original vales in &#39;input&#39; column</span>
<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  input           input_lambda_0.3  input_lambda_0.3_reverse_lambda_0.3</span>
<span class="sd">        ==========================================================================</span>
<span class="sd">        [0]   7.71320643267     2.81913279907                        7.71320643267</span>
<span class="sd">        [1]  0.207519493594    -1.25365381375                       0.207519493594</span>
<span class="sd">        [2]   6.33648234926     2.46673638752                        6.33648234926</span>
<span class="sd">        [3]   7.48803882539     2.76469126003                         7.4880388254</span>
<span class="sd">        [4]   4.98507012303     2.06401101556                        4.98507012301</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">reverseBoxCox</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">lambda_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">reverse_box_cox_column_name</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.save">
    <p>def <span class="ident">save</span>(</p><p>self, path)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.save', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.save" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.sort">
    <p>def <span class="ident">sort</span>(</p><p>self, columns, ascending=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Sort by one or more columns.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(str or List[str]):</td><td class='param-desc'>Either a column name, list of column names, or list of tuples where each tuple is a name and an
                ascending bool value.
</td></tr></table>

<table><tr><td class='param-name'>ascending</td><td class='param-type'>(Optional[bool]):</td><td class='param-desc'>True for ascending (default), or False for descending.</td></tr></table>

<p>Sort a frame by column values either ascending or descending.</p>
<div class='section-header'>Examples:</div>

<p>Consider the frame:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     3  foxtrot
[1]     1  charlie
[2]     3  bravo
[3]     2  echo
[4]     4  delta
[5]     3  alpha
</pre></div>


<p>Sort a single column:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.sort(&#39;col1&#39;)
[===Job Progress===]
&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     1  charlie
[1]     2  echo
[2]     3  foxtrot
[3]     3  bravo
[4]     3  alpha
[5]     4  delta
</pre></div>


<p>Sort a single column descending:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.sort(&#39;col2&#39;, False)
[===Job Progress===]
&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     3  foxtrot
[1]     2  echo
[2]     4  delta
[3]     1  charlie
[4]     3  bravo
[5]     3  alpha
</pre></div>


<p>Sort multiple columns:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.sort([&#39;col1&#39;, &#39;col2&#39;])
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     1  charlie
[1]     2  echo
[2]     3  alpha
[3]     3  bravo
[4]     3  foxtrot
[5]     4  delta
</pre></div>


<p>Sort multiple columns descending:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.sort([&#39;col1&#39;, &#39;col2&#39;], False)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     4  delta
[1]     3  foxtrot
[2]     3  bravo
[3]     3  alpha
[4]     2  echo
[5]     1  charlie
</pre></div>


<p>Sort multiple columns: 'col1' decending and 'col2' ascending:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.sort([ (&#39;col1&#39;, False), (&#39;col2&#39;, True) ])
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  col1  col2
==================
[0]     4  delta
[1]     3  alpha
[2]     3  bravo
[3]     3  foxtrot
[4]     2  echo
[5]     1  charlie
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.sort', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.sort" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort by one or more columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (str or List[str]) Either a column name, list of column names, or list of tuples where each tuple is a name and an</span>
<span class="sd">                    ascending bool value.</span>
<span class="sd">    :param ascending: (Optional[bool]) True for ascending (default), or False for descending.</span>

<span class="sd">    Sort a frame by column values either ascending or descending.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider the frame:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     3  foxtrot</span>
<span class="sd">        [1]     1  charlie</span>
<span class="sd">        [2]     3  bravo</span>
<span class="sd">        [3]     2  echo</span>
<span class="sd">        [4]     4  delta</span>
<span class="sd">        [5]     3  alpha</span>

<span class="sd">    Sort a single column:</span>

<span class="sd">        &gt;&gt;&gt; frame.sort(&#39;col1&#39;)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     1  charlie</span>
<span class="sd">        [1]     2  echo</span>
<span class="sd">        [2]     3  foxtrot</span>
<span class="sd">        [3]     3  bravo</span>
<span class="sd">        [4]     3  alpha</span>
<span class="sd">        [5]     4  delta</span>

<span class="sd">    Sort a single column descending:</span>

<span class="sd">        &gt;&gt;&gt; frame.sort(&#39;col2&#39;, False)</span>
<span class="sd">        [===Job Progress===]</span>
<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     3  foxtrot</span>
<span class="sd">        [1]     2  echo</span>
<span class="sd">        [2]     4  delta</span>
<span class="sd">        [3]     1  charlie</span>
<span class="sd">        [4]     3  bravo</span>
<span class="sd">        [5]     3  alpha</span>

<span class="sd">    Sort multiple columns:</span>

<span class="sd">        &gt;&gt;&gt; frame.sort([&#39;col1&#39;, &#39;col2&#39;])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     1  charlie</span>
<span class="sd">        [1]     2  echo</span>
<span class="sd">        [2]     3  alpha</span>
<span class="sd">        [3]     3  bravo</span>
<span class="sd">        [4]     3  foxtrot</span>
<span class="sd">        [5]     4  delta</span>


<span class="sd">    Sort multiple columns descending:</span>

<span class="sd">        &gt;&gt;&gt; frame.sort([&#39;col1&#39;, &#39;col2&#39;], False)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     4  delta</span>
<span class="sd">        [1]     3  foxtrot</span>
<span class="sd">        [2]     3  bravo</span>
<span class="sd">        [3]     3  alpha</span>
<span class="sd">        [4]     2  echo</span>
<span class="sd">        [5]     1  charlie</span>

<span class="sd">    Sort multiple columns: &#39;col1&#39; decending and &#39;col2&#39; ascending:</span>

<span class="sd">        &gt;&gt;&gt; frame.sort([ (&#39;col1&#39;, False), (&#39;col2&#39;, True) ])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  col1  col2</span>
<span class="sd">        ==================</span>
<span class="sd">        [0]     4  delta</span>
<span class="sd">        [1]     3  alpha</span>
<span class="sd">        [2]     3  bravo</span>
<span class="sd">        [3]     3  foxtrot</span>
<span class="sd">        [4]     2  echo</span>
<span class="sd">        [5]     1  charlie</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The columns parameter should not be None.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The columns parameter should not be empty.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
        <span class="n">scala_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">ascending</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="n">columns</span>              <span class="c"># list of column names</span>
        <span class="n">columns_ascending</span> <span class="o">=</span> <span class="n">ascending</span>       <span class="c"># boolean summarizing if we are sorting ascending or descending</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">are_all_proper_tuples</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">are_all_proper_tuples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;If the columns paramter is a list of tuples, each tuple must have a string (column name)&quot;</span>
                                 <span class="s">&quot;and a bool (True for ascending).&quot;</span><span class="p">)</span>

            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>  <span class="c"># Grab just the column names from the list of tuples</span>

            <span class="c"># Check ascending booleans in the tuples to see if they&#39;re all the same</span>
            <span class="n">are_all_same_ascending</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">are_all_same_ascending</span><span class="p">:</span>
                <span class="n">columns_ascending</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">are_all_same_ascending</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">are_all_same_ascending</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">sparktk</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">get_indices_for_selected_columns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">column_names</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">sortBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]),</span> <span class="n">ascending</span><span class="o">=</span><span class="n">columns_ascending</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If there are different ascending values between columns, then use scala sort</span>
            <span class="n">scala_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">ascending</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.sorted_k">
    <p>def <span class="ident">sorted_k</span>(</p><p>self, k, column_names_and_ascending, reduce_tree_depth=2)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a sorted subset of the data.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>k</td><td class='param-type'>(int):</td><td class='param-desc'>Number of sorted records to return.
</td></tr></table>

<table><tr><td class='param-name'>column_names_and_ascending</td><td class='param-type'>(List[tuple(str, bool)]):</td><td class='param-desc'>Column names to sort by, and true to sort column
                                   by ascending order, or false for descending order.
</td></tr></table>

<table><tr><td class='param-name'>reduce_tree_depth</td><td class='param-type'>(int):</td><td class='param-desc'>Advanced tuning parameter which determines the depth of the
                          reduce-tree (uses Spark's treeReduce() for scalability.)
                          Default is 2.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(Frame): </td><td class='param-desc'>A new frame with a subset of sorted rows from the original frame.</td></tr></table></p>

<p>Take a number of rows and return them sorted in either ascending or descending order.</p>
<p>Sorting a subset of rows is more efficient than sorting the entire frame when
the number of sorted rows is much less than the total number of rows in the frame.</p>
<div class='section-header'>Notes:</div>

<p>The number of sorted rows should be much smaller than the number of rows
in the original frame.</p>
<p>In particular:</p>
<ol>
<li>The number of sorted rows returned should fit in Spark driver memory.
    The maximum size of serialized results that can fit in the Spark driver is
    set by the Spark configuration parameter <em>spark.driver.maxResultSize</em>.</li>
<li>If you encounter a Kryo buffer overflow exception, increase the Spark
    configuration parameter <em>spark.kryoserializer.buffer.max.mb</em>.</li>
<li>Use Frame.sort() instead if the number of sorted rows is very large (in
    other words, it cannot fit in Spark driver memory).</li>
</ol>
<div class='section-header'>Examples:</div>

<p>These examples deal with the most recently-released movies in a private collection.
Consider the movie collection already stored in the frame below:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  genre      year  title
========================================================
[0]  Drama      1957  12 Angry Men
[1]  Crime      1946  The Big Sleep
[2]  Western    1969  Butch Cassidy and the Sundance Kid
[3]  Drama      1971  A Clockwork Orange
[4]  Drama      2008  The Dark Knight
[5]  Animation  2013  Frozen
[6]  Drama      1972  The Godfather
[7]  Animation  1994  The Lion King
[8]  Animation  2010  Tangled
[9]  Fantasy    1939  The WOnderful Wizard of Oz
</pre></div>


<p>This example returns the top 3 rows sorted by a single column: 'year' descending:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; topk_frame = my_frame.sorted_k(3, [ (&#39;year&#39;, False) ])
[===Job Progress===]

&gt;&gt;&gt; topk_frame.inspect()
[#]  genre      year  title
=====================================
[0]  Animation  2013  Frozen
[1]  Animation  2010  Tangled
[2]  Drama      2008  The Dark Knight
</pre></div>


<p>This example returns the top 5 rows sorted by multiple columns: 'genre' ascending, then 'year' descending:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; topk_frame = my_frame.sorted_k(5, [ (&#39;genre&#39;, True), (&#39;year&#39;, False) ])
[===Job Progress===]

&gt;&gt;&gt; topk_frame.inspect()
[#]  genre      year  title
=====================================
[0]  Animation  2013  Frozen
[1]  Animation  2010  Tangled
[2]  Animation  1994  The Lion King
[3]  Crime      1946  The Big Sleep
[4]  Drama      2008  The Dark Knight
</pre></div>


<p>This example returns the top 5 rows sorted by multiple columns: 'genre'
ascending, then 'year' ascending.
It also illustrates the optional tuning parameter for reduce-tree depth
(which does not affect the final result).</p>
<div class="codehilite"><pre>&gt;&gt;&gt; topk_frame = my_frame.sorted_k(5, [ (&#39;genre&#39;, True), (&#39;year&#39;, True) ], reduce_tree_depth=1)
[===Job Progress===]

&gt;&gt;&gt; topk_frame.inspect()
[#]  genre      year  title
===================================
[0]  Animation  1994  The Lion King
[1]  Animation  2010  Tangled
[2]  Animation  2013  Frozen
[3]  Crime      1946  The Big Sleep
[4]  Drama      1957  12 Angry Men
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.sorted_k', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.sorted_k" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">sorted_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">column_names_and_ascending</span><span class="p">,</span> <span class="n">reduce_tree_depth</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a sorted subset of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param k: (int) Number of sorted records to return.</span>
<span class="sd">    :param column_names_and_ascending: (List[tuple(str, bool)]) Column names to sort by, and true to sort column</span>
<span class="sd">                                       by ascending order, or false for descending order.</span>
<span class="sd">    :param reduce_tree_depth: (int) Advanced tuning parameter which determines the depth of the</span>
<span class="sd">                              reduce-tree (uses Spark&#39;s treeReduce() for scalability.)</span>
<span class="sd">                              Default is 2.</span>
<span class="sd">    :return: (Frame) A new frame with a subset of sorted rows from the original frame.</span>

<span class="sd">    Take a number of rows and return them sorted in either ascending or descending order.</span>

<span class="sd">    Sorting a subset of rows is more efficient than sorting the entire frame when</span>
<span class="sd">    the number of sorted rows is much less than the total number of rows in the frame.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The number of sorted rows should be much smaller than the number of rows</span>
<span class="sd">    in the original frame.</span>

<span class="sd">    In particular:</span>

<span class="sd">    1.  The number of sorted rows returned should fit in Spark driver memory.</span>
<span class="sd">        The maximum size of serialized results that can fit in the Spark driver is</span>
<span class="sd">        set by the Spark configuration parameter *spark.driver.maxResultSize*.</span>
<span class="sd">    +   If you encounter a Kryo buffer overflow exception, increase the Spark</span>
<span class="sd">        configuration parameter *spark.kryoserializer.buffer.max.mb*.</span>
<span class="sd">    +   Use Frame.sort() instead if the number of sorted rows is very large (in</span>
<span class="sd">        other words, it cannot fit in Spark driver memory).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    These examples deal with the most recently-released movies in a private collection.</span>
<span class="sd">    Consider the movie collection already stored in the frame below:</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  genre      year  title</span>
<span class="sd">        ========================================================</span>
<span class="sd">        [0]  Drama      1957  12 Angry Men</span>
<span class="sd">        [1]  Crime      1946  The Big Sleep</span>
<span class="sd">        [2]  Western    1969  Butch Cassidy and the Sundance Kid</span>
<span class="sd">        [3]  Drama      1971  A Clockwork Orange</span>
<span class="sd">        [4]  Drama      2008  The Dark Knight</span>
<span class="sd">        [5]  Animation  2013  Frozen</span>
<span class="sd">        [6]  Drama      1972  The Godfather</span>
<span class="sd">        [7]  Animation  1994  The Lion King</span>
<span class="sd">        [8]  Animation  2010  Tangled</span>
<span class="sd">        [9]  Fantasy    1939  The WOnderful Wizard of Oz</span>


<span class="sd">    This example returns the top 3 rows sorted by a single column: &#39;year&#39; descending:</span>

<span class="sd">        &gt;&gt;&gt; topk_frame = my_frame.sorted_k(3, [ (&#39;year&#39;, False) ])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; topk_frame.inspect()</span>
<span class="sd">        [#]  genre      year  title</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  Animation  2013  Frozen</span>
<span class="sd">        [1]  Animation  2010  Tangled</span>
<span class="sd">        [2]  Drama      2008  The Dark Knight</span>

<span class="sd">    This example returns the top 5 rows sorted by multiple columns: &#39;genre&#39; ascending, then &#39;year&#39; descending:</span>

<span class="sd">        &gt;&gt;&gt; topk_frame = my_frame.sorted_k(5, [ (&#39;genre&#39;, True), (&#39;year&#39;, False) ])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; topk_frame.inspect()</span>
<span class="sd">        [#]  genre      year  title</span>
<span class="sd">        =====================================</span>
<span class="sd">        [0]  Animation  2013  Frozen</span>
<span class="sd">        [1]  Animation  2010  Tangled</span>
<span class="sd">        [2]  Animation  1994  The Lion King</span>
<span class="sd">        [3]  Crime      1946  The Big Sleep</span>
<span class="sd">        [4]  Drama      2008  The Dark Knight</span>

<span class="sd">    This example returns the top 5 rows sorted by multiple columns: &#39;genre&#39;</span>
<span class="sd">    ascending, then &#39;year&#39; ascending.</span>
<span class="sd">    It also illustrates the optional tuning parameter for reduce-tree depth</span>
<span class="sd">    (which does not affect the final result).</span>

<span class="sd">        &gt;&gt;&gt; topk_frame = my_frame.sorted_k(5, [ (&#39;genre&#39;, True), (&#39;year&#39;, True) ], reduce_tree_depth=1)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; topk_frame.inspect()</span>
<span class="sd">        [#]  genre      year  title</span>
<span class="sd">        ===================================</span>
<span class="sd">        [0]  Animation  1994  The Lion King</span>
<span class="sd">        [1]  Animation  2010  Tangled</span>
<span class="sd">        [2]  Animation  2013  Frozen</span>
<span class="sd">        [3]  Crime      1946  The Big Sleep</span>
<span class="sd">        [4]  Drama      1957  12 Angry Men</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">sortedK</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string_bool_tuple</span><span class="p">(</span><span class="n">column_names_and_ascending</span><span class="p">),</span>
                                     <span class="n">reduce_tree_depth</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.take">
    <p>def <span class="ident">take</span>(</p><p>self, n, offset=0, columns=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Get data subset.</p>
<p>Take a subset of the currently active Frame.</p>
<p>(See 'collect' operation to simply get all the data from the Frame)</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>n</td><td class='param-type'>(int):</td><td class='param-desc'>The number of rows to get from the frame (warning: do not overwhelm the python session
                by taking too much)
</td></tr></table>

<table><tr><td class='param-name'>offset</td><td class='param-type'>(Optional[int]):</td><td class='param-desc'>The number of rows to skip before starting to copy.
</td></tr></table>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(Optional[str or list[str]):</td><td class='param-desc'>If not None, only the given columns' data will be provided.
                By default, all columns are included.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(list[list[data]]): </td><td class='param-desc'>raw frame data</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Consider the following frame:
    &gt;&gt;&gt; frame.inspect()
    [#]  name      age  tenure  phone
    ====================================
    [0]  Fred       39      16  555-1234
    [1]  Susan      33       3  555-0202
    [2]  Thurston   65      26  555-4510
    [3]  Judy       44      14  555-2183</p>
<p>Use take to get the first two rows and look at the schema and data in the result:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.take(2)
[[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;]]
</pre></div>


<p>Limit the columns in our result to just the name and age column:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.take(2, columns=[&#39;name&#39;, &#39;age&#39;])
[[&#39;Fred&#39;, 39], [&#39;Susan&#39;, 33]]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.take', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.take" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get data subset.</span>

<span class="sd">    Take a subset of the currently active Frame.</span>

<span class="sd">    (See &#39;collect&#39; operation to simply get all the data from the Frame)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param n: (int) The number of rows to get from the frame (warning: do not overwhelm the python session</span>
<span class="sd">                    by taking too much)</span>
<span class="sd">    :param offset: (Optional[int]) The number of rows to skip before starting to copy.</span>
<span class="sd">    :param columns: (Optional[str or list[str]) If not None, only the given columns&#39; data will be provided.</span>
<span class="sd">                    By default, all columns are included.</span>
<span class="sd">    :return: (list[list[data]]) raw frame data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider the following frame:</span>
<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      age  tenure  phone</span>
<span class="sd">        ====================================</span>
<span class="sd">        [0]  Fred       39      16  555-1234</span>
<span class="sd">        [1]  Susan      33       3  555-0202</span>
<span class="sd">        [2]  Thurston   65      26  555-4510</span>
<span class="sd">        [3]  Judy       44      14  555-2183</span>

<span class="sd">    Use take to get the first two rows and look at the schema and data in the result:</span>

<span class="sd">        &gt;&gt;&gt; frame.take(2)</span>
<span class="sd">        [[&#39;Fred&#39;, 39, 16, &#39;555-1234&#39;], [&#39;Susan&#39;, 33, 3, &#39;555-0202&#39;]]</span>

<span class="sd">    Limit the columns in our result to just the name and age column:</span>

<span class="sd">        &gt;&gt;&gt; frame.take(2, columns=[&#39;name&#39;, &#39;age&#39;])</span>
<span class="sd">        [[&#39;Fred&#39;, 39], [&#39;Susan&#39;, 33]]</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">require_type</span><span class="o">.</span><span class="n">non_negative_int</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
    <span class="n">require_type</span><span class="o">.</span><span class="n">non_negative_int</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s">&quot;offset&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">affirm_type</span><span class="o">.</span><span class="n">list_of_str</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s">&quot;columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scala</span><span class="p">:</span>
        <span class="n">scala_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option_list_string</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">get_schema_for_columns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span> <span class="k">if</span> <span class="n">columns</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">TakeCollectHelper</span><span class="o">.</span><span class="n">scala_rows_to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="n">scala_data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">require_type</span><span class="o">.</span><span class="n">non_negative_int</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_take_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">select_columns</span> <span class="o">=</span> <span class="n">TakeCollectHelper</span><span class="o">.</span><span class="n">get_select_columns_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">select_columns</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.tally">
    <p>def <span class="ident">tally</span>(</p><p>self, sample_col, count_val)</p>
    </div>
    

    
  
    <div class="desc"><p>Count number of times a value is seen.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>sample_col</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the cumulative count.
</td></tr></table>

<table><tr><td class='param-name'>count_val</td><td class='param-type'>(str):</td><td class='param-desc'>The column value to be used for the counts.</td></tr></table>

<p>A cumulative count is computed by sequentially stepping through the rows,
observing the column values and keeping track of the number of times the specified
<em>count_value</em> has been seen.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which accesses a frame that contains a single
column named <em>obs</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs
========
[0]    0
[1]    1
[2]    2
[3]    0
[4]    1
[5]    2
</pre></div>


<p>The cumulative percent count for column <em>obs</em> is obtained by:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.tally(&quot;obs&quot;, &quot;1&quot;)
[===Job Progress===]
</pre></div>


<p>The Frame <em>my_frame</em> accesses the original frame that now contains two
columns, <em>obs</em> that contains the original column values, and
<em>obsCumulativePercentCount</em> that contains the cumulative percent count:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs  obs_tally
===================
[0]    0        0.0
[1]    1        1.0
[2]    2        1.0
[3]    0        1.0
[4]    1        2.0
[5]    2        2.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.tally', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.tally" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">tally</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_col</span><span class="p">,</span> <span class="n">count_val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count number of times a value is seen.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param sample_col: (str) The name of the column from which to compute the cumulative count.</span>
<span class="sd">    :param count_val: (str) The column value to be used for the counts.</span>

<span class="sd">    A cumulative count is computed by sequentially stepping through the rows,</span>
<span class="sd">    observing the column values and keeping track of the number of times the specified</span>
<span class="sd">    *count_value* has been seen.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame*, which accesses a frame that contains a single</span>
<span class="sd">    column named *obs*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    0</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    0</span>
<span class="sd">        [4]    1</span>
<span class="sd">        [5]    2</span>

<span class="sd">    The cumulative percent count for column *obs* is obtained by:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.tally(&quot;obs&quot;, &quot;1&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    The Frame *my_frame* accesses the original frame that now contains two</span>
<span class="sd">    columns, *obs* that contains the original column values, and</span>
<span class="sd">    *obsCumulativePercentCount* that contains the cumulative percent count:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs  obs_tally</span>
<span class="sd">        ===================</span>
<span class="sd">        [0]    0        0.0</span>
<span class="sd">        [1]    1        1.0</span>
<span class="sd">        [2]    2        1.0</span>
<span class="sd">        [3]    0        1.0</span>
<span class="sd">        [4]    1        2.0</span>
<span class="sd">        [5]    2        2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">tally</span><span class="p">(</span><span class="n">sample_col</span><span class="p">,</span> <span class="n">count_val</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.tally_percent">
    <p>def <span class="ident">tally_percent</span>(</p><p>self, sample_col, count_val)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute a cumulative percent count.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>sample_col</td><td class='param-type'>(str):</td><td class='param-desc'>The name of the column from which to compute the cumulative sum.
</td></tr></table>

<table><tr><td class='param-name'>count_val</td><td class='param-type'>(str):</td><td class='param-desc'>The column value to be used for the counts.</td></tr></table>

<p>A cumulative percent count is computed by sequentially stepping through
the rows, observing the column values and keeping track of the percentage of the
total number of times the specified <em>count_value</em> has been seen up to
the current value.</p>
<div class='section-header'>Examples:</div>

<p>Consider Frame <em>my_frame</em>, which accesses a frame that contains a single
column named <em>obs</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs
========
[0]    0
[1]    1
[2]    2
[3]    0
[4]    1
[5]    2
</pre></div>


<p>The cumulative percent count for column <em>obs</em> is obtained by:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.tally_percent(&quot;obs&quot;, &quot;1&quot;)
[===Job Progress===]
</pre></div>


<p>The Frame <em>my_frame</em> accesses the original frame that now contains two
columns, <em>obs</em> that contains the original column values, and
<em>obsCumulativePercentCount</em> that contains the cumulative percent count:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect()
[#]  obs  obs_tally_percent
===========================
[0]    0                0.0
[1]    1                0.5
[2]    2                0.5
[3]    0                0.5
[4]    1                1.0
[5]    2                1.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.tally_percent', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.tally_percent" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">tally_percent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_col</span><span class="p">,</span> <span class="n">count_val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a cumulative percent count.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param sample_col: (str) The name of the column from which to compute the cumulative sum.</span>
<span class="sd">    :param count_val: (str) The column value to be used for the counts.</span>

<span class="sd">    A cumulative percent count is computed by sequentially stepping through</span>
<span class="sd">    the rows, observing the column values and keeping track of the percentage of the</span>
<span class="sd">    total number of times the specified *count_value* has been seen up to</span>
<span class="sd">    the current value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider Frame *my_frame*, which accesses a frame that contains a single</span>
<span class="sd">    column named *obs*:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs</span>
<span class="sd">        ========</span>
<span class="sd">        [0]    0</span>
<span class="sd">        [1]    1</span>
<span class="sd">        [2]    2</span>
<span class="sd">        [3]    0</span>
<span class="sd">        [4]    1</span>
<span class="sd">        [5]    2</span>

<span class="sd">    The cumulative percent count for column *obs* is obtained by:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.tally_percent(&quot;obs&quot;, &quot;1&quot;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    The Frame *my_frame* accesses the original frame that now contains two</span>
<span class="sd">    columns, *obs* that contains the original column values, and</span>
<span class="sd">    *obsCumulativePercentCount* that contains the cumulative percent count:</span>

<span class="sd">        &gt;&gt;&gt; my_frame.inspect()</span>
<span class="sd">        [#]  obs  obs_tally_percent</span>
<span class="sd">        ===========================</span>
<span class="sd">        [0]    0                0.0</span>
<span class="sd">        [1]    1                0.5</span>
<span class="sd">        [2]    2                0.5</span>
<span class="sd">        [3]    0                0.5</span>
<span class="sd">        [4]    1                1.0</span>
<span class="sd">        [5]    2                1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">tallyPercent</span><span class="p">(</span><span class="n">sample_col</span><span class="p">,</span> <span class="n">count_val</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_augmented_dickey_fuller_test">
    <p>def <span class="ident">timeseries_augmented_dickey_fuller_test</span>(</p><p>self, ts_column, max_lag, regression=&#39;c&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs the Augmented Dickey-Fuller (ADF) Test, which tests the null hypothesis of whether a unit root is present
in a time series sample. The test statistic that is returned in a negative number.  The lower the value, the
stronger the rejection of the hypothesis that there is a unit root at some level of confidence.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>ts_column</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column that contains the time series values to use with the ADF test.
</td></tr></table>

<table><tr><td class='param-name'>max_lag</td><td class='param-type'>(int):</td><td class='param-desc'>The lag order to calculate the test statistic.
</td></tr></table>

<table><tr><td class='param-name'>regression</td><td class='param-type'>(Optional(str)):</td><td class='param-desc'>The method of regression that was used. Following MacKinnon's notation, this
                   can be "c" for constant, "nc" for no constant, "ct" for constant and trend, and "ctt" for
                   constant, trend, and trend-squared.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(AugmentedDickeyFullerTestResult): </td><td class='param-desc'>Object contains the ADF test statistic and p-value.</td></tr></table></p>

<div class='section-header'>Example:</div>

<p>Consider the following frame of time series values:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  timeseries_values
======================
[0]              3.201
[1]             3.3178
[2]             3.6279
[3]             3.5902
[4]               3.43
[5]             4.0546
[6]             3.7606
[7]             3.1231
[8]             3.2077
[9]             4.3383
</pre></div>


<p>Calculate augmented Dickey-Fuller test statistic by giving it the name of the column that has the time series
values and the max_lag.  The function returns an object that has properties for the p-value and test statistic.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.timeseries_augmented_dickey_fuller_test(&quot;timeseries_values&quot;, 0)
p_value   = 0.0
test_stat = -9.93422373369
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_augmented_dickey_fuller_test', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_augmented_dickey_fuller_test" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_augmented_dickey_fuller_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_column</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">regression</span> <span class="o">=</span> <span class="s">&quot;c&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the Augmented Dickey-Fuller (ADF) Test, which tests the null hypothesis of whether a unit root is present</span>
<span class="sd">    in a time series sample. The test statistic that is returned in a negative number.  The lower the value, the</span>
<span class="sd">    stronger the rejection of the hypothesis that there is a unit root at some level of confidence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param ts_column: (str) Name of the column that contains the time series values to use with the ADF test.</span>
<span class="sd">    :param max_lag: (int) The lag order to calculate the test statistic.</span>
<span class="sd">    :param regression: (Optional(str)) The method of regression that was used. Following MacKinnon&#39;s notation, this</span>
<span class="sd">                       can be &quot;c&quot; for constant, &quot;nc&quot; for no constant, &quot;ct&quot; for constant and trend, and &quot;ctt&quot; for</span>
<span class="sd">                       constant, trend, and trend-squared.</span>
<span class="sd">    :return: (AugmentedDickeyFullerTestResult) Object contains the ADF test statistic and p-value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>


<span class="sd">    Consider the following frame of time series values:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  timeseries_values</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]              3.201</span>
<span class="sd">        [1]             3.3178</span>
<span class="sd">        [2]             3.6279</span>
<span class="sd">        [3]             3.5902</span>
<span class="sd">        [4]               3.43</span>
<span class="sd">        [5]             4.0546</span>
<span class="sd">        [6]             3.7606</span>
<span class="sd">        [7]             3.1231</span>
<span class="sd">        [8]             3.2077</span>
<span class="sd">        [9]             4.3383</span>

<span class="sd">    Calculate augmented Dickey-Fuller test statistic by giving it the name of the column that has the time series</span>
<span class="sd">    values and the max_lag.  The function returns an object that has properties for the p-value and test statistic.</span>

<span class="sd">        &gt;&gt;&gt; frame.timeseries_augmented_dickey_fuller_test(&quot;timeseries_values&quot;, 0)</span>
<span class="sd">        p_value   = 0.0</span>
<span class="sd">        test_stat = -9.93422373369</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts_column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;ts_column parameter should be a str&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;max_lag parameter should be a int&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regression</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;regression parameter should be a str&quot;</span><span class="p">)</span>

    <span class="n">scala_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesAugmentedDickeyFullerTest</span><span class="p">(</span><span class="n">ts_column</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">regression</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AugmentedDickeyFullerTestResult</span><span class="p">(</span><span class="n">scala_result</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_breusch_godfrey_test">
    <p>def <span class="ident">timeseries_breusch_godfrey_test</span>(</p><p>self, residuals, factors, max_lag)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the Breusch-Godfrey test statistic for serial correlation.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>residuals</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column that contains residual (y) values
</td></tr></table>

<table><tr><td class='param-name'>factors</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Name of the column(s) that contain factors (x) values
</td></tr></table>

<table><tr><td class='param-name'>max_lag</td><td class='param-type'>(int):</td><td class='param-desc'>The lag order to calculate the test statistic.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(BreuschGodfreyTestResult): </td><td class='param-desc'>Object contains the Breusch-Godfrey test statistic and p-value.</td></tr></table></p>

<div class='section-header'>Example:</div>

<p>Consider the following frame that uses a snippet of air quality and sensor data from:</p>
<p>https://archive.ics.uci.edu/ml/datasets/Air+Quality.</p>
<p>Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml].
Irvine, CA: University of California, School of Information and Computer Science.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  Date        Time      CO_GT  PT08_S1_CO  NMHC_GT  C6H6_GT  Temp
====================================================================
[0]  10/03/2004  18.00.00    2.6        1360      150     11.9  13.6
[1]  10/03/2004  19.00.00    2.0        1292      112      9.4  13.3
[2]  10/03/2004  20.00.00    2.2        1402       88      9.0  11.9
[3]  10/03/2004  21.00.00    2.2        1376       80      9.2  11.0
[4]  10/03/2004  22.00.00    1.6        1272       51      6.5  11.2
[5]  10/03/2004  23.00.00    1.2        1197       38      4.7  11.2
[6]  11/03/2004  00.00.00    1.2        1185       31      3.6  11.3
[7]  11/03/2004  01.00.00    1.0        1136       31      3.3  10.7
[8]  11/03/2004  02.00.00    0.9        1094       24      2.3  10.7
[9]  11/03/2004  03.00.00    0.6        1010       19      1.7  10.3
</pre></div>


<p>Calcuate the Breusch-Godfrey test result:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; y_column = &quot;Temp&quot;
&gt;&gt;&gt; x_columns = [&#39;CO_GT&#39;, &#39;PT08_S1_CO&#39;, &#39;NMHC_GT&#39;, &#39;C6H6_GT&#39;]
&gt;&gt;&gt; max_lag = 1

&gt;&gt;&gt; result = frame.timeseries_breusch_godfrey_test(y_column, x_columns, max_lag)

&gt;&gt;&gt; result
p_value   = 0.00353847462468
test_stat = 8.50666768455
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_breusch_godfrey_test', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_breusch_godfrey_test" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_breusch_godfrey_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Breusch-Godfrey test statistic for serial correlation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param residuals: (str) Name of the column that contains residual (y) values</span>
<span class="sd">    :param factors: (List[str]) Name of the column(s) that contain factors (x) values</span>
<span class="sd">    :param max_lag: (int) The lag order to calculate the test statistic.</span>
<span class="sd">    :return: (BreuschGodfreyTestResult) Object contains the Breusch-Godfrey test statistic and p-value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>


<span class="sd">    Consider the following frame that uses a snippet of air quality and sensor data from:</span>

<span class="sd">    https://archive.ics.uci.edu/ml/datasets/Air+Quality.</span>

<span class="sd">    Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml].</span>
<span class="sd">    Irvine, CA: University of California, School of Information and Computer Science.</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  Date        Time      CO_GT  PT08_S1_CO  NMHC_GT  C6H6_GT  Temp</span>
<span class="sd">        ====================================================================</span>
<span class="sd">        [0]  10/03/2004  18.00.00    2.6        1360      150     11.9  13.6</span>
<span class="sd">        [1]  10/03/2004  19.00.00    2.0        1292      112      9.4  13.3</span>
<span class="sd">        [2]  10/03/2004  20.00.00    2.2        1402       88      9.0  11.9</span>
<span class="sd">        [3]  10/03/2004  21.00.00    2.2        1376       80      9.2  11.0</span>
<span class="sd">        [4]  10/03/2004  22.00.00    1.6        1272       51      6.5  11.2</span>
<span class="sd">        [5]  10/03/2004  23.00.00    1.2        1197       38      4.7  11.2</span>
<span class="sd">        [6]  11/03/2004  00.00.00    1.2        1185       31      3.6  11.3</span>
<span class="sd">        [7]  11/03/2004  01.00.00    1.0        1136       31      3.3  10.7</span>
<span class="sd">        [8]  11/03/2004  02.00.00    0.9        1094       24      2.3  10.7</span>
<span class="sd">        [9]  11/03/2004  03.00.00    0.6        1010       19      1.7  10.3</span>


<span class="sd">    Calcuate the Breusch-Godfrey test result:</span>

<span class="sd">        &gt;&gt;&gt; y_column = &quot;Temp&quot;</span>
<span class="sd">        &gt;&gt;&gt; x_columns = [&#39;CO_GT&#39;, &#39;PT08_S1_CO&#39;, &#39;NMHC_GT&#39;, &#39;C6H6_GT&#39;]</span>
<span class="sd">        &gt;&gt;&gt; max_lag = 1</span>

<span class="sd">        &gt;&gt;&gt; result = frame.timeseries_breusch_godfrey_test(y_column, x_columns, max_lag)</span>

<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        p_value   = 0.00353847462468</span>
<span class="sd">        test_stat = 8.50666768455</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;residuals parameter should be a str (column name).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;factors parameter should be a list of strings (column names).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;max_lag parameter should be an integer.&quot;</span><span class="p">)</span>

    <span class="n">scala_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesBreuschGodfreyTest</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span>
                                                      <span class="n">max_lag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BreuschGodfreyTestResult</span><span class="p">(</span><span class="n">scala_result</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_breusch_pagan_test">
    <p>def <span class="ident">timeseries_breusch_pagan_test</span>(</p><p>self, residuals, factors)</p>
    </div>
    

    
  
    <div class="desc"><p>Peforms the Breusch-Pagan test for heteroskedasticity.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>residuals</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column that contains residual (y) values
</td></tr></table>

<table><tr><td class='param-name'>factors</td><td class='param-type'>(List[str]):</td><td class='param-desc'>Name of the column(s) that contain factors (x) values
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(BreuschPaganTestResult): </td><td class='param-desc'>Object contains the Breusch-Pagan test statistic and p-value.</td></tr></table></p>

<div class='section-header'>Example:</div>

<p>Consider the following frame:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  AT     V      AP       RH     PE
=========================================
[0]   8.34  40.77  1010.84  90.01  480.48
[1]  23.64  58.49   1011.4   74.2  445.75
[2]  29.74   56.9  1007.15  41.91  438.76
[3]  19.07  49.69  1007.22  76.79  453.09
[4]   11.8  40.66  1017.13   97.2  464.43
[5]  13.97  39.16  1016.05   84.6  470.96
[6]   22.1  71.29   1008.2  75.38  442.35
[7]  14.47  41.76  1021.98  78.41     464
[8]  31.25  69.51  1010.25  36.83  428.77
[9]   6.77  38.18   1017.8  81.13   484.3
</pre></div>


<p>Calculate the Bruesh-Pagan test statistic where the "AT" column contains residual values and the other columns are
factors:</p>
<blockquote>
<blockquote>
<blockquote>
<p>result = frame.timeseries_breusch_pagan_test("AT",["V","AP","RH","PE"])
[===Job Progress===]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The result contains the test statistic and p-value:</p>
<blockquote>
<blockquote>
<blockquote>
<p>result
p_value   = 0.000147089380721
test_stat = 22.6741588802</p>
</blockquote>
</blockquote>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_breusch_pagan_test', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_breusch_pagan_test" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_breusch_pagan_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Peforms the Breusch-Pagan test for heteroskedasticity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param residuals: (str) Name of the column that contains residual (y) values</span>
<span class="sd">    :param factors: (List[str]) Name of the column(s) that contain factors (x) values</span>
<span class="sd">    :return: (BreuschPaganTestResult) Object contains the Breusch-Pagan test statistic and p-value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>


<span class="sd">    Consider the following frame:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  AT     V      AP       RH     PE</span>
<span class="sd">        =========================================</span>
<span class="sd">        [0]   8.34  40.77  1010.84  90.01  480.48</span>
<span class="sd">        [1]  23.64  58.49   1011.4   74.2  445.75</span>
<span class="sd">        [2]  29.74   56.9  1007.15  41.91  438.76</span>
<span class="sd">        [3]  19.07  49.69  1007.22  76.79  453.09</span>
<span class="sd">        [4]   11.8  40.66  1017.13   97.2  464.43</span>
<span class="sd">        [5]  13.97  39.16  1016.05   84.6  470.96</span>
<span class="sd">        [6]   22.1  71.29   1008.2  75.38  442.35</span>
<span class="sd">        [7]  14.47  41.76  1021.98  78.41     464</span>
<span class="sd">        [8]  31.25  69.51  1010.25  36.83  428.77</span>
<span class="sd">        [9]   6.77  38.18   1017.8  81.13   484.3</span>

<span class="sd">    Calculate the Bruesh-Pagan test statistic where the &quot;AT&quot; column contains residual values and the other columns are</span>
<span class="sd">    factors:</span>

<span class="sd">    &gt;&gt;&gt; result = frame.timeseries_breusch_pagan_test(&quot;AT&quot;,[&quot;V&quot;,&quot;AP&quot;,&quot;RH&quot;,&quot;PE&quot;])</span>
<span class="sd">    [===Job Progress===]</span>

<span class="sd">    The result contains the test statistic and p-value:</span>

<span class="sd">    &gt;&gt;&gt; result</span>
<span class="sd">    p_value   = 0.000147089380721</span>
<span class="sd">    test_stat = 22.6741588802</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;residuals parameter should be a str (column name).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;factors parameter should be a list of strings (column names).&quot;</span><span class="p">)</span>

    <span class="n">scala_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesBreuschPaganTest</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">BreuschPaganTestResult</span><span class="p">(</span><span class="n">scala_result</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_durbin_watson_test">
    <p>def <span class="ident">timeseries_durbin_watson_test</span>(</p><p>self, residuals)</p>
    </div>
    

    
  
    <div class="desc"><p>Computes the Durbin-Watson test statistic used to determine the presence of serial correlation in the residuals.
Serial correlation can show a relationship between values separated from each other by a given time lag. A value
close to 0.0 gives evidence for positive serial correlation, a value close to 4.0 gives evidence for negative
serial correlation, and a value close to 2.0 gives evidence for no serial correlation.</p>
<table><tr><td class='param-name'>residuals</td><td class='param-type'>(str):</td><td class='param-desc'>Name of the column that contains residual values
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns: </td><td class='param-desc'>Durbin-Watson statistics test</td></tr></table></p>

<div class='section-header'>Example:</div>

<p>In this example, we have a frame that contains time series values.  The inspect command below shows a snippet of
what the data looks like:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  timeseries_values
======================
[0]              3.201
[1]             3.3178
[2]             3.6279
[3]             3.5902
[4]               3.43
[5]             4.0546
[6]             3.7606
[7]             3.1231
[8]             3.2077
[9]             4.3383
</pre></div>


<p>Calculate Durbin-Watson test statistic by giving it the name of the column that has the time series values:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.timeseries_durbin_watson_test(&quot;timeseries_values&quot;)
0.02678674777710402
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_durbin_watson_test', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_durbin_watson_test" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_durbin_watson_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Durbin-Watson test statistic used to determine the presence of serial correlation in the residuals.</span>
<span class="sd">    Serial correlation can show a relationship between values separated from each other by a given time lag. A value</span>
<span class="sd">    close to 0.0 gives evidence for positive serial correlation, a value close to 4.0 gives evidence for negative</span>
<span class="sd">    serial correlation, and a value close to 2.0 gives evidence for no serial correlation.</span>

<span class="sd">    :param residuals: (str) Name of the column that contains residual values</span>
<span class="sd">    :return: Durbin-Watson statistics test</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>


<span class="sd">    In this example, we have a frame that contains time series values.  The inspect command below shows a snippet of</span>
<span class="sd">    what the data looks like:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  timeseries_values</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]              3.201</span>
<span class="sd">        [1]             3.3178</span>
<span class="sd">        [2]             3.6279</span>
<span class="sd">        [3]             3.5902</span>
<span class="sd">        [4]               3.43</span>
<span class="sd">        [5]             4.0546</span>
<span class="sd">        [6]             3.7606</span>
<span class="sd">        [7]             3.1231</span>
<span class="sd">        [8]             3.2077</span>
<span class="sd">        [9]             4.3383</span>

<span class="sd">    Calculate Durbin-Watson test statistic by giving it the name of the column that has the time series values:</span>

<span class="sd">        &gt;&gt;&gt; frame.timeseries_durbin_watson_test(&quot;timeseries_values&quot;)</span>
<span class="sd">        0.02678674777710402</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;residuals should be a str (column name).&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesDurbinWatsonTest</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_from_observations">
    <p>def <span class="ident">timeseries_from_observations</span>(</p><p>self, date_time_index, timestamp_column, key_column, value_column)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a frame that has the observations formatted as a time series.</p>
<table><tr><td class='param-name'>date_time_index: </td><td class='param-desc'>List of date/time strings. DateTimeIndex to conform all series to.
</td></tr></table>

<table><tr><td class='param-name'>timestamp_column: </td><td class='param-desc'>The name of the column telling when the observation occurred.
</td></tr></table>

<table><tr><td class='param-name'>key_column: </td><td class='param-desc'>The name of the column that contains which string key the observation belongs to.
</td></tr></table>

<table><tr><td class='param-name'>value_column: </td><td class='param-desc'>The name of the column that contains the observed value.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns: </td><td class='param-desc'>Frame formatted as a time series (with a column for key and a column for the vector of values).</td></tr></table></p>

<p>Uses the specified timestamp, key, and value columns and the date/time index provided to format the observations
as a time series.  The time series frame will have columns for the key and a vector of the observed values that
correspond to the date/time index.</p>
<div class='section-header'>Examples:</div>

<p>In this example, we will use a frame of observations of resting heart rate for three individuals over three days.
The data is accessed from Frame object called <em>my_frame</em>:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; my_frame.inspect(my_frame.count())
[#]  name     date                  resting_heart_rate
======================================================
[0]  Edward   2016-01-01T12:00:00Z                  62
[1]  Stanley  2016-01-01T12:00:00Z                  57
[2]  Edward   2016-01-02T12:00:00Z                  63
[3]  Sarah    2016-01-02T12:00:00Z                  64
[4]  Stanley  2016-01-02T12:00:00Z                  57
[5]  Edward   2016-01-03T12:00:00Z                  62
[6]  Sarah    2016-01-03T12:00:00Z                  64
[7]  Stanley  2016-01-03T12:00:00Z                  56
</pre></div>


<p>We then need to create an array that contains the date/time index,
which will be used when creating the time series.  Since our data
is for three days, our date/time index will just contain those
three dates:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; datetimeindex = [&quot;2016-01-01T12:00:00.000Z&quot;,&quot;2016-01-02T12:00:00.000Z&quot;,&quot;2016-01-03T12:00:00.000Z&quot;]
</pre></div>


<p>Then we can create our time series frame by specifying our date/time
index along with the name of our timestamp column (in this example, it's
 "date"), key column (in this example, it's "name"), and value column (in
this example, it's "resting_heart_rate").</p>
<div class="codehilite"><pre> &gt;&gt;&gt; ts = my_frame.timeseries_from_observations(datetimeindex, &quot;date&quot;, &quot;name&quot;, &quot;resting_heart_rate&quot;)
 [===Job Progress===]
</pre></div>


<p>Take a look at the resulting time series frame schema and contents:</p>
<div class="codehilite"><pre> &gt;&gt;&gt; ts.schema
 [(u&#39;name&#39;, &lt;type &#39;unicode&#39;&gt;), (u&#39;resting_heart_rate&#39;, vector(3))]

 &gt;&gt;&gt; ts.inspect()
 [#]  name     resting_heart_rate
 ================================
 [0]  Stanley  [57.0, 57.0, 56.0]
 [1]  Edward   [62.0, 63.0, 62.0]
 [2]  Sarah    [None, 64.0, 64.0]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_from_observations', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_from_observations" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_from_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date_time_index</span><span class="p">,</span> <span class="n">timestamp_column</span><span class="p">,</span> <span class="n">key_column</span><span class="p">,</span> <span class="n">value_column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a frame that has the observations formatted as a time series.</span>

<span class="sd">    :param date_time_index: List of date/time strings. DateTimeIndex to conform all series to.</span>
<span class="sd">    :param timestamp_column: The name of the column telling when the observation occurred.</span>
<span class="sd">    :param key_column: The name of the column that contains which string key the observation belongs to.</span>
<span class="sd">    :param value_column: The name of the column that contains the observed value.</span>
<span class="sd">    :return: Frame formatted as a time series (with a column for key and a column for the vector of values).</span>

<span class="sd">    Uses the specified timestamp, key, and value columns and the date/time index provided to format the observations</span>
<span class="sd">    as a time series.  The time series frame will have columns for the key and a vector of the observed values that</span>
<span class="sd">    correspond to the date/time index.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will use a frame of observations of resting heart rate for three individuals over three days.</span>
<span class="sd">    The data is accessed from Frame object called *my_frame*:</span>


<span class="sd">        &gt;&gt;&gt; my_frame.inspect(my_frame.count())</span>
<span class="sd">        [#]  name     date                  resting_heart_rate</span>
<span class="sd">        ======================================================</span>
<span class="sd">        [0]  Edward   2016-01-01T12:00:00Z                  62</span>
<span class="sd">        [1]  Stanley  2016-01-01T12:00:00Z                  57</span>
<span class="sd">        [2]  Edward   2016-01-02T12:00:00Z                  63</span>
<span class="sd">        [3]  Sarah    2016-01-02T12:00:00Z                  64</span>
<span class="sd">        [4]  Stanley  2016-01-02T12:00:00Z                  57</span>
<span class="sd">        [5]  Edward   2016-01-03T12:00:00Z                  62</span>
<span class="sd">        [6]  Sarah    2016-01-03T12:00:00Z                  64</span>
<span class="sd">        [7]  Stanley  2016-01-03T12:00:00Z                  56</span>

<span class="sd">    We then need to create an array that contains the date/time index,</span>
<span class="sd">    which will be used when creating the time series.  Since our data</span>
<span class="sd">    is for three days, our date/time index will just contain those</span>
<span class="sd">    three dates:</span>

<span class="sd">        &gt;&gt;&gt; datetimeindex = [&quot;2016-01-01T12:00:00.000Z&quot;,&quot;2016-01-02T12:00:00.000Z&quot;,&quot;2016-01-03T12:00:00.000Z&quot;]</span>

<span class="sd">    Then we can create our time series frame by specifying our date/time</span>
<span class="sd">    index along with the name of our timestamp column (in this example, it&#39;s</span>
<span class="sd">     &quot;date&quot;), key column (in this example, it&#39;s &quot;name&quot;), and value column (in</span>
<span class="sd">    this example, it&#39;s &quot;resting_heart_rate&quot;).</span>

<span class="sd">         &gt;&gt;&gt; ts = my_frame.timeseries_from_observations(datetimeindex, &quot;date&quot;, &quot;name&quot;, &quot;resting_heart_rate&quot;)</span>
<span class="sd">         [===Job Progress===]</span>

<span class="sd">    Take a look at the resulting time series frame schema and contents:</span>

<span class="sd">         &gt;&gt;&gt; ts.schema</span>
<span class="sd">         [(u&#39;name&#39;, &lt;type &#39;unicode&#39;&gt;), (u&#39;resting_heart_rate&#39;, vector(3))]</span>

<span class="sd">         &gt;&gt;&gt; ts.inspect()</span>
<span class="sd">         [#]  name     resting_heart_rate</span>
<span class="sd">         ================================</span>
<span class="sd">         [0]  Stanley  [57.0, 57.0, 56.0]</span>
<span class="sd">         [1]  Edward   [62.0, 63.0, 62.0]</span>
<span class="sd">         [2]  Sarah    [None, 64.0, 64.0]</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">date_time_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;date_time_index should be a list of date/times&quot;</span><span class="p">)</span>

    <span class="n">scala_date_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_date_time_list</span><span class="p">(</span><span class="n">date_time_index</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesFromObseravations</span><span class="p">(</span><span class="n">scala_date_list</span><span class="p">,</span> <span class="n">timestamp_column</span><span class="p">,</span> <span class="n">key_column</span><span class="p">,</span> <span class="n">value_column</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.timeseries_slice">
    <p>def <span class="ident">timeseries_slice</span>(</p><p>self, date_time_index, start, end)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a frame split on the specified start and end date/times.</p>
<p>Splits a time series frame on the specified start and end date/times.</p>
<table><tr><td class='param-name'>date_time_index: </td><td class='param-desc'>List of date/time strings. DateTimeIndex to conform all series to.
</td></tr></table>

<table><tr><td class='param-name'>start: </td><td class='param-desc'>The start date for the slice in the ISO 8601 format, like: yyyy-MM-dd'T'HH:mm:ss.SSSZ
</td></tr></table>

<table><tr><td class='param-name'>end: </td><td class='param-desc'>The end date for the slice in the ISO 8601 format, like: yyyy-MM-dd'T'HH:mm:ss.SSSZ
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns: </td><td class='param-desc'>Frame that contains a sub-slice of the current frame, based on the specified start/end date/times.</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>For this example, we start with a frame that has already been formatted as a time series.
This means that the frame has a string column for key and a vector column that contains
a series of the observed values.  We must also know the date/time index that corresponds
to the time series.</p>
<p>The time series is in a Frame object called <em>ts_frame</em>.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; ts_frame.inspect()
[#]  key  series
==================================
[0]  A    [62, 55, 60, 61, 60, 59]
[1]  B    [60, 58, 61, 62, 60, 61]
[2]  C    [69, 68, 68, 70, 71, 69]
</pre></div>


<p>Next, we define the date/time index.  In this example, it is one day intervals from
2016-01-01 to 2016-01-06:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; datetimeindex = [&quot;2016-01-01T12:00:00.000Z&quot;,&quot;2016-01-02T12:00:00.000Z&quot;,&quot;2016-01-03T12:00:00.000Z&quot;,&quot;2016-01-04T12:00:00.000Z&quot;,&quot;2016-01-05T12:00:00.000Z&quot;,&quot;2016-01-06T12:00:00.000Z&quot;]
</pre></div>


<p>Get a slice of our time series from 2016-01-02 to 2016-01-04:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; slice_start = &quot;2016-01-02T12:00:00.000Z&quot;
&gt;&gt;&gt; slice_end = &quot;2016-01-04T12:00:00.000Z&quot;

&gt;&gt;&gt; sliced_frame = ts_frame.timeseries_slice(datetimeindex, slice_start, slice_end)
[===Job Progress===]
</pre></div>


<p>Take a look at our sliced time series:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; sliced_frame.inspect()
[#]  key  series
============================
[0]  A    [55.0, 60.0, 61.0]
[1]  B    [58.0, 61.0, 62.0]
[2]  C    [68.0, 68.0, 70.0]
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.timeseries_slice', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.timeseries_slice" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">timeseries_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date_time_index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a frame split on the specified start and end date/times.</span>

<span class="sd">    Splits a time series frame on the specified start and end date/times.</span>

<span class="sd">    :param date_time_index: List of date/time strings. DateTimeIndex to conform all series to.</span>
<span class="sd">    :param start: The start date for the slice in the ISO 8601 format, like: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span>
<span class="sd">    :param end: The end date for the slice in the ISO 8601 format, like: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span>
<span class="sd">    :return: Frame that contains a sub-slice of the current frame, based on the specified start/end date/times.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For this example, we start with a frame that has already been formatted as a time series.</span>
<span class="sd">    This means that the frame has a string column for key and a vector column that contains</span>
<span class="sd">    a series of the observed values.  We must also know the date/time index that corresponds</span>
<span class="sd">    to the time series.</span>

<span class="sd">    The time series is in a Frame object called *ts_frame*.</span>


<span class="sd">        &gt;&gt;&gt; ts_frame.inspect()</span>
<span class="sd">        [#]  key  series</span>
<span class="sd">        ==================================</span>
<span class="sd">        [0]  A    [62, 55, 60, 61, 60, 59]</span>
<span class="sd">        [1]  B    [60, 58, 61, 62, 60, 61]</span>
<span class="sd">        [2]  C    [69, 68, 68, 70, 71, 69]</span>

<span class="sd">    Next, we define the date/time index.  In this example, it is one day intervals from</span>
<span class="sd">    2016-01-01 to 2016-01-06:</span>

<span class="sd">        &gt;&gt;&gt; datetimeindex = [&quot;2016-01-01T12:00:00.000Z&quot;,&quot;2016-01-02T12:00:00.000Z&quot;,&quot;2016-01-03T12:00:00.000Z&quot;,&quot;2016-01-04T12:00:00.000Z&quot;,&quot;2016-01-05T12:00:00.000Z&quot;,&quot;2016-01-06T12:00:00.000Z&quot;]</span>

<span class="sd">    Get a slice of our time series from 2016-01-02 to 2016-01-04:</span>

<span class="sd">        &gt;&gt;&gt; slice_start = &quot;2016-01-02T12:00:00.000Z&quot;</span>
<span class="sd">        &gt;&gt;&gt; slice_end = &quot;2016-01-04T12:00:00.000Z&quot;</span>

<span class="sd">        &gt;&gt;&gt; sliced_frame = ts_frame.timeseries_slice(datetimeindex, slice_start, slice_end)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Take a look at our sliced time series:</span>

<span class="sd">        &gt;&gt;&gt; sliced_frame.inspect()</span>
<span class="sd">        [#]  key  series</span>
<span class="sd">        ============================</span>
<span class="sd">        [0]  A    [55.0, 60.0, 61.0]</span>
<span class="sd">        [1]  B    [58.0, 61.0, 62.0]</span>
<span class="sd">        [2]  C    [68.0, 68.0, 70.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">date_time_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;date_time_index should be a list of date/times&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;start date/time should be a string in the ISO 8601 format&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;end date/time should be a string in the ISO 8601 format&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">timeSeriesSlice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_date_time_list</span><span class="p">(</span><span class="n">date_time_index</span><span class="p">),</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_date_time</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_date_time</span><span class="p">(</span><span class="n">end</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.to_pandas">
    <p>def <span class="ident">to_pandas</span>(</p><p>self, n=None, offset=0, columns=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Brings data into a local pandas dataframe.</p>
<p>Similar to the 'take' function, but puts the data into a pandas dataframe.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>n</td><td class='param-type'>(Optional(int)):</td><td class='param-desc'>The number of rows to get from the frame (warning: do not overwhelm the python session
                by taking too much)
</td></tr></table>

<table><tr><td class='param-name'>offset</td><td class='param-type'>(Optional(int)):</td><td class='param-desc'>The number of rows to skip before copying.  Defaults to 0.
</td></tr></table>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(Optional(List[str])):</td><td class='param-desc'>Column filter.  The list of names to be included.  Default is all columns.
</td></tr></table>

<p><table style='padding-top:10px'><tr><td class='param-name'>Returns</td><td class='param-type'>(pandas.DataFrame): </td><td class='param-desc'>A new pandas dataframe object containing the taken frame data.</td></tr></table></p>

<div class='section-header'>Examples:</div>

<p>Consider the following spark-tk frame, where we have columns for name and phone number:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  name      phone
=======================
[0]  Fred      555-1234
[1]  Susan     555-0202
[2]  Thurston  555-4510
[3]  Judy      555-2183

&gt;&gt;&gt; frame.schema
[(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;phone&#39;, &lt;type &#39;str&#39;&gt;)]
</pre></div>


<p>The frame to_pandas() method is used to get a pandas DataFrame that contains the data from the spark-tk frame.  Note
that since no parameters are provided when to_pandas() is called, the default values are used for the number of
rows, the row offset, and the columns.</p>
<div class="codehilite"><pre>&gt;&gt;&gt; pandas_frame = frame.to_pandas()
&gt;&gt;&gt; pandas_frame
       name     phone
0      Fred  555-1234
1     Susan  555-0202
2  Thurston  555-4510
3      Judy  555-2183
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.to_pandas', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.to_pandas" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Brings data into a local pandas dataframe.</span>

<span class="sd">    Similar to the &#39;take&#39; function, but puts the data into a pandas dataframe.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param n: (Optional(int)) The number of rows to get from the frame (warning: do not overwhelm the python session</span>
<span class="sd">                    by taking too much)</span>
<span class="sd">    :param offset: (Optional(int)) The number of rows to skip before copying.  Defaults to 0.</span>
<span class="sd">    :param columns: (Optional(List[str])) Column filter.  The list of names to be included.  Default is all columns.</span>
<span class="sd">    :return: (pandas.DataFrame) A new pandas dataframe object containing the taken frame data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Consider the following spark-tk frame, where we have columns for name and phone number:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  name      phone</span>
<span class="sd">        =======================</span>
<span class="sd">        [0]  Fred      555-1234</span>
<span class="sd">        [1]  Susan     555-0202</span>
<span class="sd">        [2]  Thurston  555-4510</span>
<span class="sd">        [3]  Judy      555-2183</span>

<span class="sd">        &gt;&gt;&gt; frame.schema</span>
<span class="sd">        [(&#39;name&#39;, &lt;type &#39;str&#39;&gt;), (&#39;phone&#39;, &lt;type &#39;str&#39;&gt;)]</span>

<span class="sd">    The frame to_pandas() method is used to get a pandas DataFrame that contains the data from the spark-tk frame.  Note</span>
<span class="sd">    that since no parameters are provided when to_pandas() is called, the default values are used for the number of</span>
<span class="sd">    rows, the row offset, and the columns.</span>

<span class="sd">        &gt;&gt;&gt; pandas_frame = frame.to_pandas()</span>
<span class="sd">        &gt;&gt;&gt; pandas_frame</span>
<span class="sd">               name     phone</span>
<span class="sd">        0      Fred  555-1234</span>
<span class="sd">        1     Susan  555-0202</span>
<span class="sd">        2  Thurston  555-4510</span>
<span class="sd">        3      Judy  555-2183</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pandas</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;pandas module not found, unable to download.  Install pandas or try the take command.&quot;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.ops.take</span> <span class="kn">import</span> <span class="n">take_rich</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">take_rich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
    <span class="n">headers</span><span class="p">,</span> <span class="n">data_types</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
    <span class="n">frame_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">data</span>

    <span class="kn">from</span> <span class="nn">sparktk</span> <span class="kn">import</span> <span class="n">dtypes</span>
    <span class="kn">import</span> <span class="nn">datetime</span>

    <span class="n">date_time_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)]</span>
    <span class="n">has_date_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">date_time_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c"># translate our datetime long to datetime, so that it gets into the pandas df as a datetime column</span>
    <span class="k">def</span> <span class="nf">long_to_date_time</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">date_time_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">long</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">//</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">has_date_time</span><span class="p">):</span>
        <span class="n">frame_data</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">long_to_date_time</span><span class="p">,</span> <span class="n">frame_data</span><span class="p">)</span>

    <span class="c"># create pandas df</span>
    <span class="n">pandas_df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">frame_data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_types</span><span class="p">):</span>
        <span class="n">dtype_str</span> <span class="o">=</span> <span class="n">_sparktk_dtype_to_pandas_str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pandas_df</span><span class="p">[[</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">pandas_df</span><span class="p">[[</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">):</span>
                <span class="c"># DataFrame does not handle missing values in int columns. If we get this error, use the &#39;object&#39; datatype instead.</span>
                <span class="k">print</span> <span class="s">&quot;WARNING - Encountered problem casting column </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">, possibly due to missing values (i.e. presence of None).  Continued by casting column </span><span class="si">%s</span><span class="s"> as &#39;object&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype_str</span><span class="p">,</span> <span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">pandas_df</span><span class="p">[[</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">pandas_df</span><span class="p">[[</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&quot;object&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
    <span class="k">return</span> <span class="n">pandas_df</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.top_k">
    <p>def <span class="ident">top_k</span>(</p><p>self, column_name, k, weight_column=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Most or least frequent column values.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>column_name</td><td class='param-type'>(str):</td><td class='param-desc'>The column whose top (or bottom) K distinct values are to be calculated.
</td></tr></table>

<table><tr><td class='param-name'>k</td><td class='param-type'>(int):</td><td class='param-desc'>Number of entries to return (If k is negative, return bottom k).
</td></tr></table>

<table><tr><td class='param-name'>weight_column</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>The column that provides weights (frequencies) for the topK calculation.
                      Must contain numerical data. Default is 1 for all items.</td></tr></table>

<p>Calculate the top (or bottom) K distinct values by count of a column. The column can be
weighted.  All data elements of weight &lt;= 0 are excluded from the calculation, as are
all data elements whose weight is NaN or infinite. If there are no data elements of
finite weight &gt; 0, then topK is empty.</p>
<div class='section-header'>Examples:</div>

<p>For this example, we calculate the top 2 counties in a data frame:</p>
<p>Consider the following frame:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect(frame.count())
[##]  rank  city         population_2013  population_2010  change  county
=============================================================================
[0]      1  Portland              609456           583776  4.40%   Multnomah
[1]      2  Salem                 160614           154637  3.87%   Marion
[2]      3  Eugene                159190           156185  1.92%   Lane
[3]      4  Gresham               109397           105594  3.60%   Multnomah
[4]      5  Hillsboro              97368            91611  6.28%   Washington
[5]      6  Beaverton              93542            89803  4.16%   Washington
[6]     15  Grants Pass            35076            34533  1.57%   Josephine
[7]     16  Oregon City            34622            31859  8.67%   Clackamas
[8]     17  McMinnville            33131            32187  2.93%   Yamhill
[9]     18  Redmond                27427            26215  4.62%   Deschutes
[10]    19  Tualatin               26879            26054  4.17%   Washington
[11]    20  West Linn              25992            25109  3.52%   Clackamas
[12]     7  Bend                   81236            76639  6.00%   Deschutes
[13]     8  Medford                77677            74907  3.70%   Jackson
[14]     9  Springfield            60177            59403  1.30%   Lane
[15]    10  Corvallis              55298            54462  1.54%   Benton
[16]    11  Albany                 51583            50158  2.84%   Linn
[17]    12  Tigard                 50444            48035  5.02%   Washington
[18]    13  Lake Oswego            37610            36619  2.71%   Clackamas
[19]    14  Keizer                 37064            36478  1.61%   Marion

&gt;&gt;&gt; top_frame = frame.top_k(&quot;county&quot;, 2)
[===Job Progress===]

&gt;&gt;&gt; top_frame.inspect()
[#]  county      count
======================
[0]  Washington    4.0
[1]  Clackamas     3.0
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.top_k', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.top_k" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">top_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight_column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Most or least frequent column values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param column_name: (str) The column whose top (or bottom) K distinct values are to be calculated.</span>
<span class="sd">    :param k: (int) Number of entries to return (If k is negative, return bottom k).</span>
<span class="sd">    :param weight_column: (Optional[str]) The column that provides weights (frequencies) for the topK calculation.</span>
<span class="sd">                          Must contain numerical data. Default is 1 for all items.</span>

<span class="sd">    Calculate the top (or bottom) K distinct values by count of a column. The column can be</span>
<span class="sd">    weighted.  All data elements of weight &lt;= 0 are excluded from the calculation, as are</span>
<span class="sd">    all data elements whose weight is NaN or infinite. If there are no data elements of</span>
<span class="sd">    finite weight &gt; 0, then topK is empty.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For this example, we calculate the top 2 counties in a data frame:</span>


<span class="sd">    Consider the following frame:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect(frame.count())</span>
<span class="sd">        [##]  rank  city         population_2013  population_2010  change  county</span>
<span class="sd">        =============================================================================</span>
<span class="sd">        [0]      1  Portland              609456           583776  4.40%   Multnomah</span>
<span class="sd">        [1]      2  Salem                 160614           154637  3.87%   Marion</span>
<span class="sd">        [2]      3  Eugene                159190           156185  1.92%   Lane</span>
<span class="sd">        [3]      4  Gresham               109397           105594  3.60%   Multnomah</span>
<span class="sd">        [4]      5  Hillsboro              97368            91611  6.28%   Washington</span>
<span class="sd">        [5]      6  Beaverton              93542            89803  4.16%   Washington</span>
<span class="sd">        [6]     15  Grants Pass            35076            34533  1.57%   Josephine</span>
<span class="sd">        [7]     16  Oregon City            34622            31859  8.67%   Clackamas</span>
<span class="sd">        [8]     17  McMinnville            33131            32187  2.93%   Yamhill</span>
<span class="sd">        [9]     18  Redmond                27427            26215  4.62%   Deschutes</span>
<span class="sd">        [10]    19  Tualatin               26879            26054  4.17%   Washington</span>
<span class="sd">        [11]    20  West Linn              25992            25109  3.52%   Clackamas</span>
<span class="sd">        [12]     7  Bend                   81236            76639  6.00%   Deschutes</span>
<span class="sd">        [13]     8  Medford                77677            74907  3.70%   Jackson</span>
<span class="sd">        [14]     9  Springfield            60177            59403  1.30%   Lane</span>
<span class="sd">        [15]    10  Corvallis              55298            54462  1.54%   Benton</span>
<span class="sd">        [16]    11  Albany                 51583            50158  2.84%   Linn</span>
<span class="sd">        [17]    12  Tigard                 50444            48035  5.02%   Washington</span>
<span class="sd">        [18]    13  Lake Oswego            37610            36619  2.71%   Clackamas</span>
<span class="sd">        [19]    14  Keizer                 37064            36478  1.61%   Marion</span>

<span class="sd">        &gt;&gt;&gt; top_frame = frame.top_k(&quot;county&quot;, 2)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; top_frame.inspect()</span>
<span class="sd">        [#]  county      count</span>
<span class="sd">        ======================</span>
<span class="sd">        [0]  Washington    4.0</span>
<span class="sd">        [1]  Clackamas     3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sparktk.frame.frame</span> <span class="kn">import</span> <span class="n">Frame</span>
    <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">topK</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_option</span><span class="p">(</span><span class="n">weight_column</span><span class="p">)))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.unflatten_columns">
    <p>def <span class="ident">unflatten_columns</span>(</p><p>self, columns, delimiter=&#39;,&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Compacts data from multiple rows based on cell data.</p>
<div class='section-header'>Parameters:</div>

<table><tr><td class='param-name'>columns</td><td class='param-type'>(str or List[str]):</td><td class='param-desc'>Name of the column(s) to be used as keys for unflattening.
</td></tr></table>

<table><tr><td class='param-name'>delimiter</td><td class='param-type'>(Optional[str]):</td><td class='param-desc'>Separator for the data in the result columns.  Default is comma (,).</td></tr></table>

<p>Groups together cells in all columns (less the composite key) using "," as string delimiter.
The original rows are deleted.
The grouping takes place based on a composite key created from cell values.
The column datatypes are changed to string.</p>
<div class='section-header'>Examples:</div>

<p>Given a data file::</p>
<div class="codehilite"><pre>user1 1/1/2015 1 70
user1 1/1/2015 2 60
user2 1/1/2015 1 65
</pre></div>


<p>The commands to bring the data into a frame, where it can be worked on:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a      b         c  d
===========================
[0]  user1  1/1/2015  1  70
[1]  user1  1/1/2015  2  60
[2]  user2  1/1/2015  1  65
</pre></div>


<p>Unflatten the data using columns a &amp; b:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.unflatten_columns([&#39;a&#39;,&#39;b&#39;])
[===Job Progress===]
</pre></div>


<p>Check again:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.inspect()
[#]  a      b         c    d
================================
[0]  user1  1/1/2015  1,2  70,60
[1]  user2  1/1/2015  1    65
</pre></div>


<p>Alternatively, unflatten_columns() also accepts a single column like:</p>
<div class="codehilite"><pre>&gt;&gt;&gt; frame.unflatten_columns(&#39;a&#39;)
[===Job Progress===]

&gt;&gt;&gt; frame.inspect()
[#]  a      b                  c    d
=========================================
[0]  user1  1/1/2015,1/1/2015  1,2  70,60
[1]  user2  1/1/2015           1    65
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.unflatten_columns', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.unflatten_columns" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">unflatten_columns</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">&quot;,&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compacts data from multiple rows based on cell data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    :param columns: (str or List[str]) Name of the column(s) to be used as keys for unflattening.</span>
<span class="sd">    :param delimiter: (Optional[str]) Separator for the data in the result columns.  Default is comma (,).</span>

<span class="sd">    Groups together cells in all columns (less the composite key) using &quot;,&quot; as string delimiter.</span>
<span class="sd">    The original rows are deleted.</span>
<span class="sd">    The grouping takes place based on a composite key created from cell values.</span>
<span class="sd">    The column datatypes are changed to string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>


<span class="sd">    Given a data file::</span>

<span class="sd">        user1 1/1/2015 1 70</span>
<span class="sd">        user1 1/1/2015 2 60</span>
<span class="sd">        user2 1/1/2015 1 65</span>

<span class="sd">    The commands to bring the data into a frame, where it can be worked on:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a      b         c  d</span>
<span class="sd">        ===========================</span>
<span class="sd">        [0]  user1  1/1/2015  1  70</span>
<span class="sd">        [1]  user1  1/1/2015  2  60</span>
<span class="sd">        [2]  user2  1/1/2015  1  65</span>


<span class="sd">    Unflatten the data using columns a &amp; b:</span>

<span class="sd">        &gt;&gt;&gt; frame.unflatten_columns([&#39;a&#39;,&#39;b&#39;])</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">    Check again:</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a      b         c    d</span>
<span class="sd">        ================================</span>
<span class="sd">        [0]  user1  1/1/2015  1,2  70,60</span>
<span class="sd">        [1]  user2  1/1/2015  1    65</span>

<span class="sd">    Alternatively, unflatten_columns() also accepts a single column like:</span>


<span class="sd">        &gt;&gt;&gt; frame.unflatten_columns(&#39;a&#39;)</span>
<span class="sd">        [===Job Progress===]</span>

<span class="sd">        &gt;&gt;&gt; frame.inspect()</span>
<span class="sd">        [#]  a      b                  c    d</span>
<span class="sd">        =========================================</span>
<span class="sd">        [0]  user1  1/1/2015,1/1/2015  1,2  70,60</span>
<span class="sd">        [1]  user2  1/1/2015           1    65</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scala</span><span class="o">.</span><span class="n">unflattenColumns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">jutils</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_scala_list_string</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span>
                                        <span class="n">delimiter</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="sparktk.frame.frame.Frame.validate_pyrdd_schema">
    <p>def <span class="ident">validate_pyrdd_schema</span>(</p><p>self, pyrdd, schema)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-sparktk.frame.frame.Frame.validate_pyrdd_schema', this);">Show source &equiv;</a></p>
  <div id="source-sparktk.frame.frame.Frame.validate_pyrdd_schema" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">validate_pyrdd_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyrdd</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pyrdd</span><span class="p">,</span> <span class="n">RDD</span><span class="p">):</span>
        <span class="n">schema_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">num_bad_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">accumulator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">accumulator</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">schema_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of the row (</span><span class="si">%s</span><span class="s">) does not match the schema length (</span><span class="si">%s</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">schema</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">schema</span><span class="p">):</span>
                <span class="n">data_type</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data_type</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                    <span class="n">accumulator</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="n">validated_rdd</span> <span class="o">=</span> <span class="n">pyrdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">validate_schema</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="p">))</span>
        <span class="c"># Force rdd to load, so that we can get a bad value count</span>
        <span class="n">validated_rdd</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SchemaValidationReturn</span><span class="p">(</span><span class="n">validated_rdd</span><span class="p">,</span> <span class="n">num_bad_values</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unable to validate schema, because the pyrdd provided is not an RDD.&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

        </div>
        <div class="clear" />
        <footer id="footer">
          <div>
            spark-tk Python API Documentation
          </div>
        </footer>
      </article>
  </div>
</body>
</html>
